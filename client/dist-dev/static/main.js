/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./app/Errors.js":
/*!***********************!*\
  !*** ./app/Errors.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError),\n/* harmony export */   ExecError: () => (/* binding */ ExecError),\n/* harmony export */   ParseError: () => (/* binding */ ParseError),\n/* harmony export */   ReadError: () => (/* binding */ ReadError),\n/* harmony export */   RequestError: () => (/* binding */ RequestError),\n/* harmony export */   UnhandledError: () => (/* binding */ UnhandledError),\n/* harmony export */   UnknownError: () => (/* binding */ UnknownError),\n/* harmony export */   WriteError: () => (/* binding */ WriteError)\n/* harmony export */ });\nclass BaseError extends Error {\n    constructor(name, wrapErr, message, args) {\n        super();\n        if (args) {\n            for (let key in args) {\n                message += \" \" + key + \"=\" + args[key];\n            }\n        }\n        if (wrapErr) {\n            message += '\\n' + wrapErr;\n        }\n        this.name = name;\n        this.message = message;\n        if (wrapErr) {\n            this.stack = wrapErr.stack;\n        }\n    }\n}\nclass ReadError extends BaseError {\n    constructor(wrapErr, message, args) {\n        super(\"ReadError\", wrapErr, message, args);\n    }\n}\nclass WriteError extends BaseError {\n    constructor(wrapErr, message, args) {\n        super(\"WriteError\", wrapErr, message, args);\n    }\n}\nclass ParseError extends BaseError {\n    constructor(wrapErr, message, args) {\n        super(\"ParseError\", wrapErr, message, args);\n    }\n}\nclass RequestError extends BaseError {\n    constructor(wrapErr, message, args) {\n        super(\"RequestError\", wrapErr, message, args);\n    }\n}\nclass ExecError extends BaseError {\n    constructor(wrapErr, message, args) {\n        super(\"ExecError\", wrapErr, message, args);\n    }\n}\nclass UnknownError extends BaseError {\n    constructor(wrapErr, message, args) {\n        super(\"UnknownError\", wrapErr, message, args);\n    }\n}\nclass UnhandledError extends BaseError {\n    constructor(wrapErr, message, origMessage, origStack) {\n        super(\"UnhandledError\", wrapErr, message, {\n            message: origMessage,\n            stack: origStack,\n        });\n        this.stack = origStack;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9hcHAvRXJyb3JzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRU8sTUFBTSxTQUFVLFNBQVEsS0FBSztJQUtuQyxZQUFZLElBQVksRUFBRSxPQUFjLEVBQUUsT0FBZSxFQUN4RCxJQUEyQjtRQUUzQixLQUFLLEVBQUU7UUFFUCxJQUFJLElBQUksRUFBRSxDQUFDO1lBQ1YsS0FBSyxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUUsQ0FBQztnQkFDdEIsT0FBTyxJQUFJLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxHQUFHLENBQUM7WUFDdkMsQ0FBQztRQUNGLENBQUM7UUFFRCxJQUFJLE9BQU8sRUFBRSxDQUFDO1lBQ2IsT0FBTyxJQUFJLElBQUksR0FBRyxPQUFPO1FBQzFCLENBQUM7UUFFRCxJQUFJLENBQUMsSUFBSSxHQUFHLElBQUk7UUFDaEIsSUFBSSxDQUFDLE9BQU8sR0FBRyxPQUFPO1FBQ3RCLElBQUksT0FBTyxFQUFFLENBQUM7WUFDYixJQUFJLENBQUMsS0FBSyxHQUFHLE9BQU8sQ0FBQyxLQUFLO1FBQzNCLENBQUM7SUFDRixDQUFDO0NBQ0Q7QUFFTSxNQUFNLFNBQVUsU0FBUSxTQUFTO0lBQ3ZDLFlBQVksT0FBYyxFQUFFLE9BQWUsRUFBRSxJQUEyQjtRQUN2RSxLQUFLLENBQUMsV0FBVyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDO0lBQzNDLENBQUM7Q0FDRDtBQUVNLE1BQU0sVUFBVyxTQUFRLFNBQVM7SUFDeEMsWUFBWSxPQUFjLEVBQUUsT0FBZSxFQUFFLElBQTJCO1FBQ3ZFLEtBQUssQ0FBQyxZQUFZLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUM7SUFDNUMsQ0FBQztDQUNEO0FBRU0sTUFBTSxVQUFXLFNBQVEsU0FBUztJQUN4QyxZQUFZLE9BQWMsRUFBRSxPQUFlLEVBQUUsSUFBMkI7UUFDdkUsS0FBSyxDQUFDLFlBQVksRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQztJQUM1QyxDQUFDO0NBQ0Q7QUFFTSxNQUFNLFlBQWEsU0FBUSxTQUFTO0lBQzFDLFlBQVksT0FBYyxFQUFFLE9BQWUsRUFBRSxJQUEyQjtRQUN2RSxLQUFLLENBQUMsY0FBYyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDO0lBQzlDLENBQUM7Q0FDRDtBQUVNLE1BQU0sU0FBVSxTQUFRLFNBQVM7SUFDdkMsWUFBWSxPQUFjLEVBQUUsT0FBZSxFQUFFLElBQTJCO1FBQ3ZFLEtBQUssQ0FBQyxXQUFXLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUM7SUFDM0MsQ0FBQztDQUNEO0FBRU0sTUFBTSxZQUFhLFNBQVEsU0FBUztJQUMxQyxZQUFZLE9BQWMsRUFBRSxPQUFlLEVBQUUsSUFBMkI7UUFDdkUsS0FBSyxDQUFDLGNBQWMsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQztJQUM5QyxDQUFDO0NBQ0Q7QUFFTSxNQUFNLGNBQWUsU0FBUSxTQUFTO0lBQzVDLFlBQVksT0FBYyxFQUFFLE9BQWUsRUFBRSxXQUFtQixFQUMvRCxTQUFpQjtRQUVqQixLQUFLLENBQUMsZ0JBQWdCLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRTtZQUN6QyxPQUFPLEVBQUUsV0FBVztZQUNwQixLQUFLLEVBQUUsU0FBUztTQUNoQixDQUFDO1FBQ0YsSUFBSSxDQUFDLEtBQUssR0FBRyxTQUFTO0lBQ3ZCLENBQUM7Q0FDRCIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9hcHAvRXJyb3JzLnRzPzA0MGIiXSwic291cmNlc0NvbnRlbnQiOlsiLy8vIDxyZWZlcmVuY2UgcGF0aD1cIi4vUmVmZXJlbmNlcy5kLnRzXCIvPlxuXG5leHBvcnQgY2xhc3MgQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRuYW1lOiBzdHJpbmdcblx0bWVzc2FnZTogc3RyaW5nXG5cdHN0YWNrOiBzdHJpbmdcblxuXHRjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIHdyYXBFcnI6IEVycm9yLCBtZXNzYWdlOiBzdHJpbmcsXG5cdFx0YXJncz86IHtba2V5OiBzdHJpbmddOiBhbnl9KSB7XG5cblx0XHRzdXBlcigpXG5cblx0XHRpZiAoYXJncykge1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIGFyZ3MpIHtcblx0XHRcdFx0bWVzc2FnZSArPSBcIiBcIiArIGtleSArIFwiPVwiICsgYXJnc1trZXldXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHdyYXBFcnIpIHtcblx0XHRcdG1lc3NhZ2UgKz0gJ1xcbicgKyB3cmFwRXJyXG5cdFx0fVxuXG5cdFx0dGhpcy5uYW1lID0gbmFtZVxuXHRcdHRoaXMubWVzc2FnZSA9IG1lc3NhZ2Vcblx0XHRpZiAod3JhcEVycikge1xuXHRcdFx0dGhpcy5zdGFjayA9IHdyYXBFcnIuc3RhY2tcblx0XHR9XG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIFJlYWRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHdyYXBFcnI6IEVycm9yLCBtZXNzYWdlOiBzdHJpbmcsIGFyZ3M/OiB7W2tleTogc3RyaW5nXTogYW55fSkge1xuXHRcdHN1cGVyKFwiUmVhZEVycm9yXCIsIHdyYXBFcnIsIG1lc3NhZ2UsIGFyZ3MpXG5cdH1cbn1cblxuZXhwb3J0IGNsYXNzIFdyaXRlRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuXHRjb25zdHJ1Y3Rvcih3cmFwRXJyOiBFcnJvciwgbWVzc2FnZTogc3RyaW5nLCBhcmdzPzoge1trZXk6IHN0cmluZ106IGFueX0pIHtcblx0XHRzdXBlcihcIldyaXRlRXJyb3JcIiwgd3JhcEVyciwgbWVzc2FnZSwgYXJncylcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgUGFyc2VFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHdyYXBFcnI6IEVycm9yLCBtZXNzYWdlOiBzdHJpbmcsIGFyZ3M/OiB7W2tleTogc3RyaW5nXTogYW55fSkge1xuXHRcdHN1cGVyKFwiUGFyc2VFcnJvclwiLCB3cmFwRXJyLCBtZXNzYWdlLCBhcmdzKVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuXHRjb25zdHJ1Y3Rvcih3cmFwRXJyOiBFcnJvciwgbWVzc2FnZTogc3RyaW5nLCBhcmdzPzoge1trZXk6IHN0cmluZ106IGFueX0pIHtcblx0XHRzdXBlcihcIlJlcXVlc3RFcnJvclwiLCB3cmFwRXJyLCBtZXNzYWdlLCBhcmdzKVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBFeGVjRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuXHRjb25zdHJ1Y3Rvcih3cmFwRXJyOiBFcnJvciwgbWVzc2FnZTogc3RyaW5nLCBhcmdzPzoge1trZXk6IHN0cmluZ106IGFueX0pIHtcblx0XHRzdXBlcihcIkV4ZWNFcnJvclwiLCB3cmFwRXJyLCBtZXNzYWdlLCBhcmdzKVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBVbmtub3duRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuXHRjb25zdHJ1Y3Rvcih3cmFwRXJyOiBFcnJvciwgbWVzc2FnZTogc3RyaW5nLCBhcmdzPzoge1trZXk6IHN0cmluZ106IGFueX0pIHtcblx0XHRzdXBlcihcIlVua25vd25FcnJvclwiLCB3cmFwRXJyLCBtZXNzYWdlLCBhcmdzKVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBVbmhhbmRsZWRFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHdyYXBFcnI6IEVycm9yLCBtZXNzYWdlOiBzdHJpbmcsIG9yaWdNZXNzYWdlOiBzdHJpbmcsXG5cdFx0b3JpZ1N0YWNrOiBzdHJpbmcpIHtcblxuXHRcdHN1cGVyKFwiVW5oYW5kbGVkRXJyb3JcIiwgd3JhcEVyciwgbWVzc2FnZSwge1xuXHRcdFx0bWVzc2FnZTogb3JpZ01lc3NhZ2UsXG5cdFx0XHRzdGFjazogb3JpZ1N0YWNrLFxuXHRcdH0pXG5cdFx0dGhpcy5zdGFjayA9IG9yaWdTdGFja1xuXHR9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./app/Errors.js\n");

/***/ }),

/***/ "./app/utils/MiscUtils.js":
/*!********************************!*\
  !*** ./app/utils/MiscUtils.js ***!
  \********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   capitalize: () => (/* binding */ capitalize),\n/* harmony export */   decryptString: () => (/* binding */ decryptString),\n/* harmony export */   encryptAvailable: () => (/* binding */ encryptAvailable),\n/* harmony export */   encryptString: () => (/* binding */ encryptString),\n/* harmony export */   exec: () => (/* binding */ exec),\n/* harmony export */   fileDelete: () => (/* binding */ fileDelete),\n/* harmony export */   fileExists: () => (/* binding */ fileExists),\n/* harmony export */   fileRead: () => (/* binding */ fileRead),\n/* harmony export */   fileSize: () => (/* binding */ fileSize),\n/* harmony export */   fileWrite: () => (/* binding */ fileWrite),\n/* harmony export */   formatAmount: () => (/* binding */ formatAmount),\n/* harmony export */   formatDate: () => (/* binding */ formatDate),\n/* harmony export */   formatDateLess: () => (/* binding */ formatDateLess),\n/* harmony export */   formatDateShort: () => (/* binding */ formatDateShort),\n/* harmony export */   formatDateShortTime: () => (/* binding */ formatDateShortTime),\n/* harmony export */   getDeviceIdentifier: () => (/* binding */ getDeviceIdentifier),\n/* harmony export */   nonce: () => (/* binding */ nonce),\n/* harmony export */   objectIdNil: () => (/* binding */ objectIdNil),\n/* harmony export */   shuffle: () => (/* binding */ shuffle),\n/* harmony export */   tarRead: () => (/* binding */ tarRead),\n/* harmony export */   titleCase: () => (/* binding */ titleCase),\n/* harmony export */   uriFromPath: () => (/* binding */ uriFromPath),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   uuidRand: () => (/* binding */ uuidRand),\n/* harmony export */   zeroPad: () => (/* binding */ zeroPad)\n/* harmony export */ });\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Errors */ \"./app/Errors.js\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var tar__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tar */ \"./node_modules/tar/index.js\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_5__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\nfunction getDeviceIdentifier() {\n    return new Promise((resolve, reject) => {\n        const platform = os__WEBPACK_IMPORTED_MODULE_2___default().platform();\n        let command;\n        if (platform === \"linux\") {\n            command = \"cat /sys/class/dmi/id/product_uuid || sudo dmidecode -s system-serial-number\";\n        }\n        else if (platform === \"win32\") {\n            command = \"wmic bios get serialnumber\";\n        }\n        else if (platform === \"darwin\") {\n            command = \"ioreg -l | grep IOPlatformSerialNumber\";\n        }\n        else {\n            return reject(new Error(\"Unsupported platform\"));\n        }\n        child_process__WEBPACK_IMPORTED_MODULE_4___default().exec(command, (error, stdout, stderr) => {\n            if (error) {\n                return reject(error);\n            }\n            if (stderr) {\n                return reject(new Error(stderr));\n            }\n            let serial = stdout.toString().trim();\n            if (platform === \"win32\") {\n                serial = serial.split(\"\\n\").filter(l => l && !l.toLowerCase().includes(\"serial\"))[0]?.trim();\n            }\n            else if (platform === \"darwin\") {\n                const match = serial.match(/\"IOPlatformSerialNumber\"\\s=\\s\"(.+)\"/);\n                serial = match ? match[1].trim() : serial;\n            }\n            resolve(serial);\n        });\n    });\n}\nfunction uuid() {\n    return (+new Date() + Math.floor(Math.random() * 999999)).toString(36);\n}\nfunction uuidRand() {\n    let id = \"\";\n    for (let i = 0; i < 4; i++) {\n        id += Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n    return id;\n}\nfunction nonce() {\n    let nonce = '';\n    for (let i = 0; i < 8; i++) {\n        nonce += Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n    return nonce;\n}\nfunction titleCase(str) {\n    return str\n        .toLowerCase()\n        .split(' ')\n        .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n        .join(' ');\n}\nfunction shuffle(n) {\n    let i = n.length, j;\n    while (i != 0) {\n        j = Math.floor(Math.random() * i);\n        i--;\n        [n[i], n[j]] = [n[j], n[i]];\n    }\n    return n;\n}\nfunction objectIdNil(objId) {\n    return !objId || objId == '000000000000000000000000';\n}\nfunction zeroPad(num, width) {\n    if (num < Math.pow(10, width)) {\n        return ('0'.repeat(width - 1) + num).slice(-width);\n    }\n    return num.toString();\n}\nfunction capitalize(str) {\n    return str.charAt(0).toUpperCase() + str.slice(1);\n}\nfunction formatAmount(amount) {\n    if (!amount) {\n        return '-';\n    }\n    return '$' + (amount / 100).toFixed(2);\n}\nfunction formatDate(dateData) {\n    if (!dateData || dateData === '0001-01-01T00:00:00Z') {\n        return '';\n    }\n    let date;\n    if (dateData instanceof String) {\n        date = new Date(dateData);\n    }\n    else {\n        date = new Date(0);\n        date.setUTCSeconds(dateData);\n    }\n    let str = '';\n    let hours = date.getHours();\n    let period = 'AM';\n    if (hours > 12) {\n        period = 'PM';\n        hours -= 12;\n    }\n    else if (hours === 0) {\n        hours = 12;\n    }\n    let day;\n    switch (date.getDay()) {\n        case 0:\n            day = 'Sun';\n            break;\n        case 1:\n            day = 'Mon';\n            break;\n        case 2:\n            day = 'Tue';\n            break;\n        case 3:\n            day = 'Wed';\n            break;\n        case 4:\n            day = 'Thu';\n            break;\n        case 5:\n            day = 'Fri';\n            break;\n        case 6:\n            day = 'Sat';\n            break;\n    }\n    let month;\n    switch (date.getMonth()) {\n        case 0:\n            month = 'Jan';\n            break;\n        case 1:\n            month = 'Feb';\n            break;\n        case 2:\n            month = 'Mar';\n            break;\n        case 3:\n            month = 'Apr';\n            break;\n        case 4:\n            month = 'May';\n            break;\n        case 5:\n            month = 'Jun';\n            break;\n        case 6:\n            month = 'Jul';\n            break;\n        case 7:\n            month = 'Aug';\n            break;\n        case 8:\n            month = 'Sep';\n            break;\n        case 9:\n            month = 'Oct';\n            break;\n        case 10:\n            month = 'Nov';\n            break;\n        case 11:\n            month = 'Dec';\n            break;\n    }\n    str += day + ' ';\n    str += date.getDate() + ' ';\n    str += month + ' ';\n    str += date.getFullYear() + ', ';\n    str += hours + ':';\n    str += zeroPad(date.getMinutes(), 2) + ':';\n    str += zeroPad(date.getSeconds(), 2) + ' ';\n    str += period;\n    return str;\n}\nfunction formatDateLess(dateData) {\n    if (!dateData || dateData === '0001-01-01T00:00:00Z') {\n        return '';\n    }\n    let date;\n    if (dateData instanceof String) {\n        date = new Date(dateData);\n    }\n    else {\n        date = new Date(0);\n        date.setUTCSeconds(dateData);\n    }\n    let str = '';\n    let hours = date.getHours();\n    let period = 'AM';\n    if (hours > 12) {\n        period = 'PM';\n        hours -= 12;\n    }\n    else if (hours === 0) {\n        hours = 12;\n    }\n    let month;\n    switch (date.getMonth()) {\n        case 0:\n            month = 'Jan';\n            break;\n        case 1:\n            month = 'Feb';\n            break;\n        case 2:\n            month = 'Mar';\n            break;\n        case 3:\n            month = 'Apr';\n            break;\n        case 4:\n            month = 'May';\n            break;\n        case 5:\n            month = 'Jun';\n            break;\n        case 6:\n            month = 'Jul';\n            break;\n        case 7:\n            month = 'Aug';\n            break;\n        case 8:\n            month = 'Sep';\n            break;\n        case 9:\n            month = 'Oct';\n            break;\n        case 10:\n            month = 'Nov';\n            break;\n        case 11:\n            month = 'Dec';\n            break;\n    }\n    str += month + ' ';\n    str += date.getDate() + ' ';\n    str += date.getFullYear() + ', ';\n    str += hours + ':';\n    str += zeroPad(date.getMinutes(), 2);\n    str += period;\n    return str;\n}\nfunction formatDateShort(dateData) {\n    if (!dateData || dateData === '0001-01-01T00:00:00Z') {\n        return '';\n    }\n    let date;\n    if (dateData instanceof String) {\n        date = new Date(dateData);\n    }\n    else {\n        date = new Date(0);\n        date.setUTCSeconds(dateData);\n    }\n    let curDate = new Date();\n    let month;\n    switch (date.getMonth()) {\n        case 0:\n            month = 'Jan';\n            break;\n        case 1:\n            month = 'Feb';\n            break;\n        case 2:\n            month = 'Mar';\n            break;\n        case 3:\n            month = 'Apr';\n            break;\n        case 4:\n            month = 'May';\n            break;\n        case 5:\n            month = 'Jun';\n            break;\n        case 6:\n            month = 'Jul';\n            break;\n        case 7:\n            month = 'Aug';\n            break;\n        case 8:\n            month = 'Sep';\n            break;\n        case 9:\n            month = 'Oct';\n            break;\n        case 10:\n            month = 'Nov';\n            break;\n        case 11:\n            month = 'Dec';\n            break;\n    }\n    let str = month + ' ' + date.getDate();\n    if (date.getFullYear() !== curDate.getFullYear()) {\n        str += ' ' + date.getFullYear();\n    }\n    return str;\n}\nfunction formatDateShortTime(dateData) {\n    if (!dateData || dateData === '0001-01-01T00:00:00Z') {\n        return '';\n    }\n    let date;\n    if (dateData instanceof String) {\n        date = new Date(dateData);\n    }\n    else {\n        date = new Date(0);\n        date.setUTCSeconds(dateData);\n    }\n    let curDate = new Date();\n    let month;\n    switch (date.getMonth()) {\n        case 0:\n            month = 'Jan';\n            break;\n        case 1:\n            month = 'Feb';\n            break;\n        case 2:\n            month = 'Mar';\n            break;\n        case 3:\n            month = 'Apr';\n            break;\n        case 4:\n            month = 'May';\n            break;\n        case 5:\n            month = 'Jun';\n            break;\n        case 6:\n            month = 'Jul';\n            break;\n        case 7:\n            month = 'Aug';\n            break;\n        case 8:\n            month = 'Sep';\n            break;\n        case 9:\n            month = 'Oct';\n            break;\n        case 10:\n            month = 'Nov';\n            break;\n        case 11:\n            month = 'Dec';\n            break;\n    }\n    let str = month + ' ' + date.getDate();\n    if (date.getFullYear() !== curDate.getFullYear()) {\n        str += ' ' + date.getFullYear();\n    }\n    else if (date.getMonth() === curDate.getMonth() &&\n        date.getDate() === curDate.getDate()) {\n        let hours = date.getHours();\n        let period = 'AM';\n        if (hours > 12) {\n            period = 'PM';\n            hours -= 12;\n        }\n        else if (hours === 0) {\n            hours = 12;\n        }\n        str = hours + ':';\n        str += zeroPad(date.getMinutes(), 2) + ':';\n        str += zeroPad(date.getSeconds(), 2) + ' ';\n        str += period;\n    }\n    return str;\n}\nfunction exec(path, ...args) {\n    return new Promise((resolve) => {\n        child_process__WEBPACK_IMPORTED_MODULE_4___default().execFile(path, args, (err, stdout, stderr) => {\n            if (err) {\n                err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ExecError(err, \"Utils: Exec error\", { path: path, args: args, stdout: stdout, stderr: stderr });\n            }\n            resolve({\n                stdout: stdout,\n                stderr: stderr,\n                error: err,\n            });\n        });\n    });\n}\nfunction fileExists(path) {\n    return new Promise((resolve) => {\n        fs__WEBPACK_IMPORTED_MODULE_1___default().stat(path, (err, stat) => {\n            if (!err) {\n                resolve(true);\n            }\n            else {\n                resolve(false);\n            }\n        });\n    });\n}\nfunction fileSize(path) {\n    return new Promise((resolve) => {\n        fs__WEBPACK_IMPORTED_MODULE_1___default().stat(path, (err, stat) => {\n            if (err || !stat) {\n                resolve(0);\n            }\n            resolve(stat.size || 0);\n        });\n    });\n}\nfunction fileDelete(path) {\n    return new Promise((resolve, reject) => {\n        fs__WEBPACK_IMPORTED_MODULE_1___default().exists(path, (exists) => {\n            if (!exists) {\n                resolve();\n                return;\n            }\n            fs__WEBPACK_IMPORTED_MODULE_1___default().unlink(path, (err) => {\n                if (err) {\n                    err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.WriteError(err, \"Utils: Failed to delete file\", { path: path });\n                    reject(err);\n                    return;\n                }\n                resolve();\n            });\n        });\n    });\n}\nfunction fileRead(path) {\n    return new Promise((resolve, reject) => {\n        fs__WEBPACK_IMPORTED_MODULE_1___default().readFile(path, \"utf-8\", (err, data) => {\n            if (err) {\n                err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ReadError(err, \"Utils: Failed to read file\", { path: path });\n                reject(err);\n                return;\n            }\n            resolve(data);\n        });\n    });\n}\nfunction fileWrite(path, data) {\n    return new Promise((resolve, reject) => {\n        fs__WEBPACK_IMPORTED_MODULE_1___default().writeFile(path, data, (err) => {\n            if (err) {\n                err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.WriteError(err, \"Utils: Failed to write file\", { path: path });\n                reject(err);\n                return;\n            }\n            resolve();\n        });\n    });\n}\nfunction uriFromPath(pth) {\n    const pathName = path__WEBPACK_IMPORTED_MODULE_6___default().resolve(pth).replace(/\\\\/g, \"/\");\n    return encodeURI(\"file://\" + (pathName.charAt(0) !== \"/\" ?\n        \"/\" + pathName : pathName));\n}\nfunction encryptAvailable() {\n    return new Promise((resolve, reject) => {\n        try {\n            let evt = electron__WEBPACK_IMPORTED_MODULE_5___default().ipcRenderer.invoke(\"processing\", \"encryptable\");\n            evt.then((resp) => {\n                if (!resp) {\n                    let err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(null, \"Utils: Failed to check encryption support e1\");\n                    reject(err);\n                }\n                else if (resp[0]) {\n                    let err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(resp[0], \"Utils: Failed to check encryption support e2\");\n                    reject(err);\n                }\n                else {\n                    resolve(resp[1]);\n                }\n            }).catch((err) => {\n                err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(err, \"Utils: Failed to check encryption support e3\");\n                reject(err);\n            });\n        }\n        catch (err) {\n            err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(err, \"Utils: Failed to check encryption support e4\");\n            reject(err);\n        }\n    });\n}\nfunction encryptString(decData) {\n    return new Promise((resolve, reject) => {\n        try {\n            let evt = electron__WEBPACK_IMPORTED_MODULE_5___default().ipcRenderer.invoke(\"processing\", \"encrypt\", decData);\n            evt.then((resp) => {\n                if (!resp) {\n                    let err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(null, \"Utils: Failed to encrypt string e1\");\n                    reject(err);\n                }\n                else if (resp[0]) {\n                    let err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(resp[0], \"Utils: Failed to encrypt string e2\");\n                    reject(err);\n                }\n                else {\n                    resolve(resp[1]);\n                }\n            }).catch((err) => {\n                err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(err, \"Utils: Failed to encrypt string e3\");\n                reject(err);\n            });\n        }\n        catch (err) {\n            err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(err, \"Utils: Failed to encrypt string e4\");\n            reject(err);\n        }\n    });\n}\nfunction decryptString(encData) {\n    return new Promise((resolve, reject) => {\n        try {\n            let evt = electron__WEBPACK_IMPORTED_MODULE_5___default().ipcRenderer.invoke(\"processing\", \"decrypt\", encData);\n            evt.then((resp) => {\n                if (!resp) {\n                    let err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(null, \"Utils: Failed to decrypt string e1\");\n                    reject(err);\n                }\n                else if (resp[0]) {\n                    let err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(resp[0], \"Utils: Failed to decrypt string e2\");\n                    reject(err);\n                }\n                else {\n                    resolve(resp[1]);\n                }\n            }).catch((err) => {\n                err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(err, \"Utils: Failed to decrypt string e3\");\n                reject(err);\n            });\n        }\n        catch (err) {\n            err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ParseError(err, \"Utils: Failed to decrypt string e4\");\n            reject(err);\n        }\n    });\n}\nfunction tarRead(path) {\n    return new Promise((resolve, reject) => {\n        try {\n            let files = [];\n            let parser = new tar__WEBPACK_IMPORTED_MODULE_3__.Parse();\n            fs__WEBPACK_IMPORTED_MODULE_1___default().createReadStream(path)\n                .pipe(parser)\n                .on(\"entry\", (entry) => {\n                let data = \"\";\n                entry.on(\"data\", (content) => {\n                    data += content.toString();\n                });\n                entry.on(\"end\", () => {\n                    files.push({\n                        path: entry.path,\n                        data: data,\n                    });\n                });\n            })\n                .on(\"end\", () => {\n                resolve(files);\n            });\n        }\n        catch (err) {\n            err = new _Errors__WEBPACK_IMPORTED_MODULE_0__.ReadError(err, \"Utils: Failed to read tar file\", { path: path });\n            reject(err);\n        }\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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UyxPQUFPLENBQUMsSUFBWTtJQUNuQyxPQUFPLElBQUksT0FBTyxDQUFZLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBUSxFQUFFO1FBQ3ZELElBQUksQ0FBQztZQUNKLElBQUksS0FBSyxHQUFjLEVBQUU7WUFDekIsSUFBSSxNQUFNLEdBQUcsSUFBSSxzQ0FBUyxFQUFFO1lBRTVCLDBEQUFtQixDQUFDLElBQUksQ0FBQztpQkFDdkIsSUFBSSxDQUFDLE1BQU0sQ0FBQztpQkFDWixFQUFFLENBQUMsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7Z0JBQ3RCLElBQUksSUFBSSxHQUFHLEVBQUU7Z0JBRWIsS0FBSyxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxPQUFPLEVBQUUsRUFBRTtvQkFDNUIsSUFBSSxJQUFJLE9BQU8sQ0FBQyxRQUFRLEVBQUU7Z0JBQzNCLENBQUMsQ0FBQztnQkFDRixLQUFLLENBQUMsRUFBRSxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUU7b0JBQ3BCLEtBQUssQ0FBQyxJQUFJLENBQUM7d0JBQ1YsSUFBSSxFQUFFLEtBQUssQ0FBQyxJQUFJO3dCQUNoQixJQUFJLEVBQUUsSUFBSTtxQkFDVixDQUFDO2dCQUNILENBQUMsQ0FBQztZQUNILENBQUMsQ0FBQztpQkFDRCxFQUFFLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRTtnQkFDZixPQUFPLENBQUMsS0FBSyxDQUFDO1lBQ2YsQ0FBQyxDQUFDO1FBQ0osQ0FBQztRQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7WUFDZCxHQUFHLEdBQUcsSUFBSSw4Q0FBZ0IsQ0FBQyxHQUFHLEVBQUUsZ0NBQWdDLEVBQy9ELEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7WUFDakIsTUFBTSxDQUFDLEdBQUcsQ0FBQztRQUNaLENBQUM7SUFDRixDQUFDLENBQUM7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL2FwcC91dGlscy9NaXNjVXRpbHMudHM/MTIxZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vUmVmZXJlbmNlcy5kLnRzXCIvPlxuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gXCIuLi9FcnJvcnNcIlxuaW1wb3J0IGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0IG9zIGZyb20gXCJvc1wiO1xuaW1wb3J0IHRhciBmcm9tIFwidGFyXCI7XG5pbXBvcnQgY2hpbGRQcm9jZXNzIGZyb20gXCJjaGlsZF9wcm9jZXNzXCI7XG5pbXBvcnQgZWxlY3Ryb24gZnJvbSBcImVsZWN0cm9uXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBnZXREZXZpY2VJZGVudGlmaWVyKCkge1xuXG5cdHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpID0+IHtcblx0XHRjb25zdCBwbGF0Zm9ybSA9IG9zLnBsYXRmb3JtKCk7XG5cdFx0bGV0IGNvbW1hbmQ7XG5cdFx0aWYgKHBsYXRmb3JtID09PSBcImxpbnV4XCIpIHtcblx0XHRcdGNvbW1hbmQgPSBcImNhdCAvc3lzL2NsYXNzL2RtaS9pZC9wcm9kdWN0X3V1aWQgfHwgc3VkbyBkbWlkZWNvZGUgLXMgc3lzdGVtLXNlcmlhbC1udW1iZXJcIjtcblx0XHR9IGVsc2UgaWYgKHBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcblx0XHRcdGNvbW1hbmQgPSBcIndtaWMgYmlvcyBnZXQgc2VyaWFsbnVtYmVyXCI7XG5cdFx0fSBlbHNlIGlmIChwbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIikge1xuXHRcdFx0Y29tbWFuZCA9IFwiaW9yZWcgLWwgfCBncmVwIElPUGxhdGZvcm1TZXJpYWxOdW1iZXJcIjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJVbnN1cHBvcnRlZCBwbGF0Zm9ybVwiKSk7XG5cdFx0fVxuXG5cdFx0Y2hpbGRQcm9jZXNzLmV4ZWMoY29tbWFuZCwgKGVycm9yLCBzdGRvdXQsIHN0ZGVycikgPT4ge1xuXHRcdFx0aWYgKGVycm9yKSB7XG5cdFx0XHRcdHJldHVybiByZWplY3QoZXJyb3IpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0ZGVycikge1xuXHRcdFx0XHRyZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihzdGRlcnIpKTtcblx0XHRcdH1cblxuXHRcdFx0bGV0IHNlcmlhbCA9IHN0ZG91dC50b1N0cmluZygpLnRyaW0oKTtcblxuXHRcdFx0aWYgKHBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcblx0XHRcdFx0c2VyaWFsID0gc2VyaWFsLnNwbGl0KFwiXFxuXCIpLmZpbHRlcihsID0+IGwgJiYgIWwudG9Mb3dlckNhc2UoKS5pbmNsdWRlcyhcInNlcmlhbFwiKSlbMF0/LnRyaW0oKTtcblx0XHRcdH0gZWxzZSBpZiAocGxhdGZvcm0gPT09IFwiZGFyd2luXCIpIHtcblx0XHRcdFx0Y29uc3QgbWF0Y2ggPSBzZXJpYWwubWF0Y2goL1wiSU9QbGF0Zm9ybVNlcmlhbE51bWJlclwiXFxzPVxcc1wiKC4rKVwiLyk7XG5cdFx0XHRcdHNlcmlhbCA9IG1hdGNoID8gbWF0Y2hbMV0udHJpbSgpIDogc2VyaWFsO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNvbHZlKHNlcmlhbCk7XG5cdFx0fSk7XG5cblx0fSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1dWlkKCk6IHN0cmluZyB7XG5cdHJldHVybiAoK25ldyBEYXRlKCkgKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiA5OTk5OTkpKS50b1N0cmluZygzNik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1dWlkUmFuZCgpOiBzdHJpbmcge1xuXHRsZXQgaWQgPSBcIlwiXG5cblx0Zm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRpZCArPSBNYXRoLmZsb29yKCgxICsgTWF0aC5yYW5kb20oKSkgKiAweDEwMDAwKS50b1N0cmluZyhcblx0XHRcdDE2KS5zdWJzdHJpbmcoMSk7XG5cdH1cblxuXHRyZXR1cm4gaWQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBub25jZSgpOiBzdHJpbmcge1xuXHRsZXQgbm9uY2UgPSAnJ1xuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgODsgaSsrKSB7XG5cdFx0bm9uY2UgKz0gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkudG9TdHJpbmcoXG5cdFx0XHQxNikuc3Vic3RyaW5nKDEpXG5cdH1cblxuXHRyZXR1cm4gbm9uY2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRpdGxlQ2FzZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XG5cdHJldHVybiBzdHJcblx0XHQudG9Mb3dlckNhc2UoKVxuXHRcdC5zcGxpdCgnICcpXG5cdFx0Lm1hcCh3b3JkID0+IHdvcmQuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyB3b3JkLnNsaWNlKDEpKVxuXHRcdC5qb2luKCcgJyk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaHVmZmxlKG46IGFueVtdKTogYW55W10ge1xuXHRsZXQgaSA9IG4ubGVuZ3RoLCBqXG5cdHdoaWxlIChpICE9IDApIHtcblx0XHRqID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogaSlcblx0XHRpLS1cblx0XHRbbltpXSwgbltqXV0gPSBbbltqXSwgbltpXV1cblx0fVxuXHRyZXR1cm4gblxufVxuXG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0SWROaWwob2JqSWQ6IHN0cmluZyk6IGJvb2xlYW4ge1xuXHRyZXR1cm4gIW9iaklkIHx8IG9iaklkID09ICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gemVyb1BhZChudW06IG51bWJlciwgd2lkdGg6IG51bWJlcik6IHN0cmluZyB7XG5cdGlmIChudW0gPCBNYXRoLnBvdygxMCwgd2lkdGgpKSB7XG5cdFx0cmV0dXJuICgnMCcucmVwZWF0KHdpZHRoIC0gMSkgKyBudW0pLnNsaWNlKC13aWR0aCk7XG5cdH1cblx0cmV0dXJuIG51bS50b1N0cmluZygpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2FwaXRhbGl6ZShzdHI6IHN0cmluZyk6IHN0cmluZyB7XG5cdHJldHVybiBzdHIuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBzdHIuc2xpY2UoMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBbW91bnQoYW1vdW50OiBudW1iZXIpOiBzdHJpbmcge1xuXHRpZiAoIWFtb3VudCkge1xuXHRcdHJldHVybiAnLSc7XG5cdH1cblx0cmV0dXJuICckJyArIChhbW91bnQgLyAxMDApLnRvRml4ZWQoMik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlKGRhdGVEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRpZiAoIWRhdGVEYXRhIHx8IGRhdGVEYXRhID09PSAnMDAwMS0wMS0wMVQwMDowMDowMFonKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0bGV0IGRhdGU6IERhdGU7XG5cdGlmIChkYXRlRGF0YSBpbnN0YW5jZW9mIFN0cmluZykge1xuXHRcdGRhdGUgPSBuZXcgRGF0ZShkYXRlRGF0YSBhcyBzdHJpbmcpO1xuXHR9IGVsc2Uge1xuXHRcdGRhdGUgPSBuZXcgRGF0ZSgwKVxuXHRcdGRhdGUuc2V0VVRDU2Vjb25kcyhkYXRlRGF0YSBhcyBudW1iZXIpXG5cdH1cblxuXHRsZXQgc3RyID0gJyc7XG5cblx0bGV0IGhvdXJzID0gZGF0ZS5nZXRIb3VycygpO1xuXHRsZXQgcGVyaW9kID0gJ0FNJztcblxuXHRpZiAoaG91cnMgPiAxMikge1xuXHRcdHBlcmlvZCA9ICdQTSc7XG5cdFx0aG91cnMgLT0gMTI7XG5cdH0gZWxzZSBpZiAoaG91cnMgPT09IDApIHtcblx0XHRob3VycyA9IDEyO1xuXHR9XG5cblx0bGV0IGRheTtcblx0c3dpdGNoIChkYXRlLmdldERheSgpKSB7XG5cdFx0Y2FzZSAwOlxuXHRcdFx0ZGF5ID0gJ1N1bic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDE6XG5cdFx0XHRkYXkgPSAnTW9uJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdGRheSA9ICdUdWUnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAzOlxuXHRcdFx0ZGF5ID0gJ1dlZCc7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDQ6XG5cdFx0XHRkYXkgPSAnVGh1Jztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgNTpcblx0XHRcdGRheSA9ICdGcmknO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA2OlxuXHRcdFx0ZGF5ID0gJ1NhdCc7XG5cdFx0XHRicmVhaztcblx0fVxuXG5cdGxldCBtb250aDtcblx0c3dpdGNoIChkYXRlLmdldE1vbnRoKCkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRtb250aCA9ICdKYW4nO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0bW9udGggPSAnRmViJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdG1vbnRoID0gJ01hcic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRtb250aCA9ICdBcHInO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0bW9udGggPSAnTWF5Jztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgNTpcblx0XHRcdG1vbnRoID0gJ0p1bic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDY6XG5cdFx0XHRtb250aCA9ICdKdWwnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA3OlxuXHRcdFx0bW9udGggPSAnQXVnJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgODpcblx0XHRcdG1vbnRoID0gJ1NlcCc7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDk6XG5cdFx0XHRtb250aCA9ICdPY3QnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxMDpcblx0XHRcdG1vbnRoID0gJ05vdic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDExOlxuXHRcdFx0bW9udGggPSAnRGVjJztcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0c3RyICs9IGRheSArICcgJztcblx0c3RyICs9IGRhdGUuZ2V0RGF0ZSgpICsgJyAnO1xuXHRzdHIgKz0gbW9udGggKyAnICc7XG5cdHN0ciArPSBkYXRlLmdldEZ1bGxZZWFyKCkgKyAnLCAnO1xuXHRzdHIgKz0gaG91cnMgKyAnOic7XG5cdHN0ciArPSB6ZXJvUGFkKGRhdGUuZ2V0TWludXRlcygpLCAyKSArICc6Jztcblx0c3RyICs9IHplcm9QYWQoZGF0ZS5nZXRTZWNvbmRzKCksIDIpICsgJyAnO1xuXHRzdHIgKz0gcGVyaW9kO1xuXG5cdHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlTGVzcyhkYXRlRGF0YTogYW55KTogc3RyaW5nIHtcblx0aWYgKCFkYXRlRGF0YSB8fCBkYXRlRGF0YSA9PT0gJzAwMDEtMDEtMDFUMDA6MDA6MDBaJykge1xuXHRcdHJldHVybiAnJztcblx0fVxuXG5cdGxldCBkYXRlOiBEYXRlO1xuXHRpZiAoZGF0ZURhdGEgaW5zdGFuY2VvZiBTdHJpbmcpIHtcblx0XHRkYXRlID0gbmV3IERhdGUoZGF0ZURhdGEgYXMgc3RyaW5nKTtcblx0fSBlbHNlIHtcblx0XHRkYXRlID0gbmV3IERhdGUoMClcblx0XHRkYXRlLnNldFVUQ1NlY29uZHMoZGF0ZURhdGEgYXMgbnVtYmVyKVxuXHR9XG5cblx0bGV0IHN0ciA9ICcnO1xuXG5cdGxldCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKTtcblx0bGV0IHBlcmlvZCA9ICdBTSc7XG5cblx0aWYgKGhvdXJzID4gMTIpIHtcblx0XHRwZXJpb2QgPSAnUE0nO1xuXHRcdGhvdXJzIC09IDEyO1xuXHR9IGVsc2UgaWYgKGhvdXJzID09PSAwKSB7XG5cdFx0aG91cnMgPSAxMjtcblx0fVxuXG5cdGxldCBtb250aDtcblx0c3dpdGNoIChkYXRlLmdldE1vbnRoKCkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRtb250aCA9ICdKYW4nO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0bW9udGggPSAnRmViJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdG1vbnRoID0gJ01hcic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRtb250aCA9ICdBcHInO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0bW9udGggPSAnTWF5Jztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgNTpcblx0XHRcdG1vbnRoID0gJ0p1bic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDY6XG5cdFx0XHRtb250aCA9ICdKdWwnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA3OlxuXHRcdFx0bW9udGggPSAnQXVnJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgODpcblx0XHRcdG1vbnRoID0gJ1NlcCc7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDk6XG5cdFx0XHRtb250aCA9ICdPY3QnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxMDpcblx0XHRcdG1vbnRoID0gJ05vdic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDExOlxuXHRcdFx0bW9udGggPSAnRGVjJztcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0c3RyICs9IG1vbnRoICsgJyAnO1xuXHRzdHIgKz0gZGF0ZS5nZXREYXRlKCkgKyAnICc7XG5cdHN0ciArPSBkYXRlLmdldEZ1bGxZZWFyKCkgKyAnLCAnO1xuXHRzdHIgKz0gaG91cnMgKyAnOic7XG5cdHN0ciArPSB6ZXJvUGFkKGRhdGUuZ2V0TWludXRlcygpLCAyKTtcblx0c3RyICs9IHBlcmlvZDtcblxuXHRyZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RGF0ZVNob3J0KGRhdGVEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRpZiAoIWRhdGVEYXRhIHx8IGRhdGVEYXRhID09PSAnMDAwMS0wMS0wMVQwMDowMDowMFonKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0bGV0IGRhdGU6IERhdGVcblx0aWYgKGRhdGVEYXRhIGluc3RhbmNlb2YgU3RyaW5nKSB7XG5cdFx0ZGF0ZSA9IG5ldyBEYXRlKGRhdGVEYXRhIGFzIHN0cmluZylcblx0fSBlbHNlIHtcblx0XHRkYXRlID0gbmV3IERhdGUoMClcblx0XHRkYXRlLnNldFVUQ1NlY29uZHMoZGF0ZURhdGEgYXMgbnVtYmVyKVxuXHR9XG5cblx0bGV0IGN1ckRhdGUgPSBuZXcgRGF0ZSgpO1xuXG5cdGxldCBtb250aDtcblx0c3dpdGNoIChkYXRlLmdldE1vbnRoKCkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRtb250aCA9ICdKYW4nO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0bW9udGggPSAnRmViJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdG1vbnRoID0gJ01hcic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRtb250aCA9ICdBcHInO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0bW9udGggPSAnTWF5Jztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgNTpcblx0XHRcdG1vbnRoID0gJ0p1bic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDY6XG5cdFx0XHRtb250aCA9ICdKdWwnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA3OlxuXHRcdFx0bW9udGggPSAnQXVnJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgODpcblx0XHRcdG1vbnRoID0gJ1NlcCc7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDk6XG5cdFx0XHRtb250aCA9ICdPY3QnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxMDpcblx0XHRcdG1vbnRoID0gJ05vdic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDExOlxuXHRcdFx0bW9udGggPSAnRGVjJztcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0bGV0IHN0ciA9IG1vbnRoICsgJyAnICsgZGF0ZS5nZXREYXRlKCk7XG5cblx0aWYgKGRhdGUuZ2V0RnVsbFllYXIoKSAhPT0gY3VyRGF0ZS5nZXRGdWxsWWVhcigpKSB7XG5cdFx0c3RyICs9ICcgJyArIGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0fVxuXG5cdHJldHVybiBzdHI7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXREYXRlU2hvcnRUaW1lKGRhdGVEYXRhOiBhbnkpOiBzdHJpbmcge1xuXHRpZiAoIWRhdGVEYXRhIHx8IGRhdGVEYXRhID09PSAnMDAwMS0wMS0wMVQwMDowMDowMFonKSB7XG5cdFx0cmV0dXJuICcnO1xuXHR9XG5cblx0bGV0IGRhdGU6IERhdGVcblx0aWYgKGRhdGVEYXRhIGluc3RhbmNlb2YgU3RyaW5nKSB7XG5cdFx0ZGF0ZSA9IG5ldyBEYXRlKGRhdGVEYXRhIGFzIHN0cmluZylcblx0fSBlbHNlIHtcblx0XHRkYXRlID0gbmV3IERhdGUoMClcblx0XHRkYXRlLnNldFVUQ1NlY29uZHMoZGF0ZURhdGEgYXMgbnVtYmVyKVxuXHR9XG5cblx0bGV0IGN1ckRhdGUgPSBuZXcgRGF0ZSgpO1xuXG5cdGxldCBtb250aDtcblx0c3dpdGNoIChkYXRlLmdldE1vbnRoKCkpIHtcblx0XHRjYXNlIDA6XG5cdFx0XHRtb250aCA9ICdKYW4nO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxOlxuXHRcdFx0bW9udGggPSAnRmViJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgMjpcblx0XHRcdG1vbnRoID0gJ01hcic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDM6XG5cdFx0XHRtb250aCA9ICdBcHInO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA0OlxuXHRcdFx0bW9udGggPSAnTWF5Jztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgNTpcblx0XHRcdG1vbnRoID0gJ0p1bic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDY6XG5cdFx0XHRtb250aCA9ICdKdWwnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSA3OlxuXHRcdFx0bW9udGggPSAnQXVnJztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgODpcblx0XHRcdG1vbnRoID0gJ1NlcCc7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDk6XG5cdFx0XHRtb250aCA9ICdPY3QnO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAxMDpcblx0XHRcdG1vbnRoID0gJ05vdic7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlIDExOlxuXHRcdFx0bW9udGggPSAnRGVjJztcblx0XHRcdGJyZWFrO1xuXHR9XG5cblx0bGV0IHN0ciA9IG1vbnRoICsgJyAnICsgZGF0ZS5nZXREYXRlKCk7XG5cblx0aWYgKGRhdGUuZ2V0RnVsbFllYXIoKSAhPT0gY3VyRGF0ZS5nZXRGdWxsWWVhcigpKSB7XG5cdFx0c3RyICs9ICcgJyArIGRhdGUuZ2V0RnVsbFllYXIoKTtcblx0fSBlbHNlIGlmIChkYXRlLmdldE1vbnRoKCkgPT09IGN1ckRhdGUuZ2V0TW9udGgoKSAmJlxuXHRcdGRhdGUuZ2V0RGF0ZSgpID09PSBjdXJEYXRlLmdldERhdGUoKSkge1xuXHRcdGxldCBob3VycyA9IGRhdGUuZ2V0SG91cnMoKTtcblx0XHRsZXQgcGVyaW9kID0gJ0FNJztcblxuXHRcdGlmIChob3VycyA+IDEyKSB7XG5cdFx0XHRwZXJpb2QgPSAnUE0nO1xuXHRcdFx0aG91cnMgLT0gMTI7XG5cdFx0fSBlbHNlIGlmIChob3VycyA9PT0gMCkge1xuXHRcdFx0aG91cnMgPSAxMjtcblx0XHR9XG5cblx0XHRzdHIgPSBob3VycyArICc6Jztcblx0XHRzdHIgKz0gemVyb1BhZChkYXRlLmdldE1pbnV0ZXMoKSwgMikgKyAnOic7XG5cdFx0c3RyICs9IHplcm9QYWQoZGF0ZS5nZXRTZWNvbmRzKCksIDIpICsgJyAnO1xuXHRcdHN0ciArPSBwZXJpb2Q7XG5cdH1cblxuXHRyZXR1cm4gc3RyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEV4ZWNPdXRwdXQge1xuXHRzdGRvdXQ6IHN0cmluZ1xuXHRzdGRlcnI6IHN0cmluZ1xuXHRlcnJvcjogRXJyb3JzLkV4ZWNFcnJvclxufVxuXG5leHBvcnQgZnVuY3Rpb24gZXhlYyhwYXRoOiBzdHJpbmcsXG5cdC4uLmFyZ3M6IHN0cmluZ1tdKTogUHJvbWlzZTxFeGVjT3V0cHV0PiB7XG5cblx0cmV0dXJuIG5ldyBQcm9taXNlPEV4ZWNPdXRwdXQ+KChyZXNvbHZlKTogdm9pZCA9PiB7XG5cdFx0Y2hpbGRQcm9jZXNzLmV4ZWNGaWxlKHBhdGgsIGFyZ3MsIChlcnIsIHN0ZG91dCwgc3RkZXJyKSA9PiB7XG5cdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdGVyciA9IG5ldyBFcnJvcnMuRXhlY0Vycm9yKGVyciwgXCJVdGlsczogRXhlYyBlcnJvclwiLFxuXHRcdFx0XHRcdHsgcGF0aDogcGF0aCwgYXJnczogYXJncywgc3Rkb3V0OiBzdGRvdXQsIHN0ZGVycjogc3RkZXJyIH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNvbHZlKHtcblx0XHRcdFx0c3Rkb3V0OiBzdGRvdXQsXG5cdFx0XHRcdHN0ZGVycjogc3RkZXJyLFxuXHRcdFx0XHRlcnJvcjogZXJyLFxuXHRcdFx0fSBhcyBFeGVjT3V0cHV0KVxuXHRcdH0pXG5cdH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlRXhpc3RzKHBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xuXHRyZXR1cm4gbmV3IFByb21pc2U8Ym9vbGVhbj4oKHJlc29sdmUpOiB2b2lkID0+IHtcblx0XHRmcy5zdGF0KHBhdGgsIChlcnI6IEVycm9yLCBzdGF0KSA9PiB7XG5cdFx0XHRpZiAoIWVycikge1xuXHRcdFx0XHRyZXNvbHZlKHRydWUpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXNvbHZlKGZhbHNlKVxuXHRcdFx0fVxuXHRcdH0pXG5cdH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlU2l6ZShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPG51bWJlcj4ge1xuXHRyZXR1cm4gbmV3IFByb21pc2U8bnVtYmVyPigocmVzb2x2ZSk6IHZvaWQgPT4ge1xuXHRcdGZzLnN0YXQocGF0aCwgKGVycjogRXJyb3IsIHN0YXQpID0+IHtcblx0XHRcdGlmIChlcnIgfHwgIXN0YXQpIHtcblx0XHRcdFx0cmVzb2x2ZSgwKVxuXHRcdFx0fVxuXHRcdFx0cmVzb2x2ZShzdGF0LnNpemUgfHwgMClcblx0XHR9KVxuXHR9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsZURlbGV0ZShwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcblx0cmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlLCByZWplY3QpOiB2b2lkID0+IHtcblx0XHRmcy5leGlzdHMocGF0aCwgKGV4aXN0czogYm9vbGVhbik6IHZvaWQgPT4ge1xuXHRcdFx0aWYgKCFleGlzdHMpIHtcblx0XHRcdFx0cmVzb2x2ZSgpXG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0ZnMudW5saW5rKHBhdGgsIChlcnIpID0+IHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdGVyciA9IG5ldyBFcnJvcnMuV3JpdGVFcnJvcihlcnIsIFwiVXRpbHM6IEZhaWxlZCB0byBkZWxldGUgZmlsZVwiLFxuXHRcdFx0XHRcdFx0eyBwYXRoOiBwYXRoIH0pO1xuXHRcdFx0XHRcdHJlamVjdChlcnIpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdH1cblx0XHRcdFx0cmVzb2x2ZSgpXG5cdFx0XHR9KVxuXHRcdH0pXG5cdH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBmaWxlUmVhZChwYXRoOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xuXHRyZXR1cm4gbmV3IFByb21pc2U8c3RyaW5nPigocmVzb2x2ZSwgcmVqZWN0KTogdm9pZCA9PiB7XG5cdFx0ZnMucmVhZEZpbGUoXG5cdFx0XHRwYXRoLCBcInV0Zi04XCIsXG5cdFx0XHQoZXJyOiBOb2RlSlMuRXJybm9FeGNlcHRpb24sIGRhdGE6IHN0cmluZyk6IHZvaWQgPT4ge1xuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0ZXJyID0gbmV3IEVycm9ycy5SZWFkRXJyb3IoZXJyLCBcIlV0aWxzOiBGYWlsZWQgdG8gcmVhZCBmaWxlXCIsXG5cdFx0XHRcdFx0XHR7IHBhdGg6IHBhdGggfSk7XG5cdFx0XHRcdFx0cmVqZWN0KGVycilcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc29sdmUoZGF0YSlcblx0XHRcdH0sXG5cdFx0KVxuXHR9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZmlsZVdyaXRlKHBhdGg6IHN0cmluZywgZGF0YTogc3RyaW5nKTogUHJvbWlzZTx2b2lkPiB7XG5cdHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KTogdm9pZCA9PiB7XG5cdFx0ZnMud3JpdGVGaWxlKFxuXHRcdFx0cGF0aCwgZGF0YSxcblx0XHRcdChlcnI6IE5vZGVKUy5FcnJub0V4Y2VwdGlvbik6IHZvaWQgPT4ge1xuXHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0ZXJyID0gbmV3IEVycm9ycy5Xcml0ZUVycm9yKGVyciwgXCJVdGlsczogRmFpbGVkIHRvIHdyaXRlIGZpbGVcIixcblx0XHRcdFx0XHRcdHsgcGF0aDogcGF0aCB9KTtcblx0XHRcdFx0XHRyZWplY3QoZXJyKVxuXHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHR9XG5cdFx0XHRcdHJlc29sdmUoKVxuXHRcdFx0fSxcblx0XHQpXG5cdH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB1cmlGcm9tUGF0aChwdGg6IHN0cmluZyk6IHN0cmluZyB7XG5cdGNvbnN0IHBhdGhOYW1lID0gcGF0aC5yZXNvbHZlKHB0aCkucmVwbGFjZSgvXFxcXC9nLCBcIi9cIilcblx0cmV0dXJuIGVuY29kZVVSSShcImZpbGU6Ly9cIiArIChwYXRoTmFtZS5jaGFyQXQoMCkgIT09IFwiL1wiID9cblx0XHRcIi9cIiArIHBhdGhOYW1lIDogcGF0aE5hbWUpKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZW5jcnlwdEF2YWlsYWJsZSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0cmV0dXJuIG5ldyBQcm9taXNlPGJvb2xlYW4+KChyZXNvbHZlLCByZWplY3QpOiB2b2lkID0+IHtcblx0XHR0cnkge1xuXHRcdFx0bGV0IGV2dCA9IGVsZWN0cm9uLmlwY1JlbmRlcmVyLmludm9rZShcInByb2Nlc3NpbmdcIiwgXCJlbmNyeXB0YWJsZVwiKVxuXG5cdFx0XHRldnQudGhlbigocmVzcDogW0Vycm9yLCBib29sZWFuXSkgPT4ge1xuXHRcdFx0XHRpZiAoIXJlc3ApIHtcblx0XHRcdFx0XHRsZXQgZXJyID0gbmV3IEVycm9ycy5QYXJzZUVycm9yKFxuXHRcdFx0XHRcdFx0bnVsbCwgXCJVdGlsczogRmFpbGVkIHRvIGNoZWNrIGVuY3J5cHRpb24gc3VwcG9ydCBlMVwiKTtcblx0XHRcdFx0XHRyZWplY3QoZXJyKVxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlc3BbMF0pIHtcblx0XHRcdFx0XHRsZXQgZXJyID0gbmV3IEVycm9ycy5QYXJzZUVycm9yKFxuXHRcdFx0XHRcdFx0cmVzcFswXSwgXCJVdGlsczogRmFpbGVkIHRvIGNoZWNrIGVuY3J5cHRpb24gc3VwcG9ydCBlMlwiKTtcblx0XHRcdFx0XHRyZWplY3QoZXJyKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlc29sdmUocmVzcFsxXSlcblx0XHRcdFx0fVxuXHRcdFx0fSkuY2F0Y2goKGVycikgPT4ge1xuXHRcdFx0XHRlcnIgPSBuZXcgRXJyb3JzLlBhcnNlRXJyb3IoXG5cdFx0XHRcdFx0ZXJyLCBcIlV0aWxzOiBGYWlsZWQgdG8gY2hlY2sgZW5jcnlwdGlvbiBzdXBwb3J0IGUzXCIpO1xuXHRcdFx0XHRyZWplY3QoZXJyKVxuXHRcdFx0fSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdGVyciA9IG5ldyBFcnJvcnMuUGFyc2VFcnJvcihcblx0XHRcdFx0ZXJyLCBcIlV0aWxzOiBGYWlsZWQgdG8gY2hlY2sgZW5jcnlwdGlvbiBzdXBwb3J0IGU0XCIpO1xuXHRcdFx0cmVqZWN0KGVycilcblx0XHR9XG5cdH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlbmNyeXB0U3RyaW5nKGRlY0RhdGE6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG5cdHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpOiB2b2lkID0+IHtcblx0XHR0cnkge1xuXHRcdFx0bGV0IGV2dCA9IGVsZWN0cm9uLmlwY1JlbmRlcmVyLmludm9rZShcInByb2Nlc3NpbmdcIiwgXCJlbmNyeXB0XCIsIGRlY0RhdGEpXG5cblx0XHRcdGV2dC50aGVuKChyZXNwOiBbRXJyb3IsIHN0cmluZ10pID0+IHtcblx0XHRcdFx0aWYgKCFyZXNwKSB7XG5cdFx0XHRcdFx0bGV0IGVyciA9IG5ldyBFcnJvcnMuUGFyc2VFcnJvcihcblx0XHRcdFx0XHRcdG51bGwsIFwiVXRpbHM6IEZhaWxlZCB0byBlbmNyeXB0IHN0cmluZyBlMVwiKTtcblx0XHRcdFx0XHRyZWplY3QoZXJyKVxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlc3BbMF0pIHtcblx0XHRcdFx0XHRsZXQgZXJyID0gbmV3IEVycm9ycy5QYXJzZUVycm9yKFxuXHRcdFx0XHRcdFx0cmVzcFswXSwgXCJVdGlsczogRmFpbGVkIHRvIGVuY3J5cHQgc3RyaW5nIGUyXCIpO1xuXHRcdFx0XHRcdHJlamVjdChlcnIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXNwWzFdKVxuXHRcdFx0XHR9XG5cdFx0XHR9KS5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0XHRcdGVyciA9IG5ldyBFcnJvcnMuUGFyc2VFcnJvcihcblx0XHRcdFx0XHRlcnIsIFwiVXRpbHM6IEZhaWxlZCB0byBlbmNyeXB0IHN0cmluZyBlM1wiKTtcblx0XHRcdFx0cmVqZWN0KGVycilcblx0XHRcdH0pXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRlcnIgPSBuZXcgRXJyb3JzLlBhcnNlRXJyb3IoXG5cdFx0XHRcdGVyciwgXCJVdGlsczogRmFpbGVkIHRvIGVuY3J5cHQgc3RyaW5nIGU0XCIpO1xuXHRcdFx0cmVqZWN0KGVycilcblx0XHR9XG5cdH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWNyeXB0U3RyaW5nKGVuY0RhdGE6IHN0cmluZyk6IFByb21pc2U8c3RyaW5nPiB7XG5cdHJldHVybiBuZXcgUHJvbWlzZTxzdHJpbmc+KChyZXNvbHZlLCByZWplY3QpOiB2b2lkID0+IHtcblx0XHR0cnkge1xuXHRcdFx0bGV0IGV2dCA9IGVsZWN0cm9uLmlwY1JlbmRlcmVyLmludm9rZShcInByb2Nlc3NpbmdcIiwgXCJkZWNyeXB0XCIsIGVuY0RhdGEpXG5cblx0XHRcdGV2dC50aGVuKChyZXNwOiBbRXJyb3IsIHN0cmluZ10pID0+IHtcblx0XHRcdFx0aWYgKCFyZXNwKSB7XG5cdFx0XHRcdFx0bGV0IGVyciA9IG5ldyBFcnJvcnMuUGFyc2VFcnJvcihcblx0XHRcdFx0XHRcdG51bGwsIFwiVXRpbHM6IEZhaWxlZCB0byBkZWNyeXB0IHN0cmluZyBlMVwiKTtcblx0XHRcdFx0XHRyZWplY3QoZXJyKVxuXHRcdFx0XHR9IGVsc2UgaWYgKHJlc3BbMF0pIHtcblx0XHRcdFx0XHRsZXQgZXJyID0gbmV3IEVycm9ycy5QYXJzZUVycm9yKFxuXHRcdFx0XHRcdFx0cmVzcFswXSwgXCJVdGlsczogRmFpbGVkIHRvIGRlY3J5cHQgc3RyaW5nIGUyXCIpO1xuXHRcdFx0XHRcdHJlamVjdChlcnIpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShyZXNwWzFdKVxuXHRcdFx0XHR9XG5cdFx0XHR9KS5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0XHRcdGVyciA9IG5ldyBFcnJvcnMuUGFyc2VFcnJvcihcblx0XHRcdFx0XHRlcnIsIFwiVXRpbHM6IEZhaWxlZCB0byBkZWNyeXB0IHN0cmluZyBlM1wiKTtcblx0XHRcdFx0cmVqZWN0KGVycilcblx0XHRcdH0pXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRlcnIgPSBuZXcgRXJyb3JzLlBhcnNlRXJyb3IoXG5cdFx0XHRcdGVyciwgXCJVdGlsczogRmFpbGVkIHRvIGRlY3J5cHQgc3RyaW5nIGU0XCIpO1xuXHRcdFx0cmVqZWN0KGVycilcblx0XHR9XG5cdH0pXG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgVGFyRGF0YSB7XG5cdHBhdGg6IHN0cmluZ1xuXHRkYXRhOiBzdHJpbmdcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRhclJlYWQocGF0aDogc3RyaW5nKTogUHJvbWlzZTxUYXJEYXRhW10+IHtcblx0cmV0dXJuIG5ldyBQcm9taXNlPFRhckRhdGFbXT4oKHJlc29sdmUsIHJlamVjdCk6IHZvaWQgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRsZXQgZmlsZXM6IFRhckRhdGFbXSA9IFtdXG5cdFx0XHRsZXQgcGFyc2VyID0gbmV3IHRhci5QYXJzZSgpXG5cblx0XHRcdGZzLmNyZWF0ZVJlYWRTdHJlYW0ocGF0aClcblx0XHRcdFx0LnBpcGUocGFyc2VyKVxuXHRcdFx0XHQub24oXCJlbnRyeVwiLCAoZW50cnkpID0+IHtcblx0XHRcdFx0XHRsZXQgZGF0YSA9IFwiXCJcblxuXHRcdFx0XHRcdGVudHJ5Lm9uKFwiZGF0YVwiLCAoY29udGVudCkgPT4ge1xuXHRcdFx0XHRcdFx0ZGF0YSArPSBjb250ZW50LnRvU3RyaW5nKClcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdGVudHJ5Lm9uKFwiZW5kXCIsICgpID0+IHtcblx0XHRcdFx0XHRcdGZpbGVzLnB1c2goe1xuXHRcdFx0XHRcdFx0XHRwYXRoOiBlbnRyeS5wYXRoLFxuXHRcdFx0XHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRcdFx0fSlcblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9KVxuXHRcdFx0XHQub24oXCJlbmRcIiwgKCkgPT4ge1xuXHRcdFx0XHRcdHJlc29sdmUoZmlsZXMpXG5cdFx0XHRcdH0pXG5cdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRlcnIgPSBuZXcgRXJyb3JzLlJlYWRFcnJvcihlcnIsIFwiVXRpbHM6IEZhaWxlZCB0byByZWFkIHRhciBmaWxlXCIsXG5cdFx0XHRcdHsgcGF0aDogcGF0aCB9KTtcblx0XHRcdHJlamVjdChlcnIpXG5cdFx0fVxuXHR9KVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./app/utils/MiscUtils.js\n");

/***/ }),

/***/ "./main/Auth.js":
/*!**********************!*\
  !*** ./main/Auth.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   _load: () => (/* binding */ _load),\n/* harmony export */   load: () => (/* binding */ load),\n/* harmony export */   token: () => (/* binding */ token),\n/* harmony export */   unix: () => (/* binding */ unix),\n/* harmony export */   unixPath: () => (/* binding */ unixPath),\n/* harmony export */   webHost: () => (/* binding */ webHost)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! process */ \"process\");\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Service */ \"./main/Service.js\");\n\n\n\n\nlet token = '';\nlet unix = false;\nconst unixPath = \"/var/run/pritunl.sock\";\nconst webHost = \"http://127.0.0.1:9770\";\nif ((process__WEBPACK_IMPORTED_MODULE_1___default().platform) === \"linux\" || (process__WEBPACK_IMPORTED_MODULE_1___default().platform) === \"darwin\") {\n    unix = true;\n}\nfunction getAuthPath() {\n    if ((process__WEBPACK_IMPORTED_MODULE_1___default().platform) === \"win32\") {\n        return path__WEBPACK_IMPORTED_MODULE_2___default().join(_Service__WEBPACK_IMPORTED_MODULE_3__.winDrive, \"ProgramData\", \"Pritunl\", \"auth\");\n    }\n    else {\n        return path__WEBPACK_IMPORTED_MODULE_2___default().join((path__WEBPACK_IMPORTED_MODULE_2___default().sep), \"var\", \"run\", \"pritunl.auth\");\n    }\n}\nfunction _load() {\n    fs__WEBPACK_IMPORTED_MODULE_0___default().readFile(getAuthPath(), 'utf-8', (err, data) => {\n        if (err || !data) {\n            setTimeout(() => {\n                _load();\n            }, 100);\n            return;\n        }\n        token = data.trim();\n        setTimeout(() => {\n            _load();\n        }, 3000);\n    });\n}\nfunction load() {\n    return new Promise((resolve, reject) => {\n        fs__WEBPACK_IMPORTED_MODULE_0___default().readFile(getAuthPath(), 'utf-8', (err, data) => {\n            if (err || !data) {\n                setTimeout(() => {\n                    _load();\n                }, 100);\n                resolve();\n                return;\n            }\n            token = data.trim();\n            resolve();\n            setTimeout(() => {\n                _load();\n            }, 3000);\n        });\n    });\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWluL0F1dGguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7OztBQUFvQjtBQUNVO0FBQ047QUFDVztBQUU1QixJQUFJLEtBQUssR0FBRyxFQUFFLENBQUM7QUFDZixJQUFJLElBQUksR0FBRyxLQUFLO0FBQ2hCLE1BQU0sUUFBUSxHQUFHLHVCQUF1QjtBQUN4QyxNQUFNLE9BQU8sR0FBRyx1QkFBdUI7QUFFOUMsSUFBSSx5REFBZ0IsS0FBSyxPQUFPLElBQUkseURBQWdCLEtBQUssUUFBUSxFQUFFLENBQUM7SUFDbkUsSUFBSSxHQUFHLElBQUk7QUFDWixDQUFDO0FBRUQsU0FBUyxXQUFXO0lBQ25CLElBQUkseURBQWdCLEtBQUssT0FBTyxFQUFFLENBQUM7UUFDbEMsT0FBTyxnREFBUyxDQUFDLDhDQUFRLEVBQUUsYUFBYSxFQUFFLFNBQVMsRUFBRSxNQUFNLENBQUM7SUFDN0QsQ0FBQztTQUFNLENBQUM7UUFDUCxPQUFPLGdEQUFTLENBQUMsaURBQVEsRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLGNBQWMsQ0FBQztJQUN6RCxDQUFDO0FBQ0YsQ0FBQztBQUVNLFNBQVMsS0FBSztJQUNwQixrREFBVyxDQUFDLFdBQVcsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFZLEVBQVEsRUFBRTtRQUMvRCxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ2xCLFVBQVUsQ0FBQyxHQUFTLEVBQUU7Z0JBQ3JCLEtBQUssRUFBRSxDQUFDO1lBQ1QsQ0FBQyxFQUFFLEdBQUcsQ0FBQyxDQUFDO1lBQ1IsT0FBTztRQUNSLENBQUM7UUFFRCxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1FBRXBCLFVBQVUsQ0FBQyxHQUFTLEVBQUU7WUFDckIsS0FBSyxFQUFFLENBQUM7UUFDVCxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDVixDQUFDLENBQUMsQ0FBQztBQUNKLENBQUM7QUFFTSxTQUFTLElBQUk7SUFDbkIsT0FBTyxJQUFJLE9BQU8sQ0FBTyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQVEsRUFBRTtRQUNsRCxrREFBVyxDQUFDLFdBQVcsRUFBRSxFQUFFLE9BQU8sRUFBRSxDQUFDLEdBQUcsRUFBRSxJQUFZLEVBQVEsRUFBRTtZQUMvRCxJQUFJLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO2dCQUNsQixVQUFVLENBQUMsR0FBUyxFQUFFO29CQUNyQixLQUFLLEVBQUUsQ0FBQztnQkFDVCxDQUFDLEVBQUUsR0FBRyxDQUFDLENBQUM7Z0JBQ1IsT0FBTyxFQUFFLENBQUM7Z0JBQ1YsT0FBTztZQUNSLENBQUM7WUFFRCxLQUFLLEdBQUcsSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO1lBQ3BCLE9BQU8sRUFBRSxDQUFDO1lBRVYsVUFBVSxDQUFDLEdBQVMsRUFBRTtnQkFDckIsS0FBSyxFQUFFLENBQUM7WUFDVCxDQUFDLEVBQUUsSUFBSSxDQUFDLENBQUM7UUFDVixDQUFDLENBQUM7SUFDSCxDQUFDLENBQUM7QUFDSCxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL21haW4vQXV0aC50cz81YmZlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCBwcm9jZXNzIGZyb20gXCJwcm9jZXNzXCI7XG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHt3aW5Ecml2ZX0gZnJvbSBcIi4vU2VydmljZVwiO1xuXG5leHBvcnQgbGV0IHRva2VuID0gJyc7XG5leHBvcnQgbGV0IHVuaXggPSBmYWxzZVxuZXhwb3J0IGNvbnN0IHVuaXhQYXRoID0gXCIvdmFyL3J1bi9wcml0dW5sLnNvY2tcIlxuZXhwb3J0IGNvbnN0IHdlYkhvc3QgPSBcImh0dHA6Ly8xMjcuMC4wLjE6OTc3MFwiXG5cbmlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcImxpbnV4XCIgfHwgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIikge1xuXHR1bml4ID0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZXRBdXRoUGF0aCgpOiBzdHJpbmcge1xuXHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG5cdFx0cmV0dXJuIHBhdGguam9pbih3aW5Ecml2ZSwgXCJQcm9ncmFtRGF0YVwiLCBcIlByaXR1bmxcIiwgXCJhdXRoXCIpXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuIHBhdGguam9pbihwYXRoLnNlcCwgXCJ2YXJcIiwgXCJydW5cIiwgXCJwcml0dW5sLmF1dGhcIilcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gX2xvYWQoKTogdm9pZCB7XG5cdGZzLnJlYWRGaWxlKGdldEF1dGhQYXRoKCksICd1dGYtOCcsIChlcnIsIGRhdGE6IHN0cmluZyk6IHZvaWQgPT4ge1xuXHRcdGlmIChlcnIgfHwgIWRhdGEpIHtcblx0XHRcdHNldFRpbWVvdXQoKCk6IHZvaWQgPT4ge1xuXHRcdFx0XHRfbG9hZCgpO1xuXHRcdFx0fSwgMTAwKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0b2tlbiA9IGRhdGEudHJpbSgpO1xuXG5cdFx0c2V0VGltZW91dCgoKTogdm9pZCA9PiB7XG5cdFx0XHRfbG9hZCgpO1xuXHRcdH0sIDMwMDApO1xuXHR9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGxvYWQoKTogUHJvbWlzZTx2b2lkPiB7XG5cdHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KTogdm9pZCA9PiB7XG5cdFx0ZnMucmVhZEZpbGUoZ2V0QXV0aFBhdGgoKSwgJ3V0Zi04JywgKGVyciwgZGF0YTogc3RyaW5nKTogdm9pZCA9PiB7XG5cdFx0XHRpZiAoZXJyIHx8ICFkYXRhKSB7XG5cdFx0XHRcdHNldFRpbWVvdXQoKCk6IHZvaWQgPT4ge1xuXHRcdFx0XHRcdF9sb2FkKCk7XG5cdFx0XHRcdH0sIDEwMCk7XG5cdFx0XHRcdHJlc29sdmUoKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR0b2tlbiA9IGRhdGEudHJpbSgpO1xuXHRcdFx0cmVzb2x2ZSgpO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCgpOiB2b2lkID0+IHtcblx0XHRcdFx0X2xvYWQoKTtcblx0XHRcdH0sIDMwMDApO1xuXHRcdH0pXG5cdH0pXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./main/Auth.js\n");

/***/ }),

/***/ "./main/Config.js":
/*!************************!*\
  !*** ./main/Config.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors */ \"./main/Errors.js\");\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Logger */ \"./main/Logger.js\");\n\n\n\n\n\nclass ConfigData {\n    constructor() {\n        this.window_width = 0;\n        this.window_height = 0;\n        this.disable_tray_icon = false;\n        this.classic_interface = false;\n        this.frameless = null;\n        this.theme = \"dark\";\n    }\n    _load(data) {\n        if (data[\"disable_tray_icon\"] !== undefined) {\n            this.disable_tray_icon = data[\"disable_tray_icon\"];\n        }\n        if (data[\"classic_interface\"] !== undefined) {\n            this.classic_interface = data[\"classic_interface\"];\n        }\n        if (data[\"theme\"] !== undefined) {\n            this.theme = data[\"theme\"];\n        }\n        if (data[\"window_width\"] !== undefined) {\n            this.window_width = data[\"window_width\"];\n        }\n        if (data[\"window_height\"] !== undefined) {\n            this.window_height = data[\"window_height\"];\n        }\n        if (data[\"frameless\"] !== undefined) {\n            this.frameless = data[\"frameless\"];\n        }\n    }\n    path() {\n        return path__WEBPACK_IMPORTED_MODULE_1___default().join(electron__WEBPACK_IMPORTED_MODULE_2___default().app.getPath(\"userData\"), \"pritunl.json\");\n    }\n    load() {\n        return new Promise((resolve) => {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().readFile(this.path(), \"utf-8\", (err, data) => {\n                if (err) {\n                    if (err.code !== \"ENOENT\") {\n                        err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.ReadError(err, \"Config: Read error\");\n                        _Logger__WEBPACK_IMPORTED_MODULE_4__.error(err);\n                    }\n                    resolve();\n                    return;\n                }\n                let configData = {};\n                if (data) {\n                    try {\n                        configData = JSON.parse(data);\n                    }\n                    catch (err) {\n                        err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.ReadError(err, \"Config: Parse error\");\n                        _Logger__WEBPACK_IMPORTED_MODULE_4__.error(err);\n                        configData = {};\n                    }\n                }\n                this._load(configData);\n                resolve();\n            });\n        });\n    }\n    save(opts) {\n        let data = {\n            disable_tray_icon: opts[\"disable_tray_icon\"],\n            classic_interface: opts[\"classic_interface\"],\n            window_width: opts[\"window_width\"],\n            window_height: opts[\"window_height\"],\n            frameless: opts[\"frameless\"],\n            theme: opts[\"theme\"],\n        };\n        return new Promise((resolve, reject) => {\n            this.load().then(() => {\n                if (data.disable_tray_icon === undefined) {\n                    data.disable_tray_icon = this.disable_tray_icon;\n                }\n                if (data.classic_interface === undefined) {\n                    data.classic_interface = this.classic_interface;\n                }\n                if (data.window_width === undefined) {\n                    data.window_width = this.window_width;\n                }\n                if (data.theme === undefined) {\n                    data.theme = this.theme;\n                }\n                if (data.frameless === undefined) {\n                    data.frameless = this.frameless;\n                }\n                this._load(data);\n                fs__WEBPACK_IMPORTED_MODULE_0___default().writeFile(this.path(), JSON.stringify(data), (err) => {\n                    if (err) {\n                        err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.ReadError(err, \"Config: Write error\");\n                        _Logger__WEBPACK_IMPORTED_MODULE_4__.error(err);\n                    }\n                    resolve();\n                });\n            });\n        });\n    }\n}\nconst Config = new ConfigData();\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Config);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWluL0NvbmZpZy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7QUFBbUI7QUFDSTtBQUNRO0FBQ0c7QUFDQTtBQUVsQyxNQUFNLFVBQVU7SUFBaEI7UUFDQyxpQkFBWSxHQUFHLENBQUM7UUFDaEIsa0JBQWEsR0FBRyxDQUFDO1FBQ2pCLHNCQUFpQixHQUFHLEtBQUs7UUFDekIsc0JBQWlCLEdBQUcsS0FBSztRQUN6QixjQUFTLEdBQVksSUFBSTtRQUN6QixVQUFLLEdBQUcsTUFBTTtJQXlHZixDQUFDO0lBdkdBLEtBQUssQ0FBQyxJQUEwQjtRQUMvQixJQUFJLElBQUksQ0FBQyxtQkFBbUIsQ0FBQyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQzdDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUM7UUFDbkQsQ0FBQztRQUNELElBQUksSUFBSSxDQUFDLG1CQUFtQixDQUFDLEtBQUssU0FBUyxFQUFFLENBQUM7WUFDN0MsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztRQUNuRCxDQUFDO1FBQ0QsSUFBSSxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssU0FBUyxFQUFFLENBQUM7WUFDakMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDO1FBQzNCLENBQUM7UUFDRCxJQUFJLElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxTQUFTLEVBQUUsQ0FBQztZQUN4QyxJQUFJLENBQUMsWUFBWSxHQUFHLElBQUksQ0FBQyxjQUFjLENBQUM7UUFDekMsQ0FBQztRQUNELElBQUksSUFBSSxDQUFDLGVBQWUsQ0FBQyxLQUFLLFNBQVMsRUFBRSxDQUFDO1lBQ3pDLElBQUksQ0FBQyxhQUFhLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztRQUMzQyxDQUFDO1FBQ0QsSUFBSSxJQUFJLENBQUMsV0FBVyxDQUFDLEtBQUssU0FBUyxFQUFFLENBQUM7WUFDckMsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDO1FBQ25DLENBQUM7SUFDRixDQUFDO0lBRUQsSUFBSTtRQUNILE9BQU8sZ0RBQVMsQ0FBQyxtREFBWSxDQUFDLE9BQU8sQ0FBQyxVQUFVLENBQUMsRUFBRSxjQUFjLENBQUM7SUFDbkUsQ0FBQztJQUVELElBQUk7UUFDSCxPQUFPLElBQUksT0FBTyxDQUFPLENBQUMsT0FBTyxFQUFRLEVBQUU7WUFDMUMsa0RBQVcsQ0FDVixJQUFJLENBQUMsSUFBSSxFQUFFLEVBQUUsT0FBTyxFQUNwQixDQUFDLEdBQTBCLEVBQUUsSUFBWSxFQUFRLEVBQUU7Z0JBQ2xELElBQUksR0FBRyxFQUFFLENBQUM7b0JBQ1QsSUFBSSxHQUFHLENBQUMsSUFBSSxLQUFLLFFBQVEsRUFBRSxDQUFDO3dCQUMzQixHQUFHLEdBQUcsSUFBSSw4Q0FBZ0IsQ0FBQyxHQUFHLEVBQUUsb0JBQW9CLENBQUM7d0JBQ3JELDBDQUFZLENBQUMsR0FBRyxDQUFDO29CQUNsQixDQUFDO29CQUVELE9BQU8sRUFBRTtvQkFDVCxPQUFNO2dCQUNQLENBQUM7Z0JBRUQsSUFBSSxVQUFVLEdBQVEsRUFBRTtnQkFDeEIsSUFBSSxJQUFJLEVBQUUsQ0FBQztvQkFDVixJQUFJLENBQUM7d0JBQ0osVUFBVSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO29CQUM5QixDQUFDO29CQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7d0JBQ2QsR0FBRyxHQUFHLElBQUksOENBQWdCLENBQUMsR0FBRyxFQUFFLHFCQUFxQixDQUFDO3dCQUN0RCwwQ0FBWSxDQUFDLEdBQUcsQ0FBQzt3QkFFakIsVUFBVSxHQUFHLEVBQUU7b0JBQ2hCLENBQUM7Z0JBQ0YsQ0FBQztnQkFFRCxJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQztnQkFFdEIsT0FBTyxFQUFFO1lBQ1YsQ0FBQyxDQUNEO1FBQ0YsQ0FBQyxDQUFDO0lBQ0gsQ0FBQztJQUVELElBQUksQ0FBQyxJQUEwQjtRQUM5QixJQUFJLElBQUksR0FBRztZQUNWLGlCQUFpQixFQUFFLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztZQUM1QyxpQkFBaUIsRUFBRSxJQUFJLENBQUMsbUJBQW1CLENBQUM7WUFDNUMsWUFBWSxFQUFFLElBQUksQ0FBQyxjQUFjLENBQUM7WUFDbEMsYUFBYSxFQUFFLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDcEMsU0FBUyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUM7WUFDNUIsS0FBSyxFQUFFLElBQUksQ0FBQyxPQUFPLENBQUM7U0FDcEI7UUFFRCxPQUFPLElBQUksT0FBTyxDQUFPLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBUSxFQUFFO1lBQ2xELElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLENBQUMsR0FBUyxFQUFFO2dCQUMzQixJQUFJLElBQUksQ0FBQyxpQkFBaUIsS0FBSyxTQUFTLEVBQUUsQ0FBQztvQkFDMUMsSUFBSSxDQUFDLGlCQUFpQixHQUFHLElBQUksQ0FBQyxpQkFBaUI7Z0JBQ2hELENBQUM7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsaUJBQWlCLEtBQUssU0FBUyxFQUFFLENBQUM7b0JBQzFDLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUMsaUJBQWlCO2dCQUNoRCxDQUFDO2dCQUNELElBQUksSUFBSSxDQUFDLFlBQVksS0FBSyxTQUFTLEVBQUUsQ0FBQztvQkFDckMsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsWUFBWTtnQkFDdEMsQ0FBQztnQkFDRCxJQUFJLElBQUksQ0FBQyxLQUFLLEtBQUssU0FBUyxFQUFFLENBQUM7b0JBQzlCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUs7Z0JBQ3hCLENBQUM7Z0JBQ0QsSUFBSSxJQUFJLENBQUMsU0FBUyxLQUFLLFNBQVMsRUFBRSxDQUFDO29CQUNsQyxJQUFJLENBQUMsU0FBUyxHQUFHLElBQUksQ0FBQyxTQUFTO2dCQUNoQyxDQUFDO2dCQUVELElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDO2dCQUVoQixtREFBWSxDQUNYLElBQUksQ0FBQyxJQUFJLEVBQUUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxFQUNqQyxDQUFDLEdBQTBCLEVBQVEsRUFBRTtvQkFDcEMsSUFBSSxHQUFHLEVBQUUsQ0FBQzt3QkFDVCxHQUFHLEdBQUcsSUFBSSw4Q0FBZ0IsQ0FBQyxHQUFHLEVBQUUscUJBQXFCLENBQUM7d0JBQ3RELDBDQUFZLENBQUMsR0FBRyxDQUFDO29CQUNsQixDQUFDO29CQUNELE9BQU8sRUFBRTtnQkFDVixDQUFDLENBQ0Q7WUFDRixDQUFDLENBQUM7UUFDSCxDQUFDLENBQUM7SUFDSCxDQUFDO0NBQ0Q7QUFFRCxNQUFNLE1BQU0sR0FBRyxJQUFJLFVBQVUsRUFBRTtBQUMvQixpRUFBZSxNQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL21haW4vQ29uZmlnLnRzPzM3ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGZzIGZyb20gXCJmc1wiXG5pbXBvcnQgcGF0aCBmcm9tIFwicGF0aFwiXG5pbXBvcnQgZWxlY3Ryb24gZnJvbSBcImVsZWN0cm9uXCJcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tIFwiLi9FcnJvcnNcIlxuaW1wb3J0ICogYXMgTG9nZ2VyIGZyb20gXCIuL0xvZ2dlclwiXG5cbmNsYXNzIENvbmZpZ0RhdGEge1xuXHR3aW5kb3dfd2lkdGggPSAwXG5cdHdpbmRvd19oZWlnaHQgPSAwXG5cdGRpc2FibGVfdHJheV9pY29uID0gZmFsc2Vcblx0Y2xhc3NpY19pbnRlcmZhY2UgPSBmYWxzZVxuXHRmcmFtZWxlc3M6IGJvb2xlYW4gPSBudWxsXG5cdHRoZW1lID0gXCJkYXJrXCJcblxuXHRfbG9hZChkYXRhOiB7W2tleTogc3RyaW5nXTogYW55fSk6IHZvaWQge1xuXHRcdGlmIChkYXRhW1wiZGlzYWJsZV90cmF5X2ljb25cIl0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5kaXNhYmxlX3RyYXlfaWNvbiA9IGRhdGFbXCJkaXNhYmxlX3RyYXlfaWNvblwiXVxuXHRcdH1cblx0XHRpZiAoZGF0YVtcImNsYXNzaWNfaW50ZXJmYWNlXCJdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMuY2xhc3NpY19pbnRlcmZhY2UgPSBkYXRhW1wiY2xhc3NpY19pbnRlcmZhY2VcIl1cblx0XHR9XG5cdFx0aWYgKGRhdGFbXCJ0aGVtZVwiXSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLnRoZW1lID0gZGF0YVtcInRoZW1lXCJdXG5cdFx0fVxuXHRcdGlmIChkYXRhW1wid2luZG93X3dpZHRoXCJdICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHRoaXMud2luZG93X3dpZHRoID0gZGF0YVtcIndpbmRvd193aWR0aFwiXVxuXHRcdH1cblx0XHRpZiAoZGF0YVtcIndpbmRvd19oZWlnaHRcIl0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy53aW5kb3dfaGVpZ2h0ID0gZGF0YVtcIndpbmRvd19oZWlnaHRcIl1cblx0XHR9XG5cdFx0aWYgKGRhdGFbXCJmcmFtZWxlc3NcIl0gIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5mcmFtZWxlc3MgPSBkYXRhW1wiZnJhbWVsZXNzXCJdXG5cdFx0fVxuXHR9XG5cblx0cGF0aCgpOiBzdHJpbmcge1xuXHRcdHJldHVybiBwYXRoLmpvaW4oZWxlY3Ryb24uYXBwLmdldFBhdGgoXCJ1c2VyRGF0YVwiKSwgXCJwcml0dW5sLmpzb25cIilcblx0fVxuXG5cdGxvYWQoKTogUHJvbWlzZTx2b2lkPiB7XG5cdFx0cmV0dXJuIG5ldyBQcm9taXNlPHZvaWQ+KChyZXNvbHZlKTogdm9pZCA9PiB7XG5cdFx0XHRmcy5yZWFkRmlsZShcblx0XHRcdFx0dGhpcy5wYXRoKCksIFwidXRmLThcIixcblx0XHRcdFx0KGVycjogTm9kZUpTLkVycm5vRXhjZXB0aW9uLCBkYXRhOiBzdHJpbmcpOiB2b2lkID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRpZiAoZXJyLmNvZGUgIT09IFwiRU5PRU5UXCIpIHtcblx0XHRcdFx0XHRcdFx0ZXJyID0gbmV3IEVycm9ycy5SZWFkRXJyb3IoZXJyLCBcIkNvbmZpZzogUmVhZCBlcnJvclwiKVxuXHRcdFx0XHRcdFx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRyZXNvbHZlKClcblx0XHRcdFx0XHRcdHJldHVyblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGxldCBjb25maWdEYXRhOiBhbnkgPSB7fVxuXHRcdFx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRjb25maWdEYXRhID0gSlNPTi5wYXJzZShkYXRhKVxuXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0XHRcdFx0XHRcdGVyciA9IG5ldyBFcnJvcnMuUmVhZEVycm9yKGVyciwgXCJDb25maWc6IFBhcnNlIGVycm9yXCIpXG5cdFx0XHRcdFx0XHRcdExvZ2dlci5lcnJvcihlcnIpXG5cblx0XHRcdFx0XHRcdFx0Y29uZmlnRGF0YSA9IHt9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0dGhpcy5fbG9hZChjb25maWdEYXRhKVxuXG5cdFx0XHRcdFx0cmVzb2x2ZSgpXG5cdFx0XHRcdH0sXG5cdFx0XHQpXG5cdFx0fSlcblx0fVxuXG5cdHNhdmUob3B0czoge1trZXk6IHN0cmluZ106IGFueX0pOiBQcm9taXNlPHZvaWQ+IHtcblx0XHRsZXQgZGF0YSA9IHtcblx0XHRcdGRpc2FibGVfdHJheV9pY29uOiBvcHRzW1wiZGlzYWJsZV90cmF5X2ljb25cIl0sXG5cdFx0XHRjbGFzc2ljX2ludGVyZmFjZTogb3B0c1tcImNsYXNzaWNfaW50ZXJmYWNlXCJdLFxuXHRcdFx0d2luZG93X3dpZHRoOiBvcHRzW1wid2luZG93X3dpZHRoXCJdLFxuXHRcdFx0d2luZG93X2hlaWdodDogb3B0c1tcIndpbmRvd19oZWlnaHRcIl0sXG5cdFx0XHRmcmFtZWxlc3M6IG9wdHNbXCJmcmFtZWxlc3NcIl0sXG5cdFx0XHR0aGVtZTogb3B0c1tcInRoZW1lXCJdLFxuXHRcdH1cblxuXHRcdHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPigocmVzb2x2ZSwgcmVqZWN0KTogdm9pZCA9PiB7XG5cdFx0XHR0aGlzLmxvYWQoKS50aGVuKCgpOiB2b2lkID0+IHtcblx0XHRcdFx0aWYgKGRhdGEuZGlzYWJsZV90cmF5X2ljb24gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGRhdGEuZGlzYWJsZV90cmF5X2ljb24gPSB0aGlzLmRpc2FibGVfdHJheV9pY29uXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRhdGEuY2xhc3NpY19pbnRlcmZhY2UgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGRhdGEuY2xhc3NpY19pbnRlcmZhY2UgPSB0aGlzLmNsYXNzaWNfaW50ZXJmYWNlXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRhdGEud2luZG93X3dpZHRoID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRkYXRhLndpbmRvd193aWR0aCA9IHRoaXMud2luZG93X3dpZHRoXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRhdGEudGhlbWUgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0XHRcdGRhdGEudGhlbWUgPSB0aGlzLnRoZW1lXG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGRhdGEuZnJhbWVsZXNzID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRkYXRhLmZyYW1lbGVzcyA9IHRoaXMuZnJhbWVsZXNzXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9sb2FkKGRhdGEpXG5cblx0XHRcdFx0ZnMud3JpdGVGaWxlKFxuXHRcdFx0XHRcdHRoaXMucGF0aCgpLCBKU09OLnN0cmluZ2lmeShkYXRhKSxcblx0XHRcdFx0XHQoZXJyOiBOb2RlSlMuRXJybm9FeGNlcHRpb24pOiB2b2lkID0+IHtcblx0XHRcdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRcdFx0ZXJyID0gbmV3IEVycm9ycy5SZWFkRXJyb3IoZXJyLCBcIkNvbmZpZzogV3JpdGUgZXJyb3JcIilcblx0XHRcdFx0XHRcdFx0TG9nZ2VyLmVycm9yKGVycilcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlc29sdmUoKVxuXHRcdFx0XHRcdH0sXG5cdFx0XHRcdClcblx0XHRcdH0pXG5cdFx0fSlcblx0fVxufVxuXG5jb25zdCBDb25maWcgPSBuZXcgQ29uZmlnRGF0YSgpXG5leHBvcnQgZGVmYXVsdCBDb25maWdcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./main/Config.js\n");

/***/ }),

/***/ "./main/Constants.js":
/*!***************************!*\
  !*** ./main/Constants.js ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   devTools: () => (/* binding */ devTools),\n/* harmony export */   hostname: () => (/* binding */ hostname),\n/* harmony export */   logPath: () => (/* binding */ logPath),\n/* harmony export */   mainWindow: () => (/* binding */ mainWindow),\n/* harmony export */   platform: () => (/* binding */ platform),\n/* harmony export */   production: () => (/* binding */ production),\n/* harmony export */   setMainWindow: () => (/* binding */ setMainWindow),\n/* harmony export */   unix: () => (/* binding */ unix),\n/* harmony export */   unixPath: () => (/* binding */ unixPath),\n/* harmony export */   unixWsHost: () => (/* binding */ unixWsHost),\n/* harmony export */   webHost: () => (/* binding */ webHost),\n/* harmony export */   webWsHost: () => (/* binding */ webWsHost),\n/* harmony export */   winDrive: () => (/* binding */ winDrive)\n/* harmony export */ });\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! os */ \"os\");\n/* harmony import */ var os__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(os__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! process */ \"process\");\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_3__);\n\n\n\n\nlet unix = false;\nconst unixPath = \"/var/run/pritunl.sock\";\nconst webHost = \"http://127.0.0.1:9770\";\nconst unixWsHost = \"ws+unix://\" + path__WEBPACK_IMPORTED_MODULE_1___default().join((path__WEBPACK_IMPORTED_MODULE_1___default().sep), \"var\", \"run\", \"pritunl.sock\") + \":\";\nconst webWsHost = \"ws://127.0.0.1:9770\";\nconst platform = os__WEBPACK_IMPORTED_MODULE_2___default().platform();\nconst hostname = os__WEBPACK_IMPORTED_MODULE_2___default().hostname();\nconst logPath = path__WEBPACK_IMPORTED_MODULE_1___default().join(electron__WEBPACK_IMPORTED_MODULE_0___default().app.getPath(\"userData\"), \"pritunl.log\");\nlet mainWindow;\nlet production = (process__WEBPACK_IMPORTED_MODULE_3___default().argv.indexOf(\"--dev\") === -1);\nlet devTools = (process__WEBPACK_IMPORTED_MODULE_3___default().argv.indexOf(\"--dev-tools\") !== -1);\nlet winDrive = \"C:\\\\\";\nlet systemDrv = (process__WEBPACK_IMPORTED_MODULE_3___default().env).SYSTEMDRIVE;\nif (systemDrv) {\n    winDrive = systemDrv + \"\\\\\";\n}\nif ((process__WEBPACK_IMPORTED_MODULE_3___default().platform) === \"linux\" || (process__WEBPACK_IMPORTED_MODULE_3___default().platform) === \"darwin\") {\n    unix = true;\n}\nfunction setMainWindow(mainWin) {\n    mainWindow = mainWin;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWluL0NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBK0I7QUFDUjtBQUNKO0FBQ1U7QUFFdEIsSUFBSSxJQUFJLEdBQUcsS0FBSztBQUNoQixNQUFNLFFBQVEsR0FBRyx1QkFBdUI7QUFDeEMsTUFBTSxPQUFPLEdBQUcsdUJBQXVCO0FBQ3ZDLE1BQU0sVUFBVSxHQUFHLFlBQVksR0FBRyxnREFBUyxDQUNqRCxpREFBUSxFQUFFLEtBQUssRUFBRSxLQUFLLEVBQUUsY0FBYyxDQUFDLEdBQUcsR0FBRztBQUN2QyxNQUFNLFNBQVMsR0FBRyxxQkFBcUI7QUFDdkMsTUFBTSxRQUFRLEdBQUcsa0RBQVcsRUFBRTtBQUM5QixNQUFNLFFBQVEsR0FBRyxrREFBVyxFQUFFO0FBQzlCLE1BQU0sT0FBTyxHQUFHLGdEQUFTLENBQUMsbURBQVksQ0FBQyxPQUFPLENBQUMsVUFBVSxDQUFDLEVBQ2hFLGFBQWEsQ0FBQyxDQUFDO0FBQ1QsSUFBSSxVQUFrQztBQUV0QyxJQUFJLFVBQVUsR0FBRyxDQUFDLG1EQUFZLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQ3ZELElBQUksUUFBUSxHQUFHLENBQUMsbURBQVksQ0FBQyxPQUFPLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7QUFFM0QsSUFBSSxRQUFRLEdBQUcsTUFBTTtBQUM1QixJQUFJLFNBQVMsR0FBRyxvREFBVyxDQUFDLFdBQVc7QUFDdkMsSUFBSSxTQUFTLEVBQUUsQ0FBQztJQUNmLFFBQVEsR0FBRyxTQUFTLEdBQUcsSUFBSTtBQUM1QixDQUFDO0FBRUQsSUFBSSx5REFBZ0IsS0FBSyxPQUFPLElBQUkseURBQWdCLEtBQUssUUFBUSxFQUFFLENBQUM7SUFDbkUsSUFBSSxHQUFHLElBQUk7QUFDWixDQUFDO0FBRU0sU0FBUyxhQUFhLENBQUMsT0FBK0I7SUFDNUQsVUFBVSxHQUFHLE9BQU87QUFDckIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9tYWluL0NvbnN0YW50cy50cz9jOGVjIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBlbGVjdHJvbiBmcm9tIFwiZWxlY3Ryb25cIlxuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIlxuaW1wb3J0IG9zIGZyb20gXCJvc1wiXG5pbXBvcnQgcHJvY2VzcyBmcm9tIFwicHJvY2Vzc1wiXG5cbmV4cG9ydCBsZXQgdW5peCA9IGZhbHNlXG5leHBvcnQgY29uc3QgdW5peFBhdGggPSBcIi92YXIvcnVuL3ByaXR1bmwuc29ja1wiXG5leHBvcnQgY29uc3Qgd2ViSG9zdCA9IFwiaHR0cDovLzEyNy4wLjAuMTo5NzcwXCJcbmV4cG9ydCBjb25zdCB1bml4V3NIb3N0ID0gXCJ3cyt1bml4Oi8vXCIgKyBwYXRoLmpvaW4oXG5cdHBhdGguc2VwLCBcInZhclwiLCBcInJ1blwiLCBcInByaXR1bmwuc29ja1wiKSArIFwiOlwiXG5leHBvcnQgY29uc3Qgd2ViV3NIb3N0ID0gXCJ3czovLzEyNy4wLjAuMTo5NzcwXCJcbmV4cG9ydCBjb25zdCBwbGF0Zm9ybSA9IG9zLnBsYXRmb3JtKClcbmV4cG9ydCBjb25zdCBob3N0bmFtZSA9IG9zLmhvc3RuYW1lKClcbmV4cG9ydCBjb25zdCBsb2dQYXRoID0gcGF0aC5qb2luKGVsZWN0cm9uLmFwcC5nZXRQYXRoKFwidXNlckRhdGFcIiksXG5cdFwicHJpdHVubC5sb2dcIik7XG5leHBvcnQgbGV0IG1haW5XaW5kb3c6IGVsZWN0cm9uLkJyb3dzZXJXaW5kb3dcblxuZXhwb3J0IGxldCBwcm9kdWN0aW9uID0gKHByb2Nlc3MuYXJndi5pbmRleE9mKFwiLS1kZXZcIikgPT09IC0xKVxuZXhwb3J0IGxldCBkZXZUb29scyA9IChwcm9jZXNzLmFyZ3YuaW5kZXhPZihcIi0tZGV2LXRvb2xzXCIpICE9PSAtMSlcblxuZXhwb3J0IGxldCB3aW5Ecml2ZSA9IFwiQzpcXFxcXCJcbmxldCBzeXN0ZW1EcnYgPSBwcm9jZXNzLmVudi5TWVNURU1EUklWRVxuaWYgKHN5c3RlbURydikge1xuXHR3aW5Ecml2ZSA9IHN5c3RlbURydiArIFwiXFxcXFwiXG59XG5cbmlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcImxpbnV4XCIgfHwgcHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJkYXJ3aW5cIikge1xuXHR1bml4ID0gdHJ1ZVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0TWFpbldpbmRvdyhtYWluV2luOiBlbGVjdHJvbi5Ccm93c2VyV2luZG93KSB7XG5cdG1haW5XaW5kb3cgPSBtYWluV2luXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./main/Constants.js\n");

/***/ }),

/***/ "./main/Errors.js":
/*!************************!*\
  !*** ./main/Errors.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BaseError: () => (/* binding */ BaseError),\n/* harmony export */   ProcessError: () => (/* binding */ ProcessError),\n/* harmony export */   ReadError: () => (/* binding */ ReadError),\n/* harmony export */   RequestError: () => (/* binding */ RequestError),\n/* harmony export */   WriteError: () => (/* binding */ WriteError)\n/* harmony export */ });\nclass BaseError extends Error {\n    constructor(name, wrapErr, message, args) {\n        super();\n        if (args) {\n            for (let key in args) {\n                message += \" \" + key + \"=\" + args[key];\n            }\n        }\n        if (wrapErr) {\n            message += \"\\n\" + wrapErr;\n        }\n        this.name = name;\n        this.message = message;\n        if (wrapErr) {\n            this.stack = wrapErr.stack;\n        }\n    }\n}\nclass ReadError extends BaseError {\n    constructor(wrapErr, message, args) {\n        super(\"ReadError\", wrapErr, message, args);\n    }\n}\nclass WriteError extends BaseError {\n    constructor(wrapErr, message, args) {\n        super(\"WriteError\", wrapErr, message, args);\n    }\n}\nclass RequestError extends BaseError {\n    constructor(wrapErr, message, args) {\n        super(\"RequestError\", wrapErr, message, args);\n    }\n}\nclass ProcessError extends BaseError {\n    constructor(wrapErr, message, args) {\n        super(\"ProcessError\", wrapErr, message, args);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWluL0Vycm9ycy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFPLE1BQU0sU0FBVSxTQUFRLEtBQUs7SUFDbkMsWUFBWSxJQUFZLEVBQUUsT0FBYyxFQUFFLE9BQWUsRUFDeEQsSUFBMkI7UUFFM0IsS0FBSyxFQUFFO1FBRVAsSUFBSSxJQUFJLEVBQUUsQ0FBQztZQUNWLEtBQUssSUFBSSxHQUFHLElBQUksSUFBSSxFQUFFLENBQUM7Z0JBQ3RCLE9BQU8sSUFBSSxHQUFHLEdBQUcsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDO1lBQ3ZDLENBQUM7UUFDRixDQUFDO1FBRUQsSUFBSSxPQUFPLEVBQUUsQ0FBQztZQUNiLE9BQU8sSUFBSSxJQUFJLEdBQUcsT0FBTztRQUMxQixDQUFDO1FBRUQsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJO1FBQ2hCLElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTztRQUN0QixJQUFJLE9BQU8sRUFBRSxDQUFDO1lBQ2IsSUFBSSxDQUFDLEtBQUssR0FBRyxPQUFPLENBQUMsS0FBSztRQUMzQixDQUFDO0lBQ0YsQ0FBQztDQUNEO0FBRU0sTUFBTSxTQUFVLFNBQVEsU0FBUztJQUN2QyxZQUFZLE9BQWMsRUFBRSxPQUFlLEVBQUUsSUFBMkI7UUFDdkUsS0FBSyxDQUFDLFdBQVcsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQztJQUMzQyxDQUFDO0NBQ0Q7QUFFTSxNQUFNLFVBQVcsU0FBUSxTQUFTO0lBQ3hDLFlBQVksT0FBYyxFQUFFLE9BQWUsRUFBRSxJQUEyQjtRQUN2RSxLQUFLLENBQUMsWUFBWSxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsSUFBSSxDQUFDO0lBQzVDLENBQUM7Q0FDRDtBQUVNLE1BQU0sWUFBYSxTQUFRLFNBQVM7SUFDMUMsWUFBWSxPQUFjLEVBQUUsT0FBZSxFQUFFLElBQTJCO1FBQ3ZFLEtBQUssQ0FBQyxjQUFjLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxJQUFJLENBQUM7SUFDOUMsQ0FBQztDQUNEO0FBRU0sTUFBTSxZQUFhLFNBQVEsU0FBUztJQUMxQyxZQUFZLE9BQWMsRUFBRSxPQUFlLEVBQUUsSUFBMkI7UUFDdkUsS0FBSyxDQUFDLGNBQWMsRUFBRSxPQUFPLEVBQUUsT0FBTyxFQUFFLElBQUksQ0FBQztJQUM5QyxDQUFDO0NBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbWFpbi9FcnJvcnMudHM/NTJjNSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgY2xhc3MgQmFzZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihuYW1lOiBzdHJpbmcsIHdyYXBFcnI6IEVycm9yLCBtZXNzYWdlOiBzdHJpbmcsXG5cdFx0YXJncz86IHtba2V5OiBzdHJpbmddOiBhbnl9KSB7XG5cblx0XHRzdXBlcigpXG5cblx0XHRpZiAoYXJncykge1xuXHRcdFx0Zm9yIChsZXQga2V5IGluIGFyZ3MpIHtcblx0XHRcdFx0bWVzc2FnZSArPSBcIiBcIiArIGtleSArIFwiPVwiICsgYXJnc1trZXldXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHdyYXBFcnIpIHtcblx0XHRcdG1lc3NhZ2UgKz0gXCJcXG5cIiArIHdyYXBFcnJcblx0XHR9XG5cblx0XHR0aGlzLm5hbWUgPSBuYW1lXG5cdFx0dGhpcy5tZXNzYWdlID0gbWVzc2FnZVxuXHRcdGlmICh3cmFwRXJyKSB7XG5cdFx0XHR0aGlzLnN0YWNrID0gd3JhcEVyci5zdGFja1xuXHRcdH1cblx0fVxufVxuXG5leHBvcnQgY2xhc3MgUmVhZEVycm9yIGV4dGVuZHMgQmFzZUVycm9yIHtcblx0Y29uc3RydWN0b3Iod3JhcEVycjogRXJyb3IsIG1lc3NhZ2U6IHN0cmluZywgYXJncz86IHtba2V5OiBzdHJpbmddOiBhbnl9KSB7XG5cdFx0c3VwZXIoXCJSZWFkRXJyb3JcIiwgd3JhcEVyciwgbWVzc2FnZSwgYXJncylcblx0fVxufVxuXG5leHBvcnQgY2xhc3MgV3JpdGVFcnJvciBleHRlbmRzIEJhc2VFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHdyYXBFcnI6IEVycm9yLCBtZXNzYWdlOiBzdHJpbmcsIGFyZ3M/OiB7W2tleTogc3RyaW5nXTogYW55fSkge1xuXHRcdHN1cGVyKFwiV3JpdGVFcnJvclwiLCB3cmFwRXJyLCBtZXNzYWdlLCBhcmdzKVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuXHRjb25zdHJ1Y3Rvcih3cmFwRXJyOiBFcnJvciwgbWVzc2FnZTogc3RyaW5nLCBhcmdzPzoge1trZXk6IHN0cmluZ106IGFueX0pIHtcblx0XHRzdXBlcihcIlJlcXVlc3RFcnJvclwiLCB3cmFwRXJyLCBtZXNzYWdlLCBhcmdzKVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBQcm9jZXNzRXJyb3IgZXh0ZW5kcyBCYXNlRXJyb3Ige1xuXHRjb25zdHJ1Y3Rvcih3cmFwRXJyOiBFcnJvciwgbWVzc2FnZTogc3RyaW5nLCBhcmdzPzoge1trZXk6IHN0cmluZ106IGFueX0pIHtcblx0XHRzdXBlcihcIlByb2Nlc3NFcnJvclwiLCB3cmFwRXJyLCBtZXNzYWdlLCBhcmdzKVxuXHR9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./main/Errors.js\n");

/***/ }),

/***/ "./main/Logger.js":
/*!************************!*\
  !*** ./main/Logger.js ***!
  \************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   error: () => (/* binding */ error),\n/* harmony export */   info: () => (/* binding */ info),\n/* harmony export */   warning: () => (/* binding */ warning)\n/* harmony export */ });\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Errors */ \"./main/Errors.js\");\n/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Constants */ \"./main/Constants.js\");\n\n\n\nfunction push(level, err) {\n    if (!err) {\n        err = \"Undefined error\";\n    }\n    let time = new Date();\n    let msg = err.message || err;\n    msg = \"[\" + time.getFullYear() + \"-\" + (time.getMonth() + 1) + \"-\" +\n        time.getDate() + \" \" + time.getHours() + \":\" + time.getMinutes() + \":\" +\n        time.getSeconds() + \"][\" + level + \"] \" + msg + \"\\n\" + (err.stack || \"\");\n    msg = msg.trim();\n    let pth = _Constants__WEBPACK_IMPORTED_MODULE_2__.logPath;\n    fs__WEBPACK_IMPORTED_MODULE_0___default().stat(pth, (err, stat) => {\n        if (stat && stat.size > 200000) {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().unlink(pth, () => {\n                fs__WEBPACK_IMPORTED_MODULE_0___default().appendFile(pth, msg + \"\\n\", (err) => {\n                    if (err) {\n                        err = new _Errors__WEBPACK_IMPORTED_MODULE_1__.WriteError(err, \"Logger: Failed to write log\", { log_path: pth });\n                        console.error(err);\n                    }\n                });\n            });\n        }\n        else {\n            fs__WEBPACK_IMPORTED_MODULE_0___default().appendFile(pth, msg + \"\\n\", (err) => {\n                if (err) {\n                    err = new _Errors__WEBPACK_IMPORTED_MODULE_1__.WriteError(err, \"Logger: Failed to write log\", { log_path: pth });\n                    console.error(err);\n                }\n            });\n        }\n    });\n}\nfunction info(err) {\n    push(\"INFO\", err);\n}\nfunction warning(err) {\n    push(\"WARN\", err);\n}\nfunction error(err) {\n    push(\"ERROR\", err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWluL0xvZ2dlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQW1CO0FBR2U7QUFDTztBQUV6QyxTQUFTLElBQUksQ0FBQyxLQUFhLEVBQUUsR0FBUTtJQUNwQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDVixHQUFHLEdBQUcsaUJBQWlCO0lBQ3hCLENBQUM7SUFFRCxJQUFJLElBQUksR0FBRyxJQUFJLElBQUksRUFBRTtJQUNyQixJQUFJLEdBQUcsR0FBRyxHQUFHLENBQUMsT0FBTyxJQUFJLEdBQUc7SUFFNUIsR0FBRyxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxFQUFFLEdBQUcsR0FBRyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxHQUFHLENBQUMsQ0FBQyxHQUFHLEdBQUc7UUFDakUsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLEdBQUcsR0FBRyxJQUFJLENBQUMsUUFBUSxFQUFFLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLEVBQUUsR0FBRyxHQUFHO1FBQ3RFLElBQUksQ0FBQyxVQUFVLEVBQUUsR0FBRyxJQUFJLEdBQUcsS0FBSyxHQUFJLElBQUksR0FBRyxHQUFHLEdBQUcsSUFBSSxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUM7SUFFMUUsR0FBRyxHQUFHLEdBQUcsQ0FBQyxJQUFJLEVBQUU7SUFFaEIsSUFBSSxHQUFHLEdBQUcsK0NBQWlCO0lBRTNCLDhDQUFPLENBQUMsR0FBRyxFQUFFLENBQUMsR0FBVSxFQUFFLElBQUksRUFBRSxFQUFFO1FBQ2pDLElBQUksSUFBSSxJQUFJLElBQUksQ0FBQyxJQUFJLEdBQUcsTUFBTSxFQUFFLENBQUM7WUFDaEMsZ0RBQVMsQ0FBQyxHQUFHLEVBQUUsR0FBRyxFQUFFO2dCQUNuQixvREFBYSxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsSUFBSSxFQUFFLENBQUMsR0FBVSxFQUFRLEVBQUU7b0JBQ25ELElBQUksR0FBRyxFQUFFLENBQUM7d0JBQ1QsR0FBRyxHQUFHLElBQUksK0NBQWlCLENBQUMsR0FBRyxFQUFFLDZCQUE2QixFQUM3RCxFQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUMsQ0FBQzt3QkFDakIsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUM7b0JBQ25CLENBQUM7Z0JBQ0YsQ0FBQyxDQUFDO1lBQ0gsQ0FBQyxDQUFDO1FBQ0gsQ0FBQzthQUFNLENBQUM7WUFDUCxvREFBYSxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUcsSUFBSSxFQUFFLENBQUMsR0FBVSxFQUFRLEVBQUU7Z0JBQ25ELElBQUksR0FBRyxFQUFFLENBQUM7b0JBQ1QsR0FBRyxHQUFHLElBQUksK0NBQWlCLENBQUMsR0FBRyxFQUFFLDZCQUE2QixFQUM3RCxFQUFDLFFBQVEsRUFBRSxHQUFHLEVBQUMsQ0FBQztvQkFDakIsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUM7Z0JBQ25CLENBQUM7WUFDRixDQUFDLENBQUM7UUFDSCxDQUFDO0lBQ0YsQ0FBQyxDQUFDO0FBQ0gsQ0FBQztBQUVNLFNBQVMsSUFBSSxDQUFDLEdBQVE7SUFDNUIsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUM7QUFDbEIsQ0FBQztBQUVNLFNBQVMsT0FBTyxDQUFDLEdBQVE7SUFDL0IsSUFBSSxDQUFDLE1BQU0sRUFBRSxHQUFHLENBQUM7QUFDbEIsQ0FBQztBQUVNLFNBQVMsS0FBSyxDQUFDLEdBQVE7SUFDN0IsSUFBSSxDQUFDLE9BQU8sRUFBRSxHQUFHLENBQUM7QUFDbkIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9tYWluL0xvZ2dlci50cz8xYTg2Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBmcyBmcm9tIFwiZnNcIlxuaW1wb3J0IHBhdGggZnJvbSBcInBhdGhcIlxuaW1wb3J0IGVsZWN0cm9uIGZyb20gXCJlbGVjdHJvblwiXG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSBcIi4vRXJyb3JzXCJcbmltcG9ydCAqIGFzIENvbnN0YW50cyBmcm9tIFwiLi9Db25zdGFudHNcIjtcblxuZnVuY3Rpb24gcHVzaChsZXZlbDogc3RyaW5nLCBlcnI6IGFueSk6IHZvaWQge1xuXHRpZiAoIWVycikge1xuXHRcdGVyciA9IFwiVW5kZWZpbmVkIGVycm9yXCJcblx0fVxuXG5cdGxldCB0aW1lID0gbmV3IERhdGUoKVxuXHRsZXQgbXNnID0gZXJyLm1lc3NhZ2UgfHwgZXJyXG5cblx0bXNnID0gXCJbXCIgKyB0aW1lLmdldEZ1bGxZZWFyKCkgKyBcIi1cIiArICh0aW1lLmdldE1vbnRoKCkgKyAxKSArIFwiLVwiICtcblx0XHR0aW1lLmdldERhdGUoKSArIFwiIFwiICsgdGltZS5nZXRIb3VycygpICsgXCI6XCIgKyB0aW1lLmdldE1pbnV0ZXMoKSArIFwiOlwiICtcblx0XHR0aW1lLmdldFNlY29uZHMoKSArIFwiXVtcIiArIGxldmVsICArIFwiXSBcIiArIG1zZyArIFwiXFxuXCIgKyAoZXJyLnN0YWNrIHx8IFwiXCIpXG5cblx0bXNnID0gbXNnLnRyaW0oKVxuXG5cdGxldCBwdGggPSBDb25zdGFudHMubG9nUGF0aFxuXG5cdGZzLnN0YXQocHRoLCAoZXJyOiBFcnJvciwgc3RhdCkgPT4ge1xuXHRcdGlmIChzdGF0ICYmIHN0YXQuc2l6ZSA+IDIwMDAwMCkge1xuXHRcdFx0ZnMudW5saW5rKHB0aCwgKCkgPT4ge1xuXHRcdFx0XHRmcy5hcHBlbmRGaWxlKHB0aCwgbXNnICsgXCJcXG5cIiwgKGVycjogRXJyb3IpOiB2b2lkID0+IHtcblx0XHRcdFx0XHRpZiAoZXJyKSB7XG5cdFx0XHRcdFx0XHRlcnIgPSBuZXcgRXJyb3JzLldyaXRlRXJyb3IoZXJyLCBcIkxvZ2dlcjogRmFpbGVkIHRvIHdyaXRlIGxvZ1wiLFxuXHRcdFx0XHRcdFx0XHR7bG9nX3BhdGg6IHB0aH0pXG5cdFx0XHRcdFx0XHRjb25zb2xlLmVycm9yKGVycilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pXG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmcy5hcHBlbmRGaWxlKHB0aCwgbXNnICsgXCJcXG5cIiwgKGVycjogRXJyb3IpOiB2b2lkID0+IHtcblx0XHRcdFx0aWYgKGVycikge1xuXHRcdFx0XHRcdGVyciA9IG5ldyBFcnJvcnMuV3JpdGVFcnJvcihlcnIsIFwiTG9nZ2VyOiBGYWlsZWQgdG8gd3JpdGUgbG9nXCIsXG5cdFx0XHRcdFx0XHR7bG9nX3BhdGg6IHB0aH0pXG5cdFx0XHRcdFx0Y29uc29sZS5lcnJvcihlcnIpXG5cdFx0XHRcdH1cblx0XHRcdH0pXG5cdFx0fVxuXHR9KVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaW5mbyhlcnI6IGFueSk6IHZvaWQge1xuXHRwdXNoKFwiSU5GT1wiLCBlcnIpXG59XG5cbmV4cG9ydCBmdW5jdGlvbiB3YXJuaW5nKGVycjogYW55KTogdm9pZCB7XG5cdHB1c2goXCJXQVJOXCIsIGVycilcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGVycm9yKGVycjogYW55KTogdm9pZCB7XG5cdHB1c2goXCJFUlJPUlwiLCBlcnIpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./main/Logger.js\n");

/***/ }),

/***/ "./main/Main.js":
/*!**********************!*\
  !*** ./main/Main.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! process */ \"process\");\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Utils */ \"./main/Utils.js\");\n/* harmony import */ var _Service__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Service */ \"./main/Service.js\");\n/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./Constants */ \"./main/Constants.js\");\n/* harmony import */ var _Config__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Config */ \"./main/Config.js\");\n/* harmony import */ var _app_Errors__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ../app/Errors */ \"./app/Errors.js\");\n/* harmony import */ var _Tpm__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./Tpm */ \"./main/Tpm.js\");\n\n\n\n\n\n\n\n\n\n\nlet tray;\nlet awaken;\nlet ready;\nlet readyError;\nlet main;\nlet windowSize;\nif ((electron__WEBPACK_IMPORTED_MODULE_3___default().app).dock) {\n    electron__WEBPACK_IMPORTED_MODULE_3___default().app.dock.hide();\n}\nprocess__WEBPACK_IMPORTED_MODULE_0___default().on(\"uncaughtException\", function (error) {\n    let errorMsg;\n    if (error && error.stack) {\n        errorMsg = error.stack;\n    }\n    else {\n        errorMsg = String(error);\n    }\n    if (!ready) {\n        readyError = errorMsg;\n        return;\n    }\n    electron__WEBPACK_IMPORTED_MODULE_3___default().dialog.showMessageBox(null, {\n        type: \"error\",\n        buttons: [\"Exit\"],\n        title: \"Pritunl Client - Process Error\",\n        message: \"Error occured in main process:\\n\\n\" + errorMsg,\n    }).then(function () {\n        electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n    });\n});\nprocess__WEBPACK_IMPORTED_MODULE_0___default().on(\"unhandledRejection\", function (error) {\n    let errorMsg = String(error);\n    if (!ready) {\n        readyError = errorMsg;\n        return;\n    }\n    electron__WEBPACK_IMPORTED_MODULE_3___default().dialog.showMessageBox(null, {\n        type: \"error\",\n        buttons: [\"Exit\"],\n        title: \"Pritunl Client - Process Error\",\n        message: \"Error occured in main process:\\n\\n\" + errorMsg,\n    }).then(function () {\n        electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n    });\n});\nelectron__WEBPACK_IMPORTED_MODULE_3___default().ipcMain.handle(\"processing\", (evt, msg, data) => {\n    if (msg === \"encrypt\") {\n        let encData = electron__WEBPACK_IMPORTED_MODULE_3___default().safeStorage.encryptString(data).toString(\"base64\");\n        return [null, encData];\n    }\n    else if (msg === \"decrypt\") {\n        let encData = new Buffer(data, \"base64\");\n        let decData = electron__WEBPACK_IMPORTED_MODULE_3___default().safeStorage.decryptString(encData);\n        return [null, decData];\n    }\n    else if (msg === \"encryptable\") {\n        return [null, electron__WEBPACK_IMPORTED_MODULE_3___default().safeStorage.isEncryptionAvailable()];\n    }\n    let err = new _app_Errors__WEBPACK_IMPORTED_MODULE_8__.ParseError(null, \"Main: Unknown handler type\");\n    return [err, null];\n});\nelectron__WEBPACK_IMPORTED_MODULE_3___default().ipcMain.on(\"control\", (evt, msg, data) => {\n    if (msg === \"service-auth-error\") {\n        electron__WEBPACK_IMPORTED_MODULE_3___default().dialog.showMessageBox(null, {\n            type: \"error\",\n            buttons: [\"Exit\"],\n            title: \"Pritunl - Service Error (4827)\",\n            message: \"Failed to load service key. Restart \" +\n                \"computer and verify background service is running\",\n        }).then(function () {\n            electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n        });\n    }\n    else if (msg === \"service-conn-error\") {\n        electron__WEBPACK_IMPORTED_MODULE_3___default().dialog.showMessageBox(null, {\n            type: \"error\",\n            buttons: [\"Exit\"],\n            title: \"Pritunl - Service Error (2754)\",\n            message: \"Unable to establish communication with \" +\n                \"background service, try restarting computer\",\n        }).then(function () {\n            electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n        });\n    }\n    else if (msg === \"dev-tools\") {\n        if (main && main.window) {\n            main.window.webContents.openDevTools({\n                \"mode\": \"undocked\",\n            });\n        }\n    }\n    else if (msg === \"reload\") {\n        if (main && main.window) {\n            main.window.reload();\n        }\n    }\n    else if (msg === \"minimize\") {\n        if (main && main.window) {\n            main.window.minimize();\n        }\n    }\n    else if (msg === \"download-update\") {\n        _Utils__WEBPACK_IMPORTED_MODULE_4__.openLink(\"https://client.pritunl.com/#install\");\n    }\n});\n_Service__WEBPACK_IMPORTED_MODULE_5__.wakeup().then((awake) => {\n    awaken = awake;\n    if (ready) {\n        init();\n    }\n});\nclass Main {\n    showWindow() {\n        this.window.show();\n    }\n    createWindow() {\n        let frameless = false;\n        let titleBarStyle;\n        let framelessClient = false;\n        let width = 424;\n        let height = 528;\n        let minWidth = 385;\n        let minHeight = 440;\n        let maxWidth = 670;\n        let maxHeight = 800;\n        if ((process__WEBPACK_IMPORTED_MODULE_0___default().platform) === \"win32\" || _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].frameless) {\n            frameless = true;\n            framelessClient = true;\n            width = 430;\n            minWidth = 410;\n            if ((process__WEBPACK_IMPORTED_MODULE_0___default().platform) === \"win32\") {\n                frameless = false;\n                titleBarStyle = \"hidden\";\n            }\n        }\n        if (_Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].window_width && _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].window_height) {\n            width = _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].window_width;\n            if (width < minWidth) {\n                width = minWidth;\n            }\n            height = _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].window_height;\n            if (height < minHeight) {\n                height = minHeight;\n            }\n        }\n        let zoomFactor = 1;\n        if (zoomFactor !== 1) {\n            width = Math.round(width * zoomFactor);\n            height = Math.round(height * zoomFactor);\n            minWidth = Math.round(minWidth * zoomFactor);\n            minHeight = Math.round(minHeight * zoomFactor);\n            maxWidth = Math.round(maxWidth * zoomFactor);\n            maxHeight = Math.round(maxHeight * zoomFactor);\n        }\n        this.window = new (electron__WEBPACK_IMPORTED_MODULE_3___default().BrowserWindow)({\n            title: \"Pritunl Client\",\n            icon: path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"logo.png\"),\n            titleBarStyle: titleBarStyle,\n            frame: !frameless,\n            autoHideMenuBar: true,\n            fullscreen: false,\n            show: false,\n            width: width,\n            height: height,\n            minWidth: minWidth,\n            minHeight: minHeight,\n            maxWidth: maxWidth,\n            maxHeight: maxHeight,\n            backgroundColor: \"#151719\",\n            webPreferences: {\n                zoomFactor: zoomFactor,\n                devTools: true,\n                nodeIntegration: true,\n                contextIsolation: false,\n            }\n        });\n        _Constants__WEBPACK_IMPORTED_MODULE_6__.setMainWindow(this.window);\n        this.window.webContents.setUserAgent(\"pritunl\");\n        this.window.on(\"close\", () => {\n            try {\n                windowSize = this.window.getSize();\n            }\n            catch { }\n        });\n        this.window.on(\"closed\", async () => {\n            main = null;\n        });\n        let shown = false;\n        this.window.on(\"ready-to-show\", () => {\n            if (shown) {\n                return;\n            }\n            shown = true;\n            this.window.show();\n            if (_Constants__WEBPACK_IMPORTED_MODULE_6__.devTools) {\n                this.window.webContents.openDevTools({\n                    \"mode\": \"undocked\",\n                });\n            }\n        });\n        setTimeout(() => {\n            if (shown) {\n                return;\n            }\n            shown = true;\n            this.window.show();\n            if (_Constants__WEBPACK_IMPORTED_MODULE_6__.devTools) {\n                this.window.webContents.openDevTools({\n                    \"mode\": \"undocked\",\n                });\n            }\n        }, 800);\n        let indexUrl = \"file://\" + path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"index.html\");\n        indexUrl += \"?dev=\" + (!_Constants__WEBPACK_IMPORTED_MODULE_6__.production ? \"true\" : \"false\");\n        indexUrl += \"&dataPath=\" + encodeURIComponent(electron__WEBPACK_IMPORTED_MODULE_3___default().app.getPath(\"userData\"));\n        indexUrl += \"&frameless=\" + (framelessClient ? \"true\" : \"false\");\n        this.window.loadURL(indexUrl, {\n            userAgent: \"pritunl\",\n        });\n        if ((electron__WEBPACK_IMPORTED_MODULE_3___default().app).dock) {\n            electron__WEBPACK_IMPORTED_MODULE_3___default().app.dock.show();\n        }\n    }\n    run() {\n        if (main) {\n            main.showWindow();\n            return;\n        }\n        this.createWindow();\n        main = this;\n    }\n}\nfunction initTray() {\n    tray = new (electron__WEBPACK_IMPORTED_MODULE_3___default().Tray)(getTrayIcon(false));\n    tray.on(\"click\", function () {\n        let main = new Main();\n        main.run();\n    });\n    tray.on(\"double-click\", function () {\n        let main = new Main();\n        main.run();\n    });\n    let trayMenu = electron__WEBPACK_IMPORTED_MODULE_3___default().Menu.buildFromTemplate([\n        {\n            label: \"Open Pritunl Client\",\n            click: function () {\n                let main = new Main();\n                main.run();\n            }\n        },\n        {\n            label: \"Exit\",\n            click: function () {\n                electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n            }\n        }\n    ]);\n    tray.setToolTip(\"Pritunl Client\");\n    tray.setContextMenu(trayMenu);\n    _Service__WEBPACK_IMPORTED_MODULE_5__.sync().then((status) => {\n        if (tray) {\n            tray.setImage(getTrayIcon(status));\n        }\n    });\n}\nfunction initAppMenu() {\n    let appMenu = electron__WEBPACK_IMPORTED_MODULE_3___default().Menu.buildFromTemplate([\n        {\n            label: \"Pritunl\",\n            submenu: [\n                {\n                    label: \"Pritunl Client\",\n                },\n                {\n                    label: \"Close\",\n                    accelerator: \"CmdOrCtrl+W\",\n                    role: \"close\",\n                },\n                {\n                    label: \"Exit\",\n                    accelerator: \"Cmd+Q\",\n                    click: function () {\n                        electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n                    },\n                },\n            ],\n        },\n        {\n            label: \"Edit\",\n            submenu: [\n                {\n                    label: \"Undo\",\n                    accelerator: \"CmdOrCtrl+Z\",\n                    role: \"undo\",\n                },\n                {\n                    label: \"Redo\",\n                    accelerator: \"Shift+CmdOrCtrl+Z\",\n                    role: \"redo\",\n                },\n                {\n                    type: \"separator\",\n                },\n                {\n                    label: \"Cut\",\n                    accelerator: \"CmdOrCtrl+X\",\n                    role: \"cut\",\n                },\n                {\n                    label: \"Copy\",\n                    accelerator: \"CmdOrCtrl+C\",\n                    role: \"copy\",\n                },\n                {\n                    label: \"Paste\",\n                    accelerator: \"CmdOrCtrl+V\",\n                    role: \"paste\",\n                },\n                {\n                    label: \"Select All\",\n                    accelerator: \"CmdOrCtrl+A\",\n                    role: \"selectall\",\n                },\n            ],\n        }\n    ]);\n    electron__WEBPACK_IMPORTED_MODULE_3___default().Menu.setApplicationMenu(appMenu);\n}\nfunction init() {\n    if (awaken === undefined) {\n        return;\n    }\n    else if (awaken) {\n        electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n        return;\n    }\n    _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].load().then(() => {\n        _Service__WEBPACK_IMPORTED_MODULE_5__.connect().then(() => {\n            if (process__WEBPACK_IMPORTED_MODULE_0___default().argv.indexOf(\"--no-main\") !== -1) {\n                if (_Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].disable_tray_icon) {\n                    electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n                    return;\n                }\n            }\n            else {\n                let main = new Main();\n                main.run();\n            }\n            initAppMenu();\n            if (!_Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].disable_tray_icon) {\n                initTray();\n            }\n            _Service__WEBPACK_IMPORTED_MODULE_5__.subscribe((event) => {\n                if (event.type === \"connected\") {\n                    if (tray) {\n                        tray.setImage(getTrayIcon(true));\n                    }\n                }\n                else if (event.type === \"disconnected\") {\n                    if (tray) {\n                        tray.setImage(getTrayIcon(false));\n                    }\n                }\n                else if (event.type === \"wakeup\") {\n                    _Service__WEBPACK_IMPORTED_MODULE_5__.send(\"awake\");\n                    let main = new Main();\n                    main.run();\n                }\n                else if (event.type === \"shutdown\") {\n                    if (process__WEBPACK_IMPORTED_MODULE_0___default().argv.indexOf(\"--no-shutdown\") === -1) {\n                        electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n                    }\n                }\n                else if (event.type === \"sso_auth\") {\n                    _Utils__WEBPACK_IMPORTED_MODULE_4__.openLink(event.data.url);\n                }\n                else if (event.type === \"tpm_open\") {\n                    _Tpm__WEBPACK_IMPORTED_MODULE_9__.open(event.data.id, event.data.private_key);\n                }\n                else if (event.type === \"tpm_sign\") {\n                    _Tpm__WEBPACK_IMPORTED_MODULE_9__.sign(event.data.id, event.data.sign_data);\n                }\n                else if (event.type === \"tpm_close\") {\n                    _Tpm__WEBPACK_IMPORTED_MODULE_9__.close(event.data.id);\n                }\n            });\n        });\n    });\n}\nfunction getTrayIcon(state) {\n    let connTray = \"\";\n    let disconnTray = \"\";\n    if ((process__WEBPACK_IMPORTED_MODULE_0___default().platform) === \"darwin\") {\n        connTray = path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"img\", \"tray_connected_osxTemplate.png\");\n        disconnTray = path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"img\", \"tray_disconnected_osxTemplate.png\");\n    }\n    else if ((process__WEBPACK_IMPORTED_MODULE_0___default().platform) === \"win32\") {\n        if ((electron__WEBPACK_IMPORTED_MODULE_3___default().nativeTheme).shouldUseDarkColors) {\n            connTray = path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"img\", \"tray_connected_win_light.png\");\n            disconnTray = path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"img\", \"tray_disconnected_win_light.png\");\n        }\n        else {\n            connTray = path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"img\", \"tray_connected_win_dark.png\");\n            disconnTray = path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"img\", \"tray_disconnected_win_dark.png\");\n        }\n    }\n    else if ((process__WEBPACK_IMPORTED_MODULE_0___default().platform) === \"linux\") {\n        connTray = path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"img\", \"tray_connected_linux_light.png\");\n        disconnTray = path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"img\", \"tray_disconnected_linux_light.png\");\n    }\n    else {\n        connTray = path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"img\", \"tray_connected.png\");\n        disconnTray = path__WEBPACK_IMPORTED_MODULE_1___default().join(__dirname, \"..\", \"img\", \"tray_disconnected.png\");\n    }\n    if (state) {\n        return connTray;\n    }\n    else {\n        return disconnTray;\n    }\n}\nelectron__WEBPACK_IMPORTED_MODULE_3___default().app.on(\"window-all-closed\", () => {\n    try {\n        _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].load().then(async () => {\n            if (windowSize && windowSize.length == 2) {\n                _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].window_width = windowSize[0];\n                _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].window_height = windowSize[1];\n                await _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].save({\n                    window_width: _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].window_width,\n                    window_height: _Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].window_height,\n                });\n            }\n            if (_Config__WEBPACK_IMPORTED_MODULE_7__[\"default\"].disable_tray_icon || !tray) {\n                electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n            }\n            else {\n                if ((electron__WEBPACK_IMPORTED_MODULE_3___default().app).dock) {\n                    electron__WEBPACK_IMPORTED_MODULE_3___default().app.dock.hide();\n                }\n            }\n        });\n    }\n    catch (error) {\n        throw error;\n    }\n});\nelectron__WEBPACK_IMPORTED_MODULE_3___default().app.on(\"open-file\", () => {\n    try {\n        let main = new Main();\n        main.run();\n    }\n    catch (error) {\n        throw error;\n    }\n});\nelectron__WEBPACK_IMPORTED_MODULE_3___default().app.on(\"open-url\", () => {\n    try {\n        let main = new Main();\n        main.run();\n    }\n    catch (error) {\n        throw error;\n    }\n});\nelectron__WEBPACK_IMPORTED_MODULE_3___default().app.on(\"activate\", () => {\n    try {\n        let main = new Main();\n        main.run();\n    }\n    catch (error) {\n        throw error;\n    }\n});\nelectron__WEBPACK_IMPORTED_MODULE_3___default().app.on(\"quit\", () => {\n    _Service__WEBPACK_IMPORTED_MODULE_5__.cleanup();\n    try {\n        electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n    }\n    catch (error) {\n        throw error;\n    }\n});\nelectron__WEBPACK_IMPORTED_MODULE_3___default().app.on(\"ready\", () => {\n    let profilesPth = path__WEBPACK_IMPORTED_MODULE_1___default().join(electron__WEBPACK_IMPORTED_MODULE_3___default().app.getPath(\"userData\"), \"profiles\");\n    fs__WEBPACK_IMPORTED_MODULE_2___default().exists(profilesPth, function (exists) {\n        if (!exists) {\n            fs__WEBPACK_IMPORTED_MODULE_2___default().mkdir(profilesPth, function () { });\n        }\n    });\n    try {\n        if (readyError) {\n            electron__WEBPACK_IMPORTED_MODULE_3___default().dialog.showMessageBox(null, {\n                type: \"error\",\n                buttons: [\"Exit\"],\n                title: \"Pritunl Client - Process Error\",\n                message: \"Error occured in main process:\\n\\n\" + readyError,\n            }).then(function () {\n                electron__WEBPACK_IMPORTED_MODULE_3___default().app.quit();\n            });\n            return;\n        }\n        ready = true;\n        init();\n    }\n    catch (error) {\n        throw error;\n    }\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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REFBUyxDQUFDLFdBQVcsRUFBRSxVQUFTLE1BQU07UUFDdEMsSUFBSSxDQUFDLE1BQU0sRUFBRSxDQUFDO1lBQ2IsK0NBQVEsQ0FBQyxXQUFXLEVBQUUsY0FBWSxDQUFDLENBQUM7UUFDckMsQ0FBQztJQUNGLENBQUMsQ0FBQztJQUVGLElBQUksQ0FBQztRQUNKLElBQUksVUFBVSxFQUFFLENBQUM7WUFDaEIsc0RBQWUsQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFO2dCQUNwQyxJQUFJLEVBQUUsT0FBTztnQkFDYixPQUFPLEVBQUUsQ0FBQyxNQUFNLENBQUM7Z0JBQ2pCLEtBQUssRUFBRSxnQ0FBZ0M7Z0JBQ3ZDLE9BQU8sRUFBRSxvQ0FBb0MsR0FBRyxVQUFVO2FBQzFELENBQUMsQ0FBQyxJQUFJLENBQUM7Z0JBQ1AsbURBQVksQ0FBQyxJQUFJLEVBQUU7WUFDcEIsQ0FBQyxDQUFDO1lBQ0YsT0FBTTtRQUNQLENBQUM7UUFFRCxLQUFLLEdBQUcsSUFBSTtRQUNaLElBQUksRUFBRTtJQUNQLENBQUM7SUFBQyxPQUFPLEtBQUssRUFBRSxDQUFDO1FBQ2hCLE1BQU0sS0FBSztJQUNaLENBQUM7QUFDRixDQUFDLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbWFpbi9NYWluLnRzeD8yMGU5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwcm9jZXNzIGZyb20gXCJwcm9jZXNzXCJcbmltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCJcbmltcG9ydCBmcyBmcm9tIFwiZnNcIlxuaW1wb3J0IGVsZWN0cm9uIGZyb20gXCJlbGVjdHJvblwiXG5pbXBvcnQgKiBhcyBVdGlscyBmcm9tIFwiLi9VdGlsc1wiO1xuaW1wb3J0ICogYXMgU2VydmljZSBmcm9tIFwiLi9TZXJ2aWNlXCJcbmltcG9ydCAqIGFzIENvbnN0YW50cyBmcm9tIFwiLi9Db25zdGFudHNcIlxuaW1wb3J0IENvbmZpZyBmcm9tIFwiLi9Db25maWdcIlxuaW1wb3J0ICogYXMgRXJyb3JzIGZyb20gXCIuLi9hcHAvRXJyb3JzXCI7XG5pbXBvcnQgKiBhcyBUcG0gZnJvbSBcIi4vVHBtXCJcblxubGV0IHRyYXk6IGVsZWN0cm9uLlRyYXlcbmxldCBhd2FrZW46IGJvb2xlYW5cbmxldCByZWFkeTogYm9vbGVhblxubGV0IHJlYWR5RXJyb3I6IHN0cmluZ1xubGV0IG1haW46IE1haW5cbmxldCB3aW5kb3dTaXplOiBudW1iZXJbXTtcblxuaWYgKGVsZWN0cm9uLmFwcC5kb2NrKSB7XG5cdGVsZWN0cm9uLmFwcC5kb2NrLmhpZGUoKVxufVxuXG5wcm9jZXNzLm9uKFwidW5jYXVnaHRFeGNlcHRpb25cIiwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdGxldCBlcnJvck1zZzogc3RyaW5nXG5cdGlmIChlcnJvciAmJiBlcnJvci5zdGFjaykge1xuXHRcdGVycm9yTXNnID0gZXJyb3Iuc3RhY2tcblx0fSBlbHNlIHtcblx0XHRlcnJvck1zZyA9IFN0cmluZyhlcnJvcilcblx0fVxuXG5cdGlmICghcmVhZHkpIHtcblx0XHRyZWFkeUVycm9yID0gZXJyb3JNc2dcblx0XHRyZXR1cm5cblx0fVxuXG5cdGVsZWN0cm9uLmRpYWxvZy5zaG93TWVzc2FnZUJveChudWxsLCB7XG5cdFx0dHlwZTogXCJlcnJvclwiLFxuXHRcdGJ1dHRvbnM6IFtcIkV4aXRcIl0sXG5cdFx0dGl0bGU6IFwiUHJpdHVubCBDbGllbnQgLSBQcm9jZXNzIEVycm9yXCIsXG5cdFx0bWVzc2FnZTogXCJFcnJvciBvY2N1cmVkIGluIG1haW4gcHJvY2VzczpcXG5cXG5cIiArIGVycm9yTXNnLFxuXHR9KS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdGVsZWN0cm9uLmFwcC5xdWl0KClcblx0fSlcbn0pXG5cbnByb2Nlc3Mub24oXCJ1bmhhbmRsZWRSZWplY3Rpb25cIiwgZnVuY3Rpb24gKGVycm9yKSB7XG5cdGxldCBlcnJvck1zZzogc3RyaW5nID0gU3RyaW5nKGVycm9yKVxuXG5cdGlmICghcmVhZHkpIHtcblx0XHRyZWFkeUVycm9yID0gZXJyb3JNc2dcblx0XHRyZXR1cm5cblx0fVxuXG5cdGVsZWN0cm9uLmRpYWxvZy5zaG93TWVzc2FnZUJveChudWxsLCB7XG5cdFx0dHlwZTogXCJlcnJvclwiLFxuXHRcdGJ1dHRvbnM6IFtcIkV4aXRcIl0sXG5cdFx0dGl0bGU6IFwiUHJpdHVubCBDbGllbnQgLSBQcm9jZXNzIEVycm9yXCIsXG5cdFx0bWVzc2FnZTogXCJFcnJvciBvY2N1cmVkIGluIG1haW4gcHJvY2VzczpcXG5cXG5cIiArIGVycm9yTXNnLFxuXHR9KS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdGVsZWN0cm9uLmFwcC5xdWl0KClcblx0fSlcbn0pXG5cbmVsZWN0cm9uLmlwY01haW4uaGFuZGxlKFxuXHRcInByb2Nlc3NpbmdcIixcblx0KGV2dDogZWxlY3Ryb24uSXBjTWFpbkV2ZW50LCBtc2c6IHN0cmluZywgZGF0YTogc3RyaW5nKSA9PiB7XG5cdFx0aWYgKG1zZyA9PT0gXCJlbmNyeXB0XCIpIHtcblx0XHRcdGxldCBlbmNEYXRhID0gZWxlY3Ryb24uc2FmZVN0b3JhZ2UuZW5jcnlwdFN0cmluZyhcblx0XHRcdFx0ZGF0YSkudG9TdHJpbmcoXCJiYXNlNjRcIilcblx0XHRcdHJldHVybiBbbnVsbCwgZW5jRGF0YV1cblx0XHR9IGVsc2UgaWYgKG1zZyA9PT0gXCJkZWNyeXB0XCIpIHtcblx0XHRcdGxldCBlbmNEYXRhID0gbmV3IEJ1ZmZlcihkYXRhLCBcImJhc2U2NFwiKVxuXHRcdFx0bGV0IGRlY0RhdGEgPSBlbGVjdHJvbi5zYWZlU3RvcmFnZS5kZWNyeXB0U3RyaW5nKFxuXHRcdFx0XHRlbmNEYXRhKVxuXHRcdFx0cmV0dXJuIFtudWxsLCBkZWNEYXRhXVxuXHRcdH0gZWxzZSBpZiAobXNnID09PSBcImVuY3J5cHRhYmxlXCIpIHtcblx0XHRcdHJldHVybiBbbnVsbCwgZWxlY3Ryb24uc2FmZVN0b3JhZ2UuaXNFbmNyeXB0aW9uQXZhaWxhYmxlKCldXG5cdFx0fVxuXHRcdGxldCBlcnIgPSBuZXcgRXJyb3JzLlBhcnNlRXJyb3IobnVsbCwgXCJNYWluOiBVbmtub3duIGhhbmRsZXIgdHlwZVwiKTtcblx0XHRyZXR1cm4gW2VyciwgbnVsbF1cblx0fSxcbilcblxuZWxlY3Ryb24uaXBjTWFpbi5vbihcblx0XCJjb250cm9sXCIsXG5cdChldnQ6IGVsZWN0cm9uLklwY01haW5FdmVudCwgbXNnOiBzdHJpbmcsIGRhdGE6IHN0cmluZykgPT4ge1xuXHRcdGlmIChtc2cgPT09IFwic2VydmljZS1hdXRoLWVycm9yXCIpIHtcblx0XHRcdGVsZWN0cm9uLmRpYWxvZy5zaG93TWVzc2FnZUJveChudWxsLCB7XG5cdFx0XHRcdHR5cGU6IFwiZXJyb3JcIixcblx0XHRcdFx0YnV0dG9uczogW1wiRXhpdFwiXSxcblx0XHRcdFx0dGl0bGU6IFwiUHJpdHVubCAtIFNlcnZpY2UgRXJyb3IgKDQ4MjcpXCIsXG5cdFx0XHRcdG1lc3NhZ2U6IFwiRmFpbGVkIHRvIGxvYWQgc2VydmljZSBrZXkuIFJlc3RhcnQgXCIgK1xuXHRcdFx0XHRcdFwiY29tcHV0ZXIgYW5kIHZlcmlmeSBiYWNrZ3JvdW5kIHNlcnZpY2UgaXMgcnVubmluZ1wiLFxuXHRcdFx0fSkudGhlbihmdW5jdGlvbigpIHtcblx0XHRcdFx0ZWxlY3Ryb24uYXBwLnF1aXQoKVxuXHRcdFx0fSlcblx0XHR9IGVsc2UgaWYgKG1zZyA9PT0gXCJzZXJ2aWNlLWNvbm4tZXJyb3JcIikge1xuXHRcdFx0ZWxlY3Ryb24uZGlhbG9nLnNob3dNZXNzYWdlQm94KG51bGwsIHtcblx0XHRcdFx0dHlwZTogXCJlcnJvclwiLFxuXHRcdFx0XHRidXR0b25zOiBbXCJFeGl0XCJdLFxuXHRcdFx0XHR0aXRsZTogXCJQcml0dW5sIC0gU2VydmljZSBFcnJvciAoMjc1NClcIixcblx0XHRcdFx0bWVzc2FnZTogXCJVbmFibGUgdG8gZXN0YWJsaXNoIGNvbW11bmljYXRpb24gd2l0aCBcIiArXG5cdFx0XHRcdFx0XCJiYWNrZ3JvdW5kIHNlcnZpY2UsIHRyeSByZXN0YXJ0aW5nIGNvbXB1dGVyXCIsXG5cdFx0XHR9KS50aGVuKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRlbGVjdHJvbi5hcHAucXVpdCgpXG5cdFx0XHR9KVxuXHRcdH0gZWxzZSBpZiAobXNnID09PSBcImRldi10b29sc1wiKSB7XG5cdFx0XHRpZiAobWFpbiAmJiBtYWluLndpbmRvdykge1xuXHRcdFx0XHRtYWluLndpbmRvdy53ZWJDb250ZW50cy5vcGVuRGV2VG9vbHMoe1xuXHRcdFx0XHRcdFwibW9kZVwiOiBcInVuZG9ja2VkXCIsXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtc2cgPT09IFwicmVsb2FkXCIpIHtcblx0XHRcdGlmIChtYWluICYmIG1haW4ud2luZG93KSB7XG5cdFx0XHRcdG1haW4ud2luZG93LnJlbG9hZCgpXG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChtc2cgPT09IFwibWluaW1pemVcIikge1xuXHRcdFx0aWYgKG1haW4gJiYgbWFpbi53aW5kb3cpIHtcblx0XHRcdFx0bWFpbi53aW5kb3cubWluaW1pemUoKVxuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobXNnID09PSBcImRvd25sb2FkLXVwZGF0ZVwiKSB7XG5cdFx0XHRVdGlscy5vcGVuTGluayhcImh0dHBzOi8vY2xpZW50LnByaXR1bmwuY29tLyNpbnN0YWxsXCIpXG5cdFx0fVxuXHR9LFxuKVxuXG5TZXJ2aWNlLndha2V1cCgpLnRoZW4oKGF3YWtlOiBib29sZWFuKSA9PiB7XG5cdGF3YWtlbiA9IGF3YWtlXG5cdGlmIChyZWFkeSkge1xuXHRcdGluaXQoKVxuXHR9XG59KVxuXG5jbGFzcyBNYWluIHtcblx0d2luZG93OiBlbGVjdHJvbi5Ccm93c2VyV2luZG93XG5cblx0c2hvd1dpbmRvdygpOiB2b2lkIHtcblx0XHR0aGlzLndpbmRvdy5zaG93KClcblx0fVxuXG5cdGNyZWF0ZVdpbmRvdygpOiB2b2lkIHtcblx0XHRsZXQgZnJhbWVsZXNzID0gZmFsc2Vcblx0XHRsZXQgdGl0bGVCYXJTdHlsZTogc3RyaW5nXG5cdFx0bGV0IGZyYW1lbGVzc0NsaWVudCA9IGZhbHNlXG5cdFx0bGV0IHdpZHRoID0gNDI0XG5cdFx0bGV0IGhlaWdodCA9IDUyOFxuXHRcdGxldCBtaW5XaWR0aCA9IDM4NVxuXHRcdGxldCBtaW5IZWlnaHQgPSA0NDBcblx0XHRsZXQgbWF4V2lkdGggPSA2NzBcblx0XHRsZXQgbWF4SGVpZ2h0ID0gODAwXG5cblx0XHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiIHx8IENvbmZpZy5mcmFtZWxlc3MpIHtcblx0XHRcdGZyYW1lbGVzcyA9IHRydWVcblx0XHRcdGZyYW1lbGVzc0NsaWVudCA9IHRydWVcblx0XHRcdHdpZHRoID0gNDMwXG5cdFx0XHRtaW5XaWR0aCA9IDQxMFxuXG5cdFx0XHRpZiAocHJvY2Vzcy5wbGF0Zm9ybSA9PT0gXCJ3aW4zMlwiKSB7XG5cdFx0XHRcdGZyYW1lbGVzcyA9IGZhbHNlXG5cdFx0XHRcdHRpdGxlQmFyU3R5bGUgPSBcImhpZGRlblwiXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKENvbmZpZy53aW5kb3dfd2lkdGggJiYgQ29uZmlnLndpbmRvd19oZWlnaHQpIHtcblx0XHRcdHdpZHRoID0gQ29uZmlnLndpbmRvd193aWR0aFxuXHRcdFx0aWYgKHdpZHRoIDwgbWluV2lkdGgpIHtcblx0XHRcdFx0d2lkdGggPSBtaW5XaWR0aFxuXHRcdFx0fVxuXHRcdFx0aGVpZ2h0ID0gQ29uZmlnLndpbmRvd19oZWlnaHRcblx0XHRcdGlmIChoZWlnaHQgPCBtaW5IZWlnaHQpIHtcblx0XHRcdFx0aGVpZ2h0ID0gbWluSGVpZ2h0XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0bGV0IHpvb21GYWN0b3IgPSAxXG5cdFx0aWYgKHpvb21GYWN0b3IgIT09IDEpIHtcblx0XHRcdHdpZHRoID0gTWF0aC5yb3VuZCh3aWR0aCAqIHpvb21GYWN0b3IpXG5cdFx0XHRoZWlnaHQgPSBNYXRoLnJvdW5kKGhlaWdodCAqIHpvb21GYWN0b3IpXG5cdFx0XHRtaW5XaWR0aCA9IE1hdGgucm91bmQobWluV2lkdGggKiB6b29tRmFjdG9yKVxuXHRcdFx0bWluSGVpZ2h0ID0gTWF0aC5yb3VuZChtaW5IZWlnaHQgKiB6b29tRmFjdG9yKVxuXHRcdFx0bWF4V2lkdGggPSBNYXRoLnJvdW5kKG1heFdpZHRoICogem9vbUZhY3Rvcilcblx0XHRcdG1heEhlaWdodCA9IE1hdGgucm91bmQobWF4SGVpZ2h0ICogem9vbUZhY3Rvcilcblx0XHR9XG5cblx0XHR0aGlzLndpbmRvdyA9IG5ldyBlbGVjdHJvbi5Ccm93c2VyV2luZG93KHtcblx0XHRcdHRpdGxlOiBcIlByaXR1bmwgQ2xpZW50XCIsXG5cdFx0XHRpY29uOiBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uXCIsIFwibG9nby5wbmdcIiksXG5cdFx0XHR0aXRsZUJhclN0eWxlOiB0aXRsZUJhclN0eWxlIGFzIGFueSxcblx0XHRcdGZyYW1lOiAhZnJhbWVsZXNzLFxuXHRcdFx0YXV0b0hpZGVNZW51QmFyOiB0cnVlLFxuXHRcdFx0ZnVsbHNjcmVlbjogZmFsc2UsXG5cdFx0XHRzaG93OiBmYWxzZSxcblx0XHRcdHdpZHRoOiB3aWR0aCxcblx0XHRcdGhlaWdodDogaGVpZ2h0LFxuXHRcdFx0bWluV2lkdGg6IG1pbldpZHRoLFxuXHRcdFx0bWluSGVpZ2h0OiBtaW5IZWlnaHQsXG5cdFx0XHRtYXhXaWR0aDogbWF4V2lkdGgsXG5cdFx0XHRtYXhIZWlnaHQ6IG1heEhlaWdodCxcblx0XHRcdGJhY2tncm91bmRDb2xvcjogXCIjMTUxNzE5XCIsXG5cdFx0XHR3ZWJQcmVmZXJlbmNlczoge1xuXHRcdFx0XHR6b29tRmFjdG9yOiB6b29tRmFjdG9yLFxuXHRcdFx0XHRkZXZUb29sczogdHJ1ZSxcblx0XHRcdFx0bm9kZUludGVncmF0aW9uOiB0cnVlLFxuXHRcdFx0XHRjb250ZXh0SXNvbGF0aW9uOiBmYWxzZSxcblx0XHRcdH1cblx0XHR9KVxuXG5cdFx0Q29uc3RhbnRzLnNldE1haW5XaW5kb3codGhpcy53aW5kb3cpXG5cblx0XHR0aGlzLndpbmRvdy53ZWJDb250ZW50cy5zZXRVc2VyQWdlbnQoXCJwcml0dW5sXCIpXG5cblx0XHR0aGlzLndpbmRvdy5vbihcImNsb3NlXCIsICgpOiB2b2lkID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHdpbmRvd1NpemUgPSB0aGlzLndpbmRvdy5nZXRTaXplKClcblx0XHRcdH0gY2F0Y2gge31cblx0XHR9KVxuXG5cdFx0dGhpcy53aW5kb3cub24oXCJjbG9zZWRcIiwgYXN5bmMgKCk6IFByb21pc2U8dm9pZD4gPT4ge1xuXHRcdFx0bWFpbiA9IG51bGxcblx0XHR9KVxuXG5cdFx0bGV0IHNob3duID0gZmFsc2Vcblx0XHR0aGlzLndpbmRvdy5vbihcInJlYWR5LXRvLXNob3dcIiwgKCk6IHZvaWQgPT4ge1xuXHRcdFx0aWYgKHNob3duKSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXHRcdFx0c2hvd24gPSB0cnVlXG5cdFx0XHR0aGlzLndpbmRvdy5zaG93KClcblxuXHRcdFx0aWYgKENvbnN0YW50cy5kZXZUb29scykge1xuXHRcdFx0XHR0aGlzLndpbmRvdy53ZWJDb250ZW50cy5vcGVuRGV2VG9vbHMoe1xuXHRcdFx0XHRcdFwibW9kZVwiOiBcInVuZG9ja2VkXCIsXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cdFx0fSlcblx0XHRzZXRUaW1lb3V0KCgpOiB2b2lkID0+IHtcblx0XHRcdGlmIChzaG93bikge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblx0XHRcdHNob3duID0gdHJ1ZVxuXHRcdFx0dGhpcy53aW5kb3cuc2hvdygpXG5cblx0XHRcdGlmIChDb25zdGFudHMuZGV2VG9vbHMpIHtcblx0XHRcdFx0dGhpcy53aW5kb3cud2ViQ29udGVudHMub3BlbkRldlRvb2xzKHtcblx0XHRcdFx0XHRcIm1vZGVcIjogXCJ1bmRvY2tlZFwiLFxuXHRcdFx0XHR9KVxuXHRcdFx0fVxuXHRcdH0sIDgwMClcblxuXHRcdGxldCBpbmRleFVybCA9IFwiZmlsZTovL1wiICsgcGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLlwiLCBcImluZGV4Lmh0bWxcIilcblx0XHRpbmRleFVybCArPSBcIj9kZXY9XCIgKyAoIUNvbnN0YW50cy5wcm9kdWN0aW9uID8gXCJ0cnVlXCIgOiBcImZhbHNlXCIpXG5cdFx0aW5kZXhVcmwgKz0gXCImZGF0YVBhdGg9XCIgKyBlbmNvZGVVUklDb21wb25lbnQoXG5cdFx0XHRlbGVjdHJvbi5hcHAuZ2V0UGF0aChcInVzZXJEYXRhXCIpKVxuXHRcdGluZGV4VXJsICs9IFwiJmZyYW1lbGVzcz1cIiArIChmcmFtZWxlc3NDbGllbnQgPyBcInRydWVcIiA6IFwiZmFsc2VcIilcblxuXHRcdHRoaXMud2luZG93LmxvYWRVUkwoaW5kZXhVcmwsIHtcblx0XHRcdHVzZXJBZ2VudDogXCJwcml0dW5sXCIsXG5cdFx0fSlcblxuXHRcdGlmIChlbGVjdHJvbi5hcHAuZG9jaykge1xuXHRcdFx0ZWxlY3Ryb24uYXBwLmRvY2suc2hvdygpXG5cdFx0fVxuXHR9XG5cblx0cnVuKCk6IHZvaWQge1xuXHRcdGlmIChtYWluKSB7XG5cdFx0XHRtYWluLnNob3dXaW5kb3coKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0dGhpcy5jcmVhdGVXaW5kb3coKVxuXHRcdG1haW4gPSB0aGlzXG5cdH1cbn1cblxuZnVuY3Rpb24gaW5pdFRyYXkoKSB7XG5cdHRyYXkgPSBuZXcgZWxlY3Ryb24uVHJheShnZXRUcmF5SWNvbihmYWxzZSkpXG5cblx0dHJheS5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKCkge1xuXHRcdGxldCBtYWluID0gbmV3IE1haW4oKVxuXHRcdG1haW4ucnVuKClcblx0fSlcblx0dHJheS5vbihcImRvdWJsZS1jbGlja1wiLCBmdW5jdGlvbigpIHtcblx0XHRsZXQgbWFpbiA9IG5ldyBNYWluKClcblx0XHRtYWluLnJ1bigpXG5cdH0pXG5cblx0bGV0IHRyYXlNZW51ID0gZWxlY3Ryb24uTWVudS5idWlsZEZyb21UZW1wbGF0ZShbXG5cdFx0e1xuXHRcdFx0bGFiZWw6IFwiT3BlbiBQcml0dW5sIENsaWVudFwiLFxuXHRcdFx0Y2xpY2s6IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0bGV0IG1haW4gPSBuZXcgTWFpbigpXG5cdFx0XHRcdG1haW4ucnVuKClcblx0XHRcdH1cblx0XHR9LFxuXHRcdHtcblx0XHRcdGxhYmVsOiBcIkV4aXRcIixcblx0XHRcdGNsaWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZWxlY3Ryb24uYXBwLnF1aXQoKVxuXHRcdFx0fVxuXHRcdH1cblx0XSlcblxuXHR0cmF5LnNldFRvb2xUaXAoXCJQcml0dW5sIENsaWVudFwiKVxuXHR0cmF5LnNldENvbnRleHRNZW51KHRyYXlNZW51KVxuXG5cdFNlcnZpY2Uuc3luYygpLnRoZW4oKHN0YXR1czogYm9vbGVhbik6IHZvaWQgPT4ge1xuXHRcdGlmICh0cmF5KSB7XG5cdFx0XHR0cmF5LnNldEltYWdlKGdldFRyYXlJY29uKHN0YXR1cykpXG5cdFx0fVxuXHR9KVxufVxuXG5mdW5jdGlvbiBpbml0QXBwTWVudSgpIHtcblx0bGV0IGFwcE1lbnUgPSBlbGVjdHJvbi5NZW51LmJ1aWxkRnJvbVRlbXBsYXRlKFtcblx0XHR7XG5cdFx0XHRsYWJlbDogXCJQcml0dW5sXCIsXG5cdFx0XHRzdWJtZW51OiBbXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogXCJQcml0dW5sIENsaWVudFwiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGFiZWw6IFwiQ2xvc2VcIixcblx0XHRcdFx0XHRhY2NlbGVyYXRvcjogXCJDbWRPckN0cmwrV1wiLFxuXHRcdFx0XHRcdHJvbGU6IFwiY2xvc2VcIixcblx0XHRcdFx0fSxcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxhYmVsOiBcIkV4aXRcIixcblx0XHRcdFx0XHRhY2NlbGVyYXRvcjogXCJDbWQrUVwiLFxuXHRcdFx0XHRcdGNsaWNrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGVsZWN0cm9uLmFwcC5xdWl0KClcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHR9LFxuXHRcdFx0XSxcblx0XHR9LFxuXHRcdHtcblx0XHRcdGxhYmVsOiBcIkVkaXRcIixcblx0XHRcdHN1Ym1lbnU6IFtcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGxhYmVsOiBcIlVuZG9cIixcblx0XHRcdFx0XHRhY2NlbGVyYXRvcjogXCJDbWRPckN0cmwrWlwiLFxuXHRcdFx0XHRcdHJvbGU6IFwidW5kb1wiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGFiZWw6IFwiUmVkb1wiLFxuXHRcdFx0XHRcdGFjY2VsZXJhdG9yOiBcIlNoaWZ0K0NtZE9yQ3RybCtaXCIsXG5cdFx0XHRcdFx0cm9sZTogXCJyZWRvXCIsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0eXBlOiBcInNlcGFyYXRvclwiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGFiZWw6IFwiQ3V0XCIsXG5cdFx0XHRcdFx0YWNjZWxlcmF0b3I6IFwiQ21kT3JDdHJsK1hcIixcblx0XHRcdFx0XHRyb2xlOiBcImN1dFwiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGFiZWw6IFwiQ29weVwiLFxuXHRcdFx0XHRcdGFjY2VsZXJhdG9yOiBcIkNtZE9yQ3RybCtDXCIsXG5cdFx0XHRcdFx0cm9sZTogXCJjb3B5XCIsXG5cdFx0XHRcdH0sXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsYWJlbDogXCJQYXN0ZVwiLFxuXHRcdFx0XHRcdGFjY2VsZXJhdG9yOiBcIkNtZE9yQ3RybCtWXCIsXG5cdFx0XHRcdFx0cm9sZTogXCJwYXN0ZVwiLFxuXHRcdFx0XHR9LFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0bGFiZWw6IFwiU2VsZWN0IEFsbFwiLFxuXHRcdFx0XHRcdGFjY2VsZXJhdG9yOiBcIkNtZE9yQ3RybCtBXCIsXG5cdFx0XHRcdFx0cm9sZTogXCJzZWxlY3RhbGxcIixcblx0XHRcdFx0fSxcblx0XHRcdF0sXG5cdFx0fVxuXHRdIGFzIGFueSlcblx0ZWxlY3Ryb24uTWVudS5zZXRBcHBsaWNhdGlvbk1lbnUoYXBwTWVudSlcbn1cblxuZnVuY3Rpb24gaW5pdCgpIHtcblx0aWYgKGF3YWtlbiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuXG5cdH0gZWxzZSBpZiAoYXdha2VuKSB7XG5cdFx0ZWxlY3Ryb24uYXBwLnF1aXQoKVxuXHRcdHJldHVyblxuXHR9XG5cblx0Q29uZmlnLmxvYWQoKS50aGVuKCgpID0+IHtcblx0XHRTZXJ2aWNlLmNvbm5lY3QoKS50aGVuKCgpID0+IHtcblx0XHRcdGlmIChwcm9jZXNzLmFyZ3YuaW5kZXhPZihcIi0tbm8tbWFpblwiKSAhPT0gLTEpIHtcblx0XHRcdFx0aWYgKENvbmZpZy5kaXNhYmxlX3RyYXlfaWNvbikge1xuXHRcdFx0XHRcdGVsZWN0cm9uLmFwcC5xdWl0KClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bGV0IG1haW4gPSBuZXcgTWFpbigpXG5cdFx0XHRcdG1haW4ucnVuKClcblx0XHRcdH1cblxuXHRcdFx0aW5pdEFwcE1lbnUoKVxuXG5cdFx0XHRpZiAoIUNvbmZpZy5kaXNhYmxlX3RyYXlfaWNvbikge1xuXHRcdFx0XHRpbml0VHJheSgpXG5cdFx0XHR9XG5cblx0XHRcdFNlcnZpY2Uuc3Vic2NyaWJlKChldmVudDogU2VydmljZS5FdmVudCk6IHZvaWQgPT4ge1xuXHRcdFx0XHRpZiAoZXZlbnQudHlwZSA9PT0gXCJjb25uZWN0ZWRcIikge1xuXHRcdFx0XHRcdGlmICh0cmF5KSB7XG5cdFx0XHRcdFx0XHR0cmF5LnNldEltYWdlKGdldFRyYXlJY29uKHRydWUpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChldmVudC50eXBlID09PSBcImRpc2Nvbm5lY3RlZFwiKSB7XG5cdFx0XHRcdFx0aWYgKHRyYXkpIHtcblx0XHRcdFx0XHRcdHRyYXkuc2V0SW1hZ2UoZ2V0VHJheUljb24oZmFsc2UpKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChldmVudC50eXBlID09PSBcIndha2V1cFwiKSB7XG5cdFx0XHRcdFx0U2VydmljZS5zZW5kKFwiYXdha2VcIilcblxuXHRcdFx0XHRcdGxldCBtYWluID0gbmV3IE1haW4oKVxuXHRcdFx0XHRcdG1haW4ucnVuKClcblx0XHRcdFx0fSBlbHNlIGlmIChldmVudC50eXBlID09PSBcInNodXRkb3duXCIpIHtcblx0XHRcdFx0XHRpZiAocHJvY2Vzcy5hcmd2LmluZGV4T2YoXCItLW5vLXNodXRkb3duXCIpID09PSAtMSkge1xuXHRcdFx0XHRcdFx0ZWxlY3Ryb24uYXBwLnF1aXQoKVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIGlmIChldmVudC50eXBlID09PSBcInNzb19hdXRoXCIpIHtcblx0XHRcdFx0XHRVdGlscy5vcGVuTGluayhldmVudC5kYXRhLnVybClcblx0XHRcdFx0fSBlbHNlIGlmIChldmVudC50eXBlID09PSBcInRwbV9vcGVuXCIpIHtcblx0XHRcdFx0XHRUcG0ub3BlbihldmVudC5kYXRhLmlkLCBldmVudC5kYXRhLnByaXZhdGVfa2V5KVxuXHRcdFx0XHR9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IFwidHBtX3NpZ25cIikge1xuXHRcdFx0XHRcdFRwbS5zaWduKGV2ZW50LmRhdGEuaWQsIGV2ZW50LmRhdGEuc2lnbl9kYXRhKVxuXHRcdFx0XHR9IGVsc2UgaWYgKGV2ZW50LnR5cGUgPT09IFwidHBtX2Nsb3NlXCIpIHtcblx0XHRcdFx0XHRUcG0uY2xvc2UoZXZlbnQuZGF0YS5pZClcblx0XHRcdFx0fVxuXHRcdFx0fSlcblx0XHR9KVxuXHR9KVxufVxuXG5mdW5jdGlvbiBnZXRUcmF5SWNvbihzdGF0ZTogYm9vbGVhbik6IHN0cmluZyB7XG5cdGxldCBjb25uVHJheSA9IFwiXCJcblx0bGV0IGRpc2Nvbm5UcmF5ID0gXCJcIlxuXG5cdGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcImRhcndpblwiKSB7XG5cdFx0Y29ublRyYXkgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uXCIsIFwiaW1nXCIsXG5cdFx0XHRcInRyYXlfY29ubmVjdGVkX29zeFRlbXBsYXRlLnBuZ1wiKVxuXHRcdGRpc2Nvbm5UcmF5ID0gcGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLlwiLCBcImltZ1wiLFxuXHRcdFx0XCJ0cmF5X2Rpc2Nvbm5lY3RlZF9vc3hUZW1wbGF0ZS5wbmdcIilcblx0fSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcIndpbjMyXCIpIHtcblx0XHRpZiAoZWxlY3Ryb24ubmF0aXZlVGhlbWUuc2hvdWxkVXNlRGFya0NvbG9ycykge1xuXHRcdFx0Y29ublRyYXkgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uXCIsIFwiaW1nXCIsXG5cdFx0XHRcdFwidHJheV9jb25uZWN0ZWRfd2luX2xpZ2h0LnBuZ1wiKVxuXHRcdFx0ZGlzY29ublRyYXkgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uXCIsIFwiaW1nXCIsXG5cdFx0XHRcdFwidHJheV9kaXNjb25uZWN0ZWRfd2luX2xpZ2h0LnBuZ1wiKVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25uVHJheSA9IHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi5cIiwgXCJpbWdcIixcblx0XHRcdFx0XCJ0cmF5X2Nvbm5lY3RlZF93aW5fZGFyay5wbmdcIilcblx0XHRcdGRpc2Nvbm5UcmF5ID0gcGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLlwiLCBcImltZ1wiLFxuXHRcdFx0XHRcInRyYXlfZGlzY29ubmVjdGVkX3dpbl9kYXJrLnBuZ1wiKVxuXHRcdH1cblx0fSBlbHNlIGlmIChwcm9jZXNzLnBsYXRmb3JtID09PSBcImxpbnV4XCIpIHtcblx0XHRjb25uVHJheSA9IHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi5cIiwgXCJpbWdcIixcblx0XHRcdFwidHJheV9jb25uZWN0ZWRfbGludXhfbGlnaHQucG5nXCIpXG5cdFx0ZGlzY29ublRyYXkgPSBwYXRoLmpvaW4oX19kaXJuYW1lLCBcIi4uXCIsIFwiaW1nXCIsXG5cdFx0XHRcInRyYXlfZGlzY29ubmVjdGVkX2xpbnV4X2xpZ2h0LnBuZ1wiKVxuXHR9IGVsc2Uge1xuXHRcdGNvbm5UcmF5ID0gcGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLlwiLCBcImltZ1wiLFxuXHRcdFx0XCJ0cmF5X2Nvbm5lY3RlZC5wbmdcIilcblx0XHRkaXNjb25uVHJheSA9IHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi5cIiwgXCJpbWdcIixcblx0XHRcdFwidHJheV9kaXNjb25uZWN0ZWQucG5nXCIpXG5cdH1cblxuXHRpZiAoc3RhdGUpIHtcblx0XHRyZXR1cm4gY29ublRyYXlcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gZGlzY29ublRyYXlcblx0fVxufVxuXG5lbGVjdHJvbi5hcHAub24oXCJ3aW5kb3ctYWxsLWNsb3NlZFwiLCAoKTogdm9pZCA9PiB7XG5cdHRyeSB7XG5cdFx0Q29uZmlnLmxvYWQoKS50aGVuKGFzeW5jICgpOiBQcm9taXNlPHZvaWQ+ID0+IHtcblx0XHRcdGlmICh3aW5kb3dTaXplICYmIHdpbmRvd1NpemUubGVuZ3RoID09IDIpIHtcblx0XHRcdFx0Q29uZmlnLndpbmRvd193aWR0aCA9IHdpbmRvd1NpemVbMF1cblx0XHRcdFx0Q29uZmlnLndpbmRvd19oZWlnaHQgPSB3aW5kb3dTaXplWzFdXG5cdFx0XHRcdGF3YWl0IENvbmZpZy5zYXZlKHtcblx0XHRcdFx0XHR3aW5kb3dfd2lkdGg6IENvbmZpZy53aW5kb3dfd2lkdGgsXG5cdFx0XHRcdFx0d2luZG93X2hlaWdodDogQ29uZmlnLndpbmRvd19oZWlnaHQsXG5cdFx0XHRcdH0pXG5cdFx0XHR9XG5cblx0XHRcdGlmIChDb25maWcuZGlzYWJsZV90cmF5X2ljb24gfHwgIXRyYXkpIHtcblx0XHRcdFx0ZWxlY3Ryb24uYXBwLnF1aXQoKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKGVsZWN0cm9uLmFwcC5kb2NrKSB7XG5cdFx0XHRcdFx0ZWxlY3Ryb24uYXBwLmRvY2suaGlkZSgpXG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHRocm93IGVycm9yXG5cdH1cbn0pXG5cbmVsZWN0cm9uLmFwcC5vbihcIm9wZW4tZmlsZVwiLCAoKTogdm9pZCA9PiB7XG5cdHRyeSB7XG5cdFx0bGV0IG1haW4gPSBuZXcgTWFpbigpXG5cdFx0bWFpbi5ydW4oKVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHRocm93IGVycm9yXG5cdH1cbn0pXG5cbmVsZWN0cm9uLmFwcC5vbihcIm9wZW4tdXJsXCIsICgpOiB2b2lkID0+IHtcblx0dHJ5IHtcblx0XHRsZXQgbWFpbiA9IG5ldyBNYWluKClcblx0XHRtYWluLnJ1bigpXG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0dGhyb3cgZXJyb3Jcblx0fVxufSlcblxuZWxlY3Ryb24uYXBwLm9uKFwiYWN0aXZhdGVcIiwgKCk6IHZvaWQgPT4ge1xuXHR0cnkge1xuXHRcdGxldCBtYWluID0gbmV3IE1haW4oKVxuXHRcdG1haW4ucnVuKClcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHR0aHJvdyBlcnJvclxuXHR9XG59KVxuXG5lbGVjdHJvbi5hcHAub24oXCJxdWl0XCIsICgpOiB2b2lkID0+IHtcblx0U2VydmljZS5jbGVhbnVwKClcblx0dHJ5IHtcblx0XHRlbGVjdHJvbi5hcHAucXVpdCgpXG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0dGhyb3cgZXJyb3Jcblx0fVxufSlcblxuZWxlY3Ryb24uYXBwLm9uKFwicmVhZHlcIiwgKCk6IHZvaWQgPT4ge1xuXHRsZXQgcHJvZmlsZXNQdGggPSBwYXRoLmpvaW4oZWxlY3Ryb24uYXBwLmdldFBhdGgoXCJ1c2VyRGF0YVwiKSwgXCJwcm9maWxlc1wiKVxuXHRcdGZzLmV4aXN0cyhwcm9maWxlc1B0aCwgZnVuY3Rpb24oZXhpc3RzKSB7XG5cdFx0aWYgKCFleGlzdHMpIHtcblx0XHRcdGZzLm1rZGlyKHByb2ZpbGVzUHRoLCBmdW5jdGlvbigpIHt9KVxuXHRcdH1cblx0fSlcblxuXHR0cnkge1xuXHRcdGlmIChyZWFkeUVycm9yKSB7XG5cdFx0XHRlbGVjdHJvbi5kaWFsb2cuc2hvd01lc3NhZ2VCb3gobnVsbCwge1xuXHRcdFx0XHR0eXBlOiBcImVycm9yXCIsXG5cdFx0XHRcdGJ1dHRvbnM6IFtcIkV4aXRcIl0sXG5cdFx0XHRcdHRpdGxlOiBcIlByaXR1bmwgQ2xpZW50IC0gUHJvY2VzcyBFcnJvclwiLFxuXHRcdFx0XHRtZXNzYWdlOiBcIkVycm9yIG9jY3VyZWQgaW4gbWFpbiBwcm9jZXNzOlxcblxcblwiICsgcmVhZHlFcnJvcixcblx0XHRcdH0pLnRoZW4oZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGVsZWN0cm9uLmFwcC5xdWl0KClcblx0XHRcdH0pXG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cblx0XHRyZWFkeSA9IHRydWVcblx0XHRpbml0KClcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHR0aHJvdyBlcnJvclxuXHR9XG59KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./main/Main.js\n");

/***/ }),

/***/ "./main/Request.js":
/*!*************************!*\
  !*** ./main/Request.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DefaultTimeout: () => (/* binding */ DefaultTimeout),\n/* harmony export */   Request: () => (/* binding */ Request),\n/* harmony export */   Response: () => (/* binding */ Response)\n/* harmony export */ });\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! http */ \"http\");\n/* harmony import */ var http__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(http__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! https */ \"https\");\n/* harmony import */ var https__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(https__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Logger */ \"./main/Logger.js\");\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors */ \"./main/Errors.js\");\n\n\n\n\nvar DefaultTimeout = 20;\nclass Response {\n    constructor(res) {\n        this.response = res;\n        this.status = res.statusCode;\n        this.message = res.statusMessage;\n    }\n    get(key) {\n        if (this.headers) {\n            return this.headers.get(key);\n        }\n        let curKey = null;\n        let headers = new Map();\n        for (let item of this.response.rawHeaders) {\n            if (curKey) {\n                headers.set(curKey, item);\n                curKey = null;\n            }\n            else {\n                curKey = item;\n            }\n        }\n        this.headers = headers;\n        return this.headers.get(key);\n    }\n    json() {\n        return JSON.parse(this.data || null);\n    }\n    jsonPassive() {\n        try {\n            return JSON.parse(this.data || null);\n        }\n        catch {\n            return null;\n        }\n    }\n    string() {\n        return this.data;\n    }\n}\nclass Request {\n    constructor() {\n        this.headers = new Map();\n    }\n    tcp(host) {\n        let hosts = host.split(\"://\");\n        this.ssl = hosts[0] === \"https\";\n        hosts = hosts[1].split(\":\");\n        if (hosts.length > 1) {\n            this.port = parseInt(hosts.pop(), 10);\n        }\n        else {\n            this.port = 80;\n        }\n        this.hostname = hosts.join(\":\");\n        return this;\n    }\n    unix(path) {\n        this.socketPath = path;\n        return this;\n    }\n    timeout(timeout) {\n        this.ttl = timeout * 1000;\n    }\n    get(path) {\n        this.method = \"GET\";\n        this.path = path;\n        return this;\n    }\n    put(path) {\n        this.method = \"PUT\";\n        this.path = path;\n        return this;\n    }\n    post(path) {\n        this.method = \"POST\";\n        this.path = path;\n        return this;\n    }\n    delete(path) {\n        this.method = \"DELETE\";\n        this.path = path;\n        return this;\n    }\n    set(key, value) {\n        this.headers.set(key, value);\n        return this;\n    }\n    send(data) {\n        if (typeof data === \"string\") {\n            this.data = data;\n        }\n        else {\n            this.headers.set(\"Content-Type\", \"application/json\");\n            this.data = JSON.stringify(data);\n        }\n        return this;\n    }\n    parseError(wrapErr, msg) {\n        let data = {};\n        if (this.ssl !== undefined) {\n            data.ssl = this.ssl;\n        }\n        if (this.hostname) {\n            data.hostname = this.hostname;\n        }\n        if (this.port) {\n            data.port = this.port;\n        }\n        if (this.method) {\n            data.method = this.method;\n        }\n        if (this.path) {\n            data.path = this.path;\n        }\n        if (this.ttl !== undefined) {\n            data.ttl = this.ttl;\n        }\n        return new _Errors__WEBPACK_IMPORTED_MODULE_3__.RequestError(wrapErr, msg, data);\n    }\n    end() {\n        return new Promise((resolve, reject) => {\n            try {\n                let options = {\n                    path: this.path,\n                    method: this.method,\n                    headers: Object.fromEntries(this.headers)\n                };\n                if (this.socketPath) {\n                    options.socketPath = this.socketPath;\n                }\n                else {\n                    options.hostname = this.hostname;\n                    options.port = this.port;\n                }\n                options.timeout = this.ttl || (DefaultTimeout * 1000);\n                let callback = (nodeResp) => {\n                    let resp = new Response(nodeResp);\n                    nodeResp.on(\"data\", (data) => {\n                        if (data) {\n                            resp.data = data.toString();\n                        }\n                    });\n                    nodeResp.on(\"end\", () => {\n                        resolve(resp);\n                    });\n                };\n                let req;\n                if (this.ssl) {\n                    req = https__WEBPACK_IMPORTED_MODULE_1___default().request(options, callback);\n                }\n                else {\n                    req = http__WEBPACK_IMPORTED_MODULE_0___default().request(options, callback);\n                }\n                req.on(\"timeout\", () => {\n                    let err = this.parseError(null, \"Request: Timeout error\");\n                    req.destroy(err);\n                    _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n                    reject(err);\n                });\n                req.on(\"error\", (err) => {\n                    err = this.parseError(err, \"Request:  Client error\");\n                    _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n                    reject(err);\n                });\n                if (this.data) {\n                    req.write(this.data);\n                }\n                req.end();\n            }\n            catch (err) {\n                err = this.parseError(err, \"Request: Exception\");\n                _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n                reject(err);\n            }\n        });\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUMsVUFBVSxDQUFDLEdBQUcsRUFBRSx3QkFBd0IsQ0FBQztvQkFDcEQsMENBQVksQ0FBQyxHQUFHLENBQUM7b0JBQ2pCLE1BQU0sQ0FBQyxHQUFHLENBQUM7Z0JBQ1osQ0FBQyxDQUFDO2dCQUVGLElBQUksSUFBSSxDQUFDLElBQUksRUFBRSxDQUFDO29CQUNmLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQztnQkFDckIsQ0FBQztnQkFFRCxHQUFHLENBQUMsR0FBRyxFQUFFO1lBQ1YsQ0FBQztZQUFDLE9BQU8sR0FBRyxFQUFFLENBQUM7Z0JBQ2QsR0FBRyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsR0FBRyxFQUFFLG9CQUFvQixDQUFDO2dCQUNoRCwwQ0FBWSxDQUFDLEdBQUcsQ0FBQztnQkFDakIsTUFBTSxDQUFDLEdBQUcsQ0FBQztZQUNaLENBQUM7UUFDRixDQUFDLENBQUM7SUFDSCxDQUFDO0NBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbWFpbi9SZXF1ZXN0LnRzPzFjY2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGh0dHAgZnJvbSBcImh0dHBcIlxuaW1wb3J0IGh0dHBzIGZyb20gXCJodHRwc1wiXG5pbXBvcnQgKiBhcyBMb2dnZXIgZnJvbSBcIi4vTG9nZ2VyXCJcbmltcG9ydCAqIGFzIEVycm9ycyBmcm9tIFwiLi9FcnJvcnNcIlxuXG5leHBvcnQgdmFyIERlZmF1bHRUaW1lb3V0ID0gMjBcblxuZXhwb3J0IGNsYXNzIFJlc3BvbnNlIHtcblx0cmVzcG9uc2U6IGh0dHAuSW5jb21pbmdNZXNzYWdlXG5cdGhlYWRlcnM6IE1hcDxzdHJpbmcsIHN0cmluZz5cblx0c3RhdHVzOiBudW1iZXJcblx0bWVzc2FnZTogc3RyaW5nXG5cdGRhdGE6IHN0cmluZ1xuXG5cdGNvbnN0cnVjdG9yKHJlczogaHR0cC5JbmNvbWluZ01lc3NhZ2UpIHtcblx0XHR0aGlzLnJlc3BvbnNlID0gcmVzXG5cdFx0dGhpcy5zdGF0dXMgPSByZXMuc3RhdHVzQ29kZVxuXHRcdHRoaXMubWVzc2FnZSA9IHJlcy5zdGF0dXNNZXNzYWdlXG5cdH1cblxuXHRnZXQoa2V5OiBzdHJpbmcpOiBzdHJpbmcge1xuXHRcdGlmICh0aGlzLmhlYWRlcnMpIHtcblx0XHRcdHJldHVybiB0aGlzLmhlYWRlcnMuZ2V0KGtleSlcblx0XHR9XG5cblx0XHRsZXQgY3VyS2V5OiBzdHJpbmcgPSBudWxsXG5cdFx0bGV0IGhlYWRlcnMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG5cblx0XHRmb3IgKGxldCBpdGVtIG9mIHRoaXMucmVzcG9uc2UucmF3SGVhZGVycykge1xuXHRcdFx0aWYgKGN1cktleSkge1xuXHRcdFx0XHRoZWFkZXJzLnNldChjdXJLZXksIGl0ZW0pXG5cdFx0XHRcdGN1cktleSA9IG51bGxcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN1cktleSA9IGl0ZW1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzXG5cblx0XHRyZXR1cm4gdGhpcy5oZWFkZXJzLmdldChrZXkpXG5cdH1cblxuXHRqc29uKCk6IG9iamVjdCB7XG5cdFx0cmV0dXJuIEpTT04ucGFyc2UodGhpcy5kYXRhIHx8IG51bGwpXG5cdH1cblxuXHRqc29uUGFzc2l2ZSgpOiBvYmplY3Qge1xuXHRcdHRyeSB7XG5cdFx0XHRyZXR1cm4gSlNPTi5wYXJzZSh0aGlzLmRhdGEgfHwgbnVsbClcblx0XHR9IGNhdGNoIHtcblx0XHRcdHJldHVybiBudWxsXG5cdFx0fVxuXHR9XG5cblx0c3RyaW5nKCk6IHN0cmluZyB7XG5cdFx0cmV0dXJuIHRoaXMuZGF0YVxuXHR9XG59XG5cbmV4cG9ydCBjbGFzcyBSZXF1ZXN0IHtcblx0c3NsOiBib29sZWFuXG5cdGhvc3RuYW1lOiBzdHJpbmdcblx0cG9ydDogbnVtYmVyXG5cdHNvY2tldFBhdGg6IHN0cmluZ1xuXHR0dGw6IG51bWJlclxuXHRtZXRob2Q6IHN0cmluZ1xuXHRwYXRoOiBzdHJpbmdcblx0aGVhZGVyczogTWFwPHN0cmluZywgc3RyaW5nPlxuXHRkYXRhOiBzdHJpbmdcblxuXHRjb25zdHJ1Y3RvcigpIHtcblx0XHR0aGlzLmhlYWRlcnMgPSBuZXcgTWFwPHN0cmluZywgc3RyaW5nPigpXG5cdH1cblxuXHR0Y3AoaG9zdDogc3RyaW5nKTogUmVxdWVzdCB7XG5cdFx0bGV0IGhvc3RzID0gaG9zdC5zcGxpdChcIjovL1wiKVxuXG5cdFx0dGhpcy5zc2wgPSBob3N0c1swXSA9PT0gXCJodHRwc1wiXG5cblx0XHRob3N0cyA9IGhvc3RzWzFdLnNwbGl0KFwiOlwiKVxuXG5cdFx0aWYgKGhvc3RzLmxlbmd0aCA+IDEpIHtcblx0XHRcdHRoaXMucG9ydCA9IHBhcnNlSW50KGhvc3RzLnBvcCgpLCAxMClcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5wb3J0ID0gODBcblx0XHR9XG5cblx0XHR0aGlzLmhvc3RuYW1lID0gaG9zdHMuam9pbihcIjpcIilcblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHR1bml4KHBhdGg6IHN0cmluZyk6IFJlcXVlc3Qge1xuXHRcdHRoaXMuc29ja2V0UGF0aCA9IHBhdGhcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0dGltZW91dCh0aW1lb3V0OiBudW1iZXIpIHtcblx0XHR0aGlzLnR0bCA9IHRpbWVvdXQgKiAxMDAwXG5cdH1cblxuXHRnZXQocGF0aDogc3RyaW5nKTogUmVxdWVzdCB7XG5cdFx0dGhpcy5tZXRob2QgPSBcIkdFVFwiXG5cdFx0dGhpcy5wYXRoID0gcGF0aFxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRwdXQocGF0aDogc3RyaW5nKTogUmVxdWVzdCB7XG5cdFx0dGhpcy5tZXRob2QgPSBcIlBVVFwiXG5cdFx0dGhpcy5wYXRoID0gcGF0aFxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRwb3N0KHBhdGg6IHN0cmluZyk6IFJlcXVlc3Qge1xuXHRcdHRoaXMubWV0aG9kID0gXCJQT1NUXCJcblx0XHR0aGlzLnBhdGggPSBwYXRoXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdGRlbGV0ZShwYXRoOiBzdHJpbmcpOiBSZXF1ZXN0IHtcblx0XHR0aGlzLm1ldGhvZCA9IFwiREVMRVRFXCJcblx0XHR0aGlzLnBhdGggPSBwYXRoXG5cdFx0cmV0dXJuIHRoaXNcblx0fVxuXG5cdHNldChrZXk6IHN0cmluZywgdmFsdWU6IHN0cmluZyk6IFJlcXVlc3Qge1xuXHRcdHRoaXMuaGVhZGVycy5zZXQoa2V5LCB2YWx1ZSlcblx0XHRyZXR1cm4gdGhpc1xuXHR9XG5cblx0c2VuZChkYXRhOiBzdHJpbmd8b2JqZWN0KTogUmVxdWVzdCB7XG5cdFx0aWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG5cdFx0XHR0aGlzLmRhdGEgPSBkYXRhXG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuaGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpXG5cdFx0XHR0aGlzLmRhdGEgPSBKU09OLnN0cmluZ2lmeShkYXRhKVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzXG5cdH1cblxuXHRwYXJzZUVycm9yKHdyYXBFcnI6IEVycm9yLCBtc2c6IHN0cmluZyk6IEVycm9ycy5SZXF1ZXN0RXJyb3Ige1xuXHRcdGxldCBkYXRhOiB7W2tleTogc3RyaW5nXTogYW55fSA9IHt9XG5cblx0XHRpZiAodGhpcy5zc2wgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0ZGF0YS5zc2wgPSB0aGlzLnNzbFxuXHRcdH1cblx0XHRpZiAodGhpcy5ob3N0bmFtZSkge1xuXHRcdFx0ZGF0YS5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWVcblx0XHR9XG5cdFx0aWYgKHRoaXMucG9ydCkge1xuXHRcdFx0ZGF0YS5wb3J0ID0gdGhpcy5wb3J0XG5cdFx0fVxuXHRcdGlmICh0aGlzLm1ldGhvZCkge1xuXHRcdFx0ZGF0YS5tZXRob2QgPSB0aGlzLm1ldGhvZFxuXHRcdH1cblx0XHRpZiAodGhpcy5wYXRoKSB7XG5cdFx0XHRkYXRhLnBhdGggPSB0aGlzLnBhdGhcblx0XHR9XG5cdFx0aWYgKHRoaXMudHRsICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdGRhdGEudHRsID0gdGhpcy50dGxcblx0XHR9XG5cblx0XHRyZXR1cm4gbmV3IEVycm9ycy5SZXF1ZXN0RXJyb3IoXG5cdFx0XHR3cmFwRXJyLCBtc2csIGRhdGEpXG5cdH1cblxuXHRlbmQoKTogUHJvbWlzZTxSZXNwb25zZT4ge1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZTxSZXNwb25zZT4oKHJlc29sdmUsIHJlamVjdCk6IHZvaWQgPT4ge1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0bGV0IG9wdGlvbnM6IGh0dHAuUmVxdWVzdE9wdGlvbnMgPSB7XG5cdFx0XHRcdFx0cGF0aDogdGhpcy5wYXRoLFxuXHRcdFx0XHRcdG1ldGhvZDogdGhpcy5tZXRob2QsXG5cdFx0XHRcdFx0aGVhZGVyczogT2JqZWN0LmZyb21FbnRyaWVzKHRoaXMuaGVhZGVycylcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICh0aGlzLnNvY2tldFBhdGgpIHtcblx0XHRcdFx0XHRvcHRpb25zLnNvY2tldFBhdGggPSB0aGlzLnNvY2tldFBhdGhcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRvcHRpb25zLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVxuXHRcdFx0XHRcdG9wdGlvbnMucG9ydCA9IHRoaXMucG9ydFxuXHRcdFx0XHR9XG5cblx0XHRcdFx0b3B0aW9ucy50aW1lb3V0ID0gdGhpcy50dGwgfHwgKERlZmF1bHRUaW1lb3V0ICogMTAwMClcblxuXHRcdFx0XHRsZXQgY2FsbGJhY2sgPSAobm9kZVJlc3A6IGh0dHAuSW5jb21pbmdNZXNzYWdlKSA9PiB7XG5cdFx0XHRcdFx0bGV0IHJlc3AgPSBuZXcgUmVzcG9uc2Uobm9kZVJlc3ApXG5cblx0XHRcdFx0XHRub2RlUmVzcC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcblx0XHRcdFx0XHRcdGlmIChkYXRhKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3AuZGF0YSA9IGRhdGEudG9TdHJpbmcoKVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pXG5cblx0XHRcdFx0XHRub2RlUmVzcC5vbihcImVuZFwiLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRyZXNvbHZlKHJlc3ApXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCByZXE6IGh0dHAuQ2xpZW50UmVxdWVzdFxuXHRcdFx0XHRpZiAodGhpcy5zc2wpIHtcblx0XHRcdFx0XHRyZXEgPSBodHRwcy5yZXF1ZXN0KG9wdGlvbnMsIGNhbGxiYWNrKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJlcSA9IGh0dHAucmVxdWVzdChvcHRpb25zLCBjYWxsYmFjaylcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlcS5vbihcInRpbWVvdXRcIiwgKCkgPT4ge1xuXHRcdFx0XHRcdGxldCBlcnIgPSB0aGlzLnBhcnNlRXJyb3IobnVsbCwgXCJSZXF1ZXN0OiBUaW1lb3V0IGVycm9yXCIpXG5cdFx0XHRcdFx0cmVxLmRlc3Ryb3koZXJyKVxuXHRcdFx0XHRcdExvZ2dlci5lcnJvcihlcnIpXG5cdFx0XHRcdFx0cmVqZWN0KGVycilcblx0XHRcdFx0fSlcblxuXHRcdFx0XHRyZXEub24oXCJlcnJvclwiLCAoZXJyKSA9PiB7XG5cdFx0XHRcdFx0ZXJyID0gdGhpcy5wYXJzZUVycm9yKGVyciwgXCJSZXF1ZXN0OiAgQ2xpZW50IGVycm9yXCIpXG5cdFx0XHRcdFx0TG9nZ2VyLmVycm9yKGVycilcblx0XHRcdFx0XHRyZWplY3QoZXJyKVxuXHRcdFx0XHR9KVxuXG5cdFx0XHRcdGlmICh0aGlzLmRhdGEpIHtcblx0XHRcdFx0XHRyZXEud3JpdGUodGhpcy5kYXRhKVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVxLmVuZCgpXG5cdFx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdFx0ZXJyID0gdGhpcy5wYXJzZUVycm9yKGVyciwgXCJSZXF1ZXN0OiBFeGNlcHRpb25cIilcblx0XHRcdFx0TG9nZ2VyLmVycm9yKGVycilcblx0XHRcdFx0cmVqZWN0KGVycilcblx0XHRcdH1cblx0XHR9KVxuXHR9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./main/Request.js\n");

/***/ }),

/***/ "./main/RequestUtils.js":
/*!******************************!*\
  !*** ./main/RequestUtils.js ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   del: () => (/* binding */ del),\n/* harmony export */   get: () => (/* binding */ get),\n/* harmony export */   post: () => (/* binding */ post),\n/* harmony export */   put: () => (/* binding */ put)\n/* harmony export */ });\n/* harmony import */ var _Auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Auth */ \"./main/Auth.js\");\n/* harmony import */ var _Request__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Request */ \"./main/Request.js\");\n\n\nfunction get(path) {\n    let req = new _Request__WEBPACK_IMPORTED_MODULE_1__.Request();\n    if (_Auth__WEBPACK_IMPORTED_MODULE_0__.unix) {\n        req.unix(_Auth__WEBPACK_IMPORTED_MODULE_0__.unixPath);\n    }\n    else {\n        req.tcp(_Auth__WEBPACK_IMPORTED_MODULE_0__.webHost);\n    }\n    req.get(path)\n        .set(\"Auth-Token\", _Auth__WEBPACK_IMPORTED_MODULE_0__.token)\n        .set(\"User-Agent\", \"pritunl\");\n    return req;\n}\nfunction put(path) {\n    let req = new _Request__WEBPACK_IMPORTED_MODULE_1__.Request();\n    if (_Auth__WEBPACK_IMPORTED_MODULE_0__.unix) {\n        req.unix(_Auth__WEBPACK_IMPORTED_MODULE_0__.unixPath);\n    }\n    else {\n        req.tcp(_Auth__WEBPACK_IMPORTED_MODULE_0__.webHost);\n    }\n    req.put(path)\n        .set(\"Auth-Token\", _Auth__WEBPACK_IMPORTED_MODULE_0__.token)\n        .set(\"User-Agent\", \"pritunl\");\n    return req;\n}\nfunction post(path) {\n    let req = new _Request__WEBPACK_IMPORTED_MODULE_1__.Request();\n    if (_Auth__WEBPACK_IMPORTED_MODULE_0__.unix) {\n        req.unix(_Auth__WEBPACK_IMPORTED_MODULE_0__.unixPath);\n    }\n    else {\n        req.tcp(_Auth__WEBPACK_IMPORTED_MODULE_0__.webHost);\n    }\n    req.post(path)\n        .set(\"Auth-Token\", _Auth__WEBPACK_IMPORTED_MODULE_0__.token)\n        .set(\"User-Agent\", \"pritunl\");\n    return req;\n}\nfunction del(path) {\n    let req = new _Request__WEBPACK_IMPORTED_MODULE_1__.Request();\n    if (_Auth__WEBPACK_IMPORTED_MODULE_0__.unix) {\n        req.unix(_Auth__WEBPACK_IMPORTED_MODULE_0__.unixPath);\n    }\n    else {\n        req.tcp(_Auth__WEBPACK_IMPORTED_MODULE_0__.webHost);\n    }\n    req.delete(path)\n        .set(\"Auth-Token\", _Auth__WEBPACK_IMPORTED_MODULE_0__.token)\n        .set(\"User-Agent\", \"pritunl\");\n    return req;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWluL1JlcXVlc3RVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBK0I7QUFDSztBQUc3QixTQUFTLEdBQUcsQ0FBQyxJQUFZO0lBQy9CLElBQUksR0FBRyxHQUFHLElBQUksNkNBQWUsRUFBRTtJQUUvQixJQUFJLHVDQUFTLEVBQUUsQ0FBQztRQUNmLEdBQUcsQ0FBQyxJQUFJLENBQUMsMkNBQWEsQ0FBQztJQUN4QixDQUFDO1NBQU0sQ0FBQztRQUNQLEdBQUcsQ0FBQyxHQUFHLENBQUMsMENBQVksQ0FBQztJQUN0QixDQUFDO0lBRUQsR0FBRyxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUM7U0FDWCxHQUFHLENBQUMsWUFBWSxFQUFFLHdDQUFVLENBQUM7U0FDN0IsR0FBRyxDQUFDLFlBQVksRUFBRSxTQUFTLENBQUM7SUFFOUIsT0FBTyxHQUFHO0FBQ1gsQ0FBQztBQUVNLFNBQVMsR0FBRyxDQUFDLElBQVk7SUFDL0IsSUFBSSxHQUFHLEdBQUcsSUFBSSw2Q0FBZSxFQUFFO0lBRS9CLElBQUksdUNBQVMsRUFBRSxDQUFDO1FBQ2YsR0FBRyxDQUFDLElBQUksQ0FBQywyQ0FBYSxDQUFDO0lBQ3hCLENBQUM7U0FBTSxDQUFDO1FBQ1AsR0FBRyxDQUFDLEdBQUcsQ0FBQywwQ0FBWSxDQUFDO0lBQ3RCLENBQUM7SUFFRCxHQUFHLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztTQUNYLEdBQUcsQ0FBQyxZQUFZLEVBQUUsd0NBQVUsQ0FBQztTQUM3QixHQUFHLENBQUMsWUFBWSxFQUFFLFNBQVMsQ0FBQztJQUU5QixPQUFPLEdBQUc7QUFDWCxDQUFDO0FBRU0sU0FBUyxJQUFJLENBQUMsSUFBWTtJQUNoQyxJQUFJLEdBQUcsR0FBRyxJQUFJLDZDQUFlLEVBQUU7SUFFL0IsSUFBSSx1Q0FBUyxFQUFFLENBQUM7UUFDZixHQUFHLENBQUMsSUFBSSxDQUFDLDJDQUFhLENBQUM7SUFDeEIsQ0FBQztTQUFNLENBQUM7UUFDUCxHQUFHLENBQUMsR0FBRyxDQUFDLDBDQUFZLENBQUM7SUFDdEIsQ0FBQztJQUVELEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1NBQ1osR0FBRyxDQUFDLFlBQVksRUFBRSx3Q0FBVSxDQUFDO1NBQzdCLEdBQUcsQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDO0lBRTlCLE9BQU8sR0FBRztBQUNYLENBQUM7QUFFTSxTQUFTLEdBQUcsQ0FBQyxJQUFZO0lBQy9CLElBQUksR0FBRyxHQUFHLElBQUksNkNBQWUsRUFBRTtJQUUvQixJQUFJLHVDQUFTLEVBQUUsQ0FBQztRQUNmLEdBQUcsQ0FBQyxJQUFJLENBQUMsMkNBQWEsQ0FBQztJQUN4QixDQUFDO1NBQU0sQ0FBQztRQUNQLEdBQUcsQ0FBQyxHQUFHLENBQUMsMENBQVksQ0FBQztJQUN0QixDQUFDO0lBRUQsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUM7U0FDZCxHQUFHLENBQUMsWUFBWSxFQUFFLHdDQUFVLENBQUM7U0FDN0IsR0FBRyxDQUFDLFlBQVksRUFBRSxTQUFTLENBQUM7SUFFOUIsT0FBTyxHQUFHO0FBQ1gsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9tYWluL1JlcXVlc3RVdGlscy50cz9iZjU0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEF1dGggZnJvbSBcIi4vQXV0aFwiO1xuaW1wb3J0ICogYXMgUmVxdWVzdCBmcm9tIFwiLi9SZXF1ZXN0XCJcbmltcG9ydCBjcnlwdG8gZnJvbSBcImNyeXB0b1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KHBhdGg6IHN0cmluZyk6IFJlcXVlc3QuUmVxdWVzdCB7XG5cdGxldCByZXEgPSBuZXcgUmVxdWVzdC5SZXF1ZXN0KClcblxuXHRpZiAoQXV0aC51bml4KSB7XG5cdFx0cmVxLnVuaXgoQXV0aC51bml4UGF0aClcblx0fSBlbHNlIHtcblx0XHRyZXEudGNwKEF1dGgud2ViSG9zdClcblx0fVxuXG5cdHJlcS5nZXQocGF0aClcblx0XHQuc2V0KFwiQXV0aC1Ub2tlblwiLCBBdXRoLnRva2VuKVxuXHRcdC5zZXQoXCJVc2VyLUFnZW50XCIsIFwicHJpdHVubFwiKVxuXG5cdHJldHVybiByZXFcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHB1dChwYXRoOiBzdHJpbmcpOiBSZXF1ZXN0LlJlcXVlc3Qge1xuXHRsZXQgcmVxID0gbmV3IFJlcXVlc3QuUmVxdWVzdCgpXG5cblx0aWYgKEF1dGgudW5peCkge1xuXHRcdHJlcS51bml4KEF1dGgudW5peFBhdGgpXG5cdH0gZWxzZSB7XG5cdFx0cmVxLnRjcChBdXRoLndlYkhvc3QpXG5cdH1cblxuXHRyZXEucHV0KHBhdGgpXG5cdFx0LnNldChcIkF1dGgtVG9rZW5cIiwgQXV0aC50b2tlbilcblx0XHQuc2V0KFwiVXNlci1BZ2VudFwiLCBcInByaXR1bmxcIilcblxuXHRyZXR1cm4gcmVxXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3N0KHBhdGg6IHN0cmluZyk6IFJlcXVlc3QuUmVxdWVzdCB7XG5cdGxldCByZXEgPSBuZXcgUmVxdWVzdC5SZXF1ZXN0KClcblxuXHRpZiAoQXV0aC51bml4KSB7XG5cdFx0cmVxLnVuaXgoQXV0aC51bml4UGF0aClcblx0fSBlbHNlIHtcblx0XHRyZXEudGNwKEF1dGgud2ViSG9zdClcblx0fVxuXG5cdHJlcS5wb3N0KHBhdGgpXG5cdFx0LnNldChcIkF1dGgtVG9rZW5cIiwgQXV0aC50b2tlbilcblx0XHQuc2V0KFwiVXNlci1BZ2VudFwiLCBcInByaXR1bmxcIilcblxuXHRyZXR1cm4gcmVxXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWwocGF0aDogc3RyaW5nKTogUmVxdWVzdC5SZXF1ZXN0IHtcblx0bGV0IHJlcSA9IG5ldyBSZXF1ZXN0LlJlcXVlc3QoKVxuXG5cdGlmIChBdXRoLnVuaXgpIHtcblx0XHRyZXEudW5peChBdXRoLnVuaXhQYXRoKVxuXHR9IGVsc2Uge1xuXHRcdHJlcS50Y3AoQXV0aC53ZWJIb3N0KVxuXHR9XG5cblx0cmVxLmRlbGV0ZShwYXRoKVxuXHRcdC5zZXQoXCJBdXRoLVRva2VuXCIsIEF1dGgudG9rZW4pXG5cdFx0LnNldChcIlVzZXItQWdlbnRcIiwgXCJwcml0dW5sXCIpXG5cblx0cmV0dXJuIHJlcVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./main/RequestUtils.js\n");

/***/ }),

/***/ "./main/Service.js":
/*!*************************!*\
  !*** ./main/Service.js ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   cleanup: () => (/* binding */ cleanup),\n/* harmony export */   connect: () => (/* binding */ connect),\n/* harmony export */   send: () => (/* binding */ send),\n/* harmony export */   subscribe: () => (/* binding */ subscribe),\n/* harmony export */   sync: () => (/* binding */ sync),\n/* harmony export */   wakeup: () => (/* binding */ wakeup),\n/* harmony export */   winDrive: () => (/* binding */ winDrive)\n/* harmony export */ });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"./node_modules/ws/wrapper.mjs\");\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! process */ \"process\");\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _RequestUtils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./RequestUtils */ \"./main/RequestUtils.js\");\n/* harmony import */ var _Auth__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Auth */ \"./main/Auth.js\");\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./Logger */ \"./main/Logger.js\");\n/* harmony import */ var _Constants__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Constants */ \"./main/Constants.js\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_6__);\n/* harmony import */ var _app_utils_MiscUtils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../app/utils/MiscUtils */ \"./app/utils/MiscUtils.js\");\n\n\n\n\n\n\n\n\nlet showConnect = false;\nlet socket;\nlet callbacks = [];\nlet winDrive = 'C:\\\\';\nlet systemDrv = (process__WEBPACK_IMPORTED_MODULE_1___default().env).SYSTEMDRIVE;\nif (systemDrv) {\n    winDrive = systemDrv + '\\\\';\n}\nfunction sync() {\n    return new Promise(async (resolve) => {\n        try {\n            await _Auth__WEBPACK_IMPORTED_MODULE_3__.load();\n        }\n        catch (err) {\n            _Logger__WEBPACK_IMPORTED_MODULE_4__.error(err);\n            resolve(false);\n            return;\n        }\n        _RequestUtils__WEBPACK_IMPORTED_MODULE_2__.get(\"/status\")\n            .set(\"Auth-Token\", _Auth__WEBPACK_IMPORTED_MODULE_3__.token)\n            .set(\"User-Agent\", \"pritunl\")\n            .end()\n            .then((resp) => {\n            if (resp.status === 200) {\n                let data = resp.jsonPassive();\n                if (data) {\n                    resolve(data.status);\n                }\n                else {\n                    resolve(false);\n                }\n            }\n            else {\n                resolve(false);\n            }\n        }, (err) => {\n            _Logger__WEBPACK_IMPORTED_MODULE_4__.error(err);\n            resolve(false);\n        });\n    });\n}\nfunction wakeup() {\n    return new Promise(async (resolve) => {\n        try {\n            await _Auth__WEBPACK_IMPORTED_MODULE_3__.load();\n        }\n        catch (err) {\n            _Logger__WEBPACK_IMPORTED_MODULE_4__.error(err);\n            resolve(false);\n            return;\n        }\n        _RequestUtils__WEBPACK_IMPORTED_MODULE_2__.post(\"/wakeup\")\n            .set(\"Auth-Token\", _Auth__WEBPACK_IMPORTED_MODULE_3__.token)\n            .set(\"User-Agent\", \"pritunl\")\n            .end()\n            .then((resp) => {\n            if (resp.status === 200) {\n                resolve(true);\n            }\n            else {\n                resolve(false);\n            }\n        }, (err) => {\n            _Logger__WEBPACK_IMPORTED_MODULE_4__.error(err);\n            resolve(false);\n        });\n    });\n}\nfunction cleanup() {\n    return new Promise(async (resolve) => {\n        try {\n            await _Auth__WEBPACK_IMPORTED_MODULE_3__.load();\n        }\n        catch (err) {\n            _Logger__WEBPACK_IMPORTED_MODULE_4__.error(err);\n            resolve(false);\n            return;\n        }\n        _RequestUtils__WEBPACK_IMPORTED_MODULE_2__.post(\"/cleanup\")\n            .set(\"Auth-Token\", _Auth__WEBPACK_IMPORTED_MODULE_3__.token)\n            .set(\"User-Agent\", \"pritunl\")\n            .end()\n            .then((resp) => {\n            if (resp.status === 200) {\n                resolve(true);\n            }\n            else {\n                resolve(false);\n            }\n        }, (err) => {\n            _Logger__WEBPACK_IMPORTED_MODULE_4__.error(err);\n            resolve(false);\n        });\n    });\n}\nlet authAttempts = 0;\nlet connAttempts = 0;\nlet dialogShown = false;\nlet curSocket = \"\";\nfunction connect() {\n    let socketId = _app_utils_MiscUtils__WEBPACK_IMPORTED_MODULE_7__.uuid();\n    curSocket = socketId;\n    return new Promise(async (resolve, reject) => {\n        try {\n            await _Auth__WEBPACK_IMPORTED_MODULE_3__.load();\n        }\n        catch (err) {\n        }\n        if (!_Auth__WEBPACK_IMPORTED_MODULE_3__.token) {\n            if (authAttempts > 20) {\n                if (!dialogShown) {\n                    dialogShown = true;\n                    electron__WEBPACK_IMPORTED_MODULE_6___default().dialog.showMessageBox(null, {\n                        type: \"error\",\n                        buttons: [\"Retry\", \"Exit\"],\n                        title: \"Pritunl - Service Error (6729\",\n                        message: \"Unable to authenticate communication with \" +\n                            \"background service, try restarting computer\",\n                    }).then(function (evt) {\n                        if (evt.response == 0) {\n                            authAttempts = 0;\n                            connAttempts = 0;\n                            dialogShown = false;\n                            connect();\n                        }\n                        else {\n                            electron__WEBPACK_IMPORTED_MODULE_6___default().app.quit();\n                        }\n                    });\n                }\n            }\n            else {\n                authAttempts += 1;\n                setTimeout(() => {\n                    connect();\n                }, 500);\n            }\n            return;\n        }\n        resolve();\n        let reconnected = false;\n        let wsHost = \"\";\n        let headers = {\n            \"User-Agent\": \"pritunl\",\n            \"Auth-Token\": _Auth__WEBPACK_IMPORTED_MODULE_3__.token,\n        };\n        if (_Constants__WEBPACK_IMPORTED_MODULE_5__.unix) {\n            wsHost = _Constants__WEBPACK_IMPORTED_MODULE_5__.unixWsHost;\n            headers[\"Host\"] = \"unix\";\n        }\n        else {\n            wsHost = _Constants__WEBPACK_IMPORTED_MODULE_5__.webWsHost;\n        }\n        let reconnect = () => {\n            setTimeout(() => {\n                if (reconnected) {\n                    return;\n                }\n                reconnected = true;\n                if (connAttempts > 30) {\n                    if (!dialogShown) {\n                        dialogShown = true;\n                        electron__WEBPACK_IMPORTED_MODULE_6___default().dialog.showMessageBox(null, {\n                            type: \"error\",\n                            buttons: [\"Retry\", \"Exit\"],\n                            title: \"Pritunl - Service Error (8362)\",\n                            message: \"Unable to establish communication with \" +\n                                \"background service, try restarting computer\",\n                        }).then(function (evt) {\n                            if (evt.response == 0) {\n                                authAttempts = 0;\n                                connAttempts = 0;\n                                dialogShown = false;\n                                connect();\n                            }\n                            else {\n                                electron__WEBPACK_IMPORTED_MODULE_6___default().app.quit();\n                            }\n                        });\n                    }\n                }\n                else {\n                    connAttempts += 1;\n                }\n                connect();\n            }, 1000);\n        };\n        socket = new ws__WEBPACK_IMPORTED_MODULE_0__[\"default\"](wsHost + \"/events\", {\n            headers: headers,\n        });\n        socket.on(\"open\", () => {\n            if (socketId !== curSocket) {\n                return;\n            }\n            connAttempts = 0;\n            if (showConnect) {\n                showConnect = false;\n                console.log(\"Events: Service reconnected\");\n                if (_Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow && !_Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow.isDestroyed()) {\n                    _Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow.webContents.send(\"event.reconnected\");\n                }\n            }\n        });\n        socket.on(\"error\", (err) => {\n            if (socketId !== curSocket) {\n                return;\n            }\n            if (_Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow && !_Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow.isDestroyed()) {\n                _Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow.webContents.send(\"event.error\", err.toString());\n            }\n            console.error(\"Events: Socket error \" + err);\n            showConnect = true;\n            reconnect();\n        });\n        socket.on(\"onerror\", (err) => {\n            if (socketId !== curSocket) {\n                return;\n            }\n            console.error(\"Events: Socket error \" + err);\n            showConnect = true;\n            reconnect();\n        });\n        socket.on(\"close\", () => {\n            if (socketId !== curSocket) {\n                return;\n            }\n            if (_Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow && !_Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow.isDestroyed()) {\n                _Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow.webContents.send(\"event.closed\");\n            }\n            showConnect = true;\n            reconnect();\n        });\n        socket.on(\"message\", (dataBuf) => {\n            if (socketId !== curSocket) {\n                return;\n            }\n            let dataStr = dataBuf.toString();\n            if (_Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow && !_Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow.isDestroyed()) {\n                _Constants__WEBPACK_IMPORTED_MODULE_5__.mainWindow.webContents.send(\"event\", dataStr);\n            }\n            let data = JSON.parse(dataStr);\n            for (let callback of callbacks) {\n                callback(data);\n            }\n        });\n    });\n}\nfunction send(msg) {\n    if (socket) {\n        socket.send(msg);\n    }\n}\nfunction subscribe(callback) {\n    callbacks.push(callback);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXZWJTb2NrZXQgZnJvbSBcIndzXCJcbmltcG9ydCBwcm9jZXNzIGZyb20gXCJwcm9jZXNzXCJcbmltcG9ydCAqIGFzIFJlcXVlc3QgZnJvbSBcIi4vUmVxdWVzdFwiXG5pbXBvcnQgKiBhcyBSZXF1ZXN0VXRpbHMgZnJvbSAnLi9SZXF1ZXN0VXRpbHMnO1xuaW1wb3J0ICogYXMgQXV0aCBmcm9tIFwiLi9BdXRoXCJcbmltcG9ydCAqIGFzIExvZ2dlciBmcm9tIFwiLi9Mb2dnZXJcIlxuaW1wb3J0ICogYXMgQ29uc3RhbnRzIGZyb20gXCIuL0NvbnN0YW50c1wiXG5pbXBvcnQgZWxlY3Ryb24gZnJvbSBcImVsZWN0cm9uXCI7XG5pbXBvcnQgKiBhcyBNaXNjVXRpbHMgZnJvbSBcIi4uL2FwcC91dGlscy9NaXNjVXRpbHNcIjtcblxuZXhwb3J0IGludGVyZmFjZSBFdmVudCB7XG5cdGlkOiBzdHJpbmdcblx0dHlwZTogc3RyaW5nXG5cdGRhdGE/OiBhbnlcbn1cblxuZXhwb3J0IHR5cGUgQ2FsbGJhY2sgPSAoZXZlbnQ6IEV2ZW50KSA9PiB2b2lkXG5cbmxldCBzaG93Q29ubmVjdCA9IGZhbHNlXG5sZXQgc29ja2V0OiBXZWJTb2NrZXQuV2ViU29ja2V0XG5sZXQgY2FsbGJhY2tzOiBDYWxsYmFja1tdID0gW11cblxuZXhwb3J0IGxldCB3aW5Ecml2ZSA9ICdDOlxcXFwnO1xubGV0IHN5c3RlbURydiA9IHByb2Nlc3MuZW52LlNZU1RFTURSSVZFO1xuaWYgKHN5c3RlbURydikge1xuXHR3aW5Ecml2ZSA9IHN5c3RlbURydiArICdcXFxcJztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN5bmMoKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPihhc3luYyAocmVzb2x2ZSkgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBBdXRoLmxvYWQoKVxuXHRcdH0gY2F0Y2goZXJyKSB7XG5cdFx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXHRcdFx0cmVzb2x2ZShmYWxzZSlcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdFJlcXVlc3RVdGlsc1xuXHRcdFx0LmdldChcIi9zdGF0dXNcIilcblx0XHRcdC5zZXQoXCJBdXRoLVRva2VuXCIsIEF1dGgudG9rZW4pXG5cdFx0XHQuc2V0KFwiVXNlci1BZ2VudFwiLCBcInByaXR1bmxcIilcblx0XHRcdC5lbmQoKVxuXHRcdFx0LnRoZW4oKHJlc3A6IFJlcXVlc3QuUmVzcG9uc2UpID0+IHtcblx0XHRcdFx0aWYgKHJlc3Auc3RhdHVzID09PSAyMDApIHtcblx0XHRcdFx0XHRsZXQgZGF0YSA9IHJlc3AuanNvblBhc3NpdmUoKSBhcyBhbnlcblx0XHRcdFx0XHRpZiAoZGF0YSkge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShkYXRhLnN0YXR1cylcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzb2x2ZShmYWxzZSlcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShmYWxzZSlcblx0XHRcdFx0fVxuXHRcdFx0fSwgKGVycikgPT4ge1xuXHRcdFx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXHRcdFx0XHRyZXNvbHZlKGZhbHNlKVxuXHRcdFx0fSlcblx0fSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHdha2V1cCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcblx0cmV0dXJuIG5ldyBQcm9taXNlPGJvb2xlYW4+KGFzeW5jIChyZXNvbHZlKSA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IEF1dGgubG9hZCgpXG5cdFx0fSBjYXRjaChlcnIpIHtcblx0XHRcdExvZ2dlci5lcnJvcihlcnIpXG5cdFx0XHRyZXNvbHZlKGZhbHNlKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0UmVxdWVzdFV0aWxzXG5cdFx0XHQucG9zdChcIi93YWtldXBcIilcblx0XHRcdC5zZXQoXCJBdXRoLVRva2VuXCIsIEF1dGgudG9rZW4pXG5cdFx0XHQuc2V0KFwiVXNlci1BZ2VudFwiLCBcInByaXR1bmxcIilcblx0XHRcdC5lbmQoKVxuXHRcdFx0LnRoZW4oKHJlc3A6IFJlcXVlc3QuUmVzcG9uc2UpID0+IHtcblx0XHRcdFx0aWYgKHJlc3Auc3RhdHVzID09PSAyMDApIHtcblx0XHRcdFx0XHRyZXNvbHZlKHRydWUpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmVzb2x2ZShmYWxzZSlcblx0XHRcdFx0fVxuXHRcdFx0fSwgKGVycikgPT4ge1xuXHRcdFx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXHRcdFx0XHRyZXNvbHZlKGZhbHNlKVxuXHRcdFx0fSlcblx0fSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsZWFudXAoKTogUHJvbWlzZTxib29sZWFuPiB7XG5cdHJldHVybiBuZXcgUHJvbWlzZTxib29sZWFuPihhc3luYyAocmVzb2x2ZSkgPT4ge1xuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCBBdXRoLmxvYWQoKVxuXHRcdH0gY2F0Y2goZXJyKSB7XG5cdFx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXHRcdFx0cmVzb2x2ZShmYWxzZSlcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdFJlcXVlc3RVdGlsc1xuXHRcdFx0LnBvc3QoXCIvY2xlYW51cFwiKVxuXHRcdFx0LnNldChcIkF1dGgtVG9rZW5cIiwgQXV0aC50b2tlbilcblx0XHRcdC5zZXQoXCJVc2VyLUFnZW50XCIsIFwicHJpdHVubFwiKVxuXHRcdFx0LmVuZCgpXG5cdFx0XHQudGhlbigocmVzcDogUmVxdWVzdC5SZXNwb25zZSkgPT4ge1xuXHRcdFx0XHRpZiAocmVzcC5zdGF0dXMgPT09IDIwMCkge1xuXHRcdFx0XHRcdHJlc29sdmUodHJ1ZSlcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXNvbHZlKGZhbHNlKVxuXHRcdFx0XHR9XG5cdFx0XHR9LCAoZXJyKSA9PiB7XG5cdFx0XHRcdExvZ2dlci5lcnJvcihlcnIpXG5cdFx0XHRcdHJlc29sdmUoZmFsc2UpXG5cdFx0XHR9KVxuXHR9KVxufVxuXG5sZXQgYXV0aEF0dGVtcHRzID0gMFxubGV0IGNvbm5BdHRlbXB0cyA9IDBcbmxldCBkaWFsb2dTaG93biA9IGZhbHNlXG5sZXQgY3VyU29ja2V0ID0gXCJcIlxuXG5leHBvcnQgZnVuY3Rpb24gY29ubmVjdCgpOiBQcm9taXNlPHZvaWQ+IHtcblx0bGV0IHNvY2tldElkID0gTWlzY1V0aWxzLnV1aWQoKVxuXHRjdXJTb2NrZXQgPSBzb2NrZXRJZFxuXG5cdHJldHVybiBuZXcgUHJvbWlzZTx2b2lkPihhc3luYyAocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IEF1dGgubG9hZCgpXG5cdFx0fSBjYXRjaChlcnIpIHtcblx0XHR9XG5cblx0XHRpZiAoIUF1dGgudG9rZW4pIHtcblx0XHRcdGlmIChhdXRoQXR0ZW1wdHMgPiAyMCkge1xuXHRcdFx0XHRpZiAoIWRpYWxvZ1Nob3duKSB7XG5cdFx0XHRcdFx0ZGlhbG9nU2hvd24gPSB0cnVlXG5cdFx0XHRcdFx0ZWxlY3Ryb24uZGlhbG9nLnNob3dNZXNzYWdlQm94KG51bGwsIHtcblx0XHRcdFx0XHRcdHR5cGU6IFwiZXJyb3JcIixcblx0XHRcdFx0XHRcdGJ1dHRvbnM6IFtcIlJldHJ5XCIsIFwiRXhpdFwiXSxcblx0XHRcdFx0XHRcdHRpdGxlOiBcIlByaXR1bmwgLSBTZXJ2aWNlIEVycm9yICg2NzI5XCIsXG5cdFx0XHRcdFx0XHRtZXNzYWdlOiBcIlVuYWJsZSB0byBhdXRoZW50aWNhdGUgY29tbXVuaWNhdGlvbiB3aXRoIFwiICtcblx0XHRcdFx0XHRcdFx0XCJiYWNrZ3JvdW5kIHNlcnZpY2UsIHRyeSByZXN0YXJ0aW5nIGNvbXB1dGVyXCIsXG5cdFx0XHRcdFx0fSkudGhlbihmdW5jdGlvbihldnQpIHtcblx0XHRcdFx0XHRcdGlmIChldnQucmVzcG9uc2UgPT0gMCkge1xuXHRcdFx0XHRcdFx0XHRhdXRoQXR0ZW1wdHMgPSAwXG5cdFx0XHRcdFx0XHRcdGNvbm5BdHRlbXB0cyA9IDBcblx0XHRcdFx0XHRcdFx0ZGlhbG9nU2hvd24gPSBmYWxzZVxuXHRcdFx0XHRcdFx0XHRjb25uZWN0KClcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGVsZWN0cm9uLmFwcC5xdWl0KClcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdXRoQXR0ZW1wdHMgKz0gMVxuXHRcdFx0XHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRcdFx0XHRjb25uZWN0KClcblx0XHRcdFx0fSwgNTAwKVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0cmVzb2x2ZSgpXG5cblx0XHRsZXQgcmVjb25uZWN0ZWQgPSBmYWxzZVxuXHRcdGxldCB3c0hvc3QgPSBcIlwiXG5cdFx0bGV0IGhlYWRlcnMgPSB7XG5cdFx0XHRcIlVzZXItQWdlbnRcIjogXCJwcml0dW5sXCIsXG5cdFx0XHRcIkF1dGgtVG9rZW5cIjogQXV0aC50b2tlbixcblx0XHR9IGFzIGFueVxuXG5cdFx0aWYgKENvbnN0YW50cy51bml4KSB7XG5cdFx0XHR3c0hvc3QgPSBDb25zdGFudHMudW5peFdzSG9zdFxuXHRcdFx0aGVhZGVyc1tcIkhvc3RcIl0gPSBcInVuaXhcIlxuXHRcdH0gZWxzZSB7XG5cdFx0XHR3c0hvc3QgPSBDb25zdGFudHMud2ViV3NIb3N0XG5cdFx0fVxuXG5cdFx0bGV0IHJlY29ubmVjdCA9ICgpOiB2b2lkID0+IHtcblx0XHRcdHNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdFx0XHRpZiAocmVjb25uZWN0ZWQpIHtcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRyZWNvbm5lY3RlZCA9IHRydWVcblxuXHRcdFx0XHRpZiAoY29ubkF0dGVtcHRzID4gMzApIHtcblx0XHRcdFx0XHRpZiAoIWRpYWxvZ1Nob3duKSB7XG5cdFx0XHRcdFx0XHRkaWFsb2dTaG93biA9IHRydWVcblx0XHRcdFx0XHRcdGVsZWN0cm9uLmRpYWxvZy5zaG93TWVzc2FnZUJveChudWxsLCB7XG5cdFx0XHRcdFx0XHRcdHR5cGU6IFwiZXJyb3JcIixcblx0XHRcdFx0XHRcdFx0YnV0dG9uczogW1wiUmV0cnlcIiwgXCJFeGl0XCJdLFxuXHRcdFx0XHRcdFx0XHR0aXRsZTogXCJQcml0dW5sIC0gU2VydmljZSBFcnJvciAoODM2MilcIixcblx0XHRcdFx0XHRcdFx0bWVzc2FnZTogXCJVbmFibGUgdG8gZXN0YWJsaXNoIGNvbW11bmljYXRpb24gd2l0aCBcIiArXG5cdFx0XHRcdFx0XHRcdFx0XCJiYWNrZ3JvdW5kIHNlcnZpY2UsIHRyeSByZXN0YXJ0aW5nIGNvbXB1dGVyXCIsXG5cdFx0XHRcdFx0XHR9KS50aGVuKGZ1bmN0aW9uIChldnQpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGV2dC5yZXNwb25zZSA9PSAwKSB7XG5cdFx0XHRcdFx0XHRcdFx0YXV0aEF0dGVtcHRzID0gMFxuXHRcdFx0XHRcdFx0XHRcdGNvbm5BdHRlbXB0cyA9IDBcblx0XHRcdFx0XHRcdFx0XHRkaWFsb2dTaG93biA9IGZhbHNlXG5cdFx0XHRcdFx0XHRcdFx0Y29ubmVjdCgpXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0ZWxlY3Ryb24uYXBwLnF1aXQoKVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb25uQXR0ZW1wdHMgKz0gMVxuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbm5lY3QoKVxuXHRcdFx0fSwgMTAwMClcblx0XHR9XG5cblx0XHRzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHdzSG9zdCArIFwiL2V2ZW50c1wiLCB7XG5cdFx0XHRoZWFkZXJzOiBoZWFkZXJzLFxuXHRcdH0pXG5cblx0XHRzb2NrZXQub24oXCJvcGVuXCIsICgpOiB2b2lkID0+IHtcblx0XHRcdGlmIChzb2NrZXRJZCAhPT0gY3VyU29ja2V0KSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXG5cdFx0XHRjb25uQXR0ZW1wdHMgPSAwXG5cdFx0XHRpZiAoc2hvd0Nvbm5lY3QpIHtcblx0XHRcdFx0c2hvd0Nvbm5lY3QgPSBmYWxzZVxuXHRcdFx0XHRjb25zb2xlLmxvZyhcIkV2ZW50czogU2VydmljZSByZWNvbm5lY3RlZFwiKVxuXHRcdFx0XHRpZiAoQ29uc3RhbnRzLm1haW5XaW5kb3cgJiYgIUNvbnN0YW50cy5tYWluV2luZG93LmlzRGVzdHJveWVkKCkpIHtcblx0XHRcdFx0XHRDb25zdGFudHMubWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKFwiZXZlbnQucmVjb25uZWN0ZWRcIilcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pXG5cblx0XHRzb2NrZXQub24oXCJlcnJvclwiLCAoZXJyOiBFcnJvcikgPT4ge1xuXHRcdFx0aWYgKHNvY2tldElkICE9PSBjdXJTb2NrZXQpIHtcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9XG5cblx0XHRcdGlmIChDb25zdGFudHMubWFpbldpbmRvdyAmJiAhQ29uc3RhbnRzLm1haW5XaW5kb3cuaXNEZXN0cm95ZWQoKSkge1xuXHRcdFx0XHRDb25zdGFudHMubWFpbldpbmRvdy53ZWJDb250ZW50cy5zZW5kKFwiZXZlbnQuZXJyb3JcIiwgZXJyLnRvU3RyaW5nKCkpXG5cdFx0XHR9XG5cblx0XHRcdGNvbnNvbGUuZXJyb3IoXCJFdmVudHM6IFNvY2tldCBlcnJvciBcIiArIGVycilcblx0XHRcdHNob3dDb25uZWN0ID0gdHJ1ZVxuXHRcdFx0cmVjb25uZWN0KClcblx0XHR9KVxuXG5cdFx0c29ja2V0Lm9uKFwib25lcnJvclwiLCAoZXJyKSA9PiB7XG5cdFx0XHRpZiAoc29ja2V0SWQgIT09IGN1clNvY2tldCkge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0Y29uc29sZS5lcnJvcihcIkV2ZW50czogU29ja2V0IGVycm9yIFwiICsgZXJyKVxuXHRcdFx0c2hvd0Nvbm5lY3QgPSB0cnVlXG5cdFx0XHRyZWNvbm5lY3QoKVxuXHRcdH0pXG5cblx0XHRzb2NrZXQub24oXCJjbG9zZVwiLCAoKSA9PiB7XG5cdFx0XHRpZiAoc29ja2V0SWQgIT09IGN1clNvY2tldCkge1xuXHRcdFx0XHRyZXR1cm5cblx0XHRcdH1cblxuXHRcdFx0aWYgKENvbnN0YW50cy5tYWluV2luZG93ICYmICFDb25zdGFudHMubWFpbldpbmRvdy5pc0Rlc3Ryb3llZCgpKSB7XG5cdFx0XHRcdENvbnN0YW50cy5tYWluV2luZG93LndlYkNvbnRlbnRzLnNlbmQoXCJldmVudC5jbG9zZWRcIilcblx0XHRcdH1cblxuXHRcdFx0c2hvd0Nvbm5lY3QgPSB0cnVlXG5cdFx0XHRyZWNvbm5lY3QoKVxuXHRcdH0pXG5cblx0XHRzb2NrZXQub24oXCJtZXNzYWdlXCIsIChkYXRhQnVmOiBCdWZmZXIpOiB2b2lkID0+IHtcblx0XHRcdGlmIChzb2NrZXRJZCAhPT0gY3VyU29ja2V0KSB7XG5cdFx0XHRcdHJldHVyblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgZGF0YVN0ciA9IGRhdGFCdWYudG9TdHJpbmcoKVxuXG5cdFx0XHRpZiAoQ29uc3RhbnRzLm1haW5XaW5kb3cgJiYgIUNvbnN0YW50cy5tYWluV2luZG93LmlzRGVzdHJveWVkKCkpIHtcblx0XHRcdFx0Q29uc3RhbnRzLm1haW5XaW5kb3cud2ViQ29udGVudHMuc2VuZChcImV2ZW50XCIsIGRhdGFTdHIpXG5cdFx0XHR9XG5cblx0XHRcdGxldCBkYXRhID0gSlNPTi5wYXJzZShkYXRhU3RyKVxuXHRcdFx0Zm9yIChsZXQgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG5cdFx0XHRcdGNhbGxiYWNrKGRhdGEgYXMgRXZlbnQpXG5cdFx0XHR9XG5cdFx0fSlcblx0fSlcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbmQobXNnOiBzdHJpbmcpIHtcblx0aWYgKHNvY2tldCkge1xuXHRcdHNvY2tldC5zZW5kKG1zZylcblx0fVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3Vic2NyaWJlKGNhbGxiYWNrOiBDYWxsYmFjaykge1xuXHRjYWxsYmFja3MucHVzaChjYWxsYmFjaylcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./main/Service.js\n");

/***/ }),

/***/ "./main/Tpm.js":
/*!*********************!*\
  !*** ./main/Tpm.js ***!
  \*********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   close: () => (/* binding */ close),\n/* harmony export */   open: () => (/* binding */ open),\n/* harmony export */   sign: () => (/* binding */ sign)\n/* harmony export */ });\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! path */ \"path\");\n/* harmony import */ var path__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(path__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Logger */ \"./main/Logger.js\");\n/* harmony import */ var _Errors__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Errors */ \"./main/Errors.js\");\n/* harmony import */ var _RequestUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./RequestUtils */ \"./main/RequestUtils.js\");\n/* harmony import */ var _Auth__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./Auth */ \"./main/Auth.js\");\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! process */ \"process\");\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_6__);\n\n\n\n\n\n\n\nlet deviceAuthPath = path__WEBPACK_IMPORTED_MODULE_0___default().join(\"/\", \"Applications\", \"Pritunl.app\", \"Contents\", \"Resources\", \"Pritunl Device Authentication\");\nif (process__WEBPACK_IMPORTED_MODULE_6___default().argv.indexOf(\"--dev\") !== -1) {\n    deviceAuthPath = path__WEBPACK_IMPORTED_MODULE_0___default().join(__dirname, \"..\", \"..\", \"..\", \"service_macos\", \"Pritunl Device Authentication\");\n}\nlet procs = {};\nfunction open(callerId, privKey64) {\n    let proc = child_process__WEBPACK_IMPORTED_MODULE_1___default().execFile(deviceAuthPath);\n    let stderr = \"\";\n    setTimeout(() => {\n        if (proc.exitCode === null) {\n            let err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.ProcessError(null, \"Tpm: Secure enclave process timed out\", {\n                caller_id: callerId,\n            });\n            _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n        }\n        proc.kill(\"SIGINT\");\n    }, 10000);\n    proc.on(\"error\", (err) => {\n        err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.ProcessError(err, \"Tpm: Secure enclave exec error\", {\n            caller_id: callerId,\n        });\n        _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n        _RequestUtils__WEBPACK_IMPORTED_MODULE_4__.post(\"/tpm/callback\")\n            .set(\"Auth-Token\", _Auth__WEBPACK_IMPORTED_MODULE_5__.token)\n            .set(\"User-Agent\", \"pritunl\")\n            .send({\n            id: callerId,\n            error: err.message,\n        })\n            .end()\n            .then((resp) => {\n            if (resp.status != 200) {\n                err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.RequestError(null, \"Tpm: Callback request error\", {\n                    caller_id: callerId,\n                    reponse_status: resp.status,\n                    data: resp.data,\n                });\n                _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n            }\n        }, (err) => {\n            err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.RequestError(err, \"Tpm: Callback request error\", {\n                caller_id: callerId,\n            });\n            _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n        });\n    });\n    proc.on(\"exit\", (code, signal) => {\n        delete procs[callerId];\n        if (code !== 0) {\n            let err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.ProcessError(null, \"Tpm: Secure enclave exec code error\", {\n                caller_id: callerId,\n                exit_code: code,\n                output: stderr,\n            });\n            _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n            _RequestUtils__WEBPACK_IMPORTED_MODULE_4__.post(\"/tpm/callback\")\n                .set(\"Auth-Token\", _Auth__WEBPACK_IMPORTED_MODULE_5__.token)\n                .set(\"User-Agent\", \"pritunl\")\n                .send({\n                id: callerId,\n                error: err.message,\n            })\n                .end()\n                .then((resp) => {\n                if (resp.status != 200) {\n                    err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.RequestError(null, \"Tpm: Callback request error\", {\n                        caller_id: callerId,\n                        reponse_status: resp.status,\n                        data: resp.data,\n                    });\n                    _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n                }\n            }, (err) => {\n                err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.RequestError(err, \"Tpm: Callback request error\", {\n                    caller_id: callerId,\n                });\n                _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n            });\n        }\n    });\n    let outBuffer = \"\";\n    proc.stdout.on(\"data\", (data) => {\n        outBuffer += data;\n        if (!outBuffer.includes(\"\\n\")) {\n            return;\n        }\n        let lines = outBuffer.split(\"\\n\");\n        let line = lines[0];\n        outBuffer = lines.slice(1).join(\"\\n\");\n        let dataObj;\n        try {\n            dataObj = JSON.parse(line.replace(/\\s/g, \"\"));\n        }\n        catch {\n            let err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.RequestError(null, \"Tpm: Failed to parse line\", {\n                caller_id: callerId,\n                line: data,\n            });\n            _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n            return;\n        }\n        _RequestUtils__WEBPACK_IMPORTED_MODULE_4__.post(\"/tpm/callback\")\n            .set(\"Auth-Token\", _Auth__WEBPACK_IMPORTED_MODULE_5__.token)\n            .set(\"User-Agent\", \"pritunl\")\n            .send({\n            id: callerId,\n            public_key: dataObj.public_key,\n            private_key: dataObj.key_data,\n            signature: dataObj.signature,\n        })\n            .end()\n            .then((resp) => {\n            if (resp.status != 200) {\n                let err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.RequestError(null, \"Tpm: Callback request error\", {\n                    caller_id: callerId,\n                    reponse_status: resp.status,\n                    data: resp.data,\n                });\n                _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n            }\n        }, (err) => {\n            err = new _Errors__WEBPACK_IMPORTED_MODULE_3__.RequestError(err, \"Tpm: Callback request error\", {\n                caller_id: callerId,\n            });\n            _Logger__WEBPACK_IMPORTED_MODULE_2__.error(err);\n        });\n    });\n    proc.stderr.on(\"data\", (data) => {\n        stderr += data;\n    });\n    proc.stdin.write(JSON.stringify({\n        \"key_data\": privKey64,\n    }) + \"\\n\");\n    procs[callerId] = proc;\n}\nfunction sign(callerId, signData) {\n    let proc = procs[callerId];\n    if (!proc) {\n        return;\n    }\n    proc.stdin.write(JSON.stringify({\n        \"sign_data\": signData,\n    }) + \"\\n\");\n}\nfunction close(callerId) {\n    let proc = procs[callerId];\n    if (!proc) {\n        return;\n    }\n    proc.kill(\"SIGINT\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWluL1RwbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQXVCO0FBQ2lCO0FBQ047QUFDQTtBQUVZO0FBQ2hCO0FBQ0E7QUFFOUIsSUFBSSxjQUFjLEdBQUcsZ0RBQVMsQ0FBQyxHQUFHLEVBQUUsY0FBYyxFQUFFLGFBQWEsRUFDaEUsVUFBVSxFQUFFLFdBQVcsRUFBRSwrQkFBK0IsQ0FBQztBQUMxRCxJQUFJLG1EQUFZLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLENBQUM7SUFDMUMsY0FBYyxHQUFHLGdEQUFTLENBQUMsU0FBUyxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsSUFBSSxFQUNyRCxlQUFlLEVBQUUsK0JBQStCLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRUQsSUFBSSxLQUFLLEdBQStDLEVBQUU7QUFFbkQsU0FBUyxJQUFJLENBQUMsUUFBZ0IsRUFBRSxTQUFpQjtJQUN2RCxJQUFJLElBQUksR0FBRyw2REFBcUIsQ0FBQyxjQUFjLENBQUM7SUFDaEQsSUFBSSxNQUFNLEdBQUcsRUFBRTtJQUVmLFVBQVUsQ0FBQyxHQUFHLEVBQUU7UUFDZixJQUFJLElBQUksQ0FBQyxRQUFRLEtBQUssSUFBSSxFQUFFLENBQUM7WUFDNUIsSUFBSSxHQUFHLEdBQUcsSUFBSSxpREFBbUIsQ0FDaEMsSUFBSSxFQUNKLHVDQUF1QyxFQUN2QztnQkFDQyxTQUFTLEVBQUUsUUFBUTthQUNuQixDQUNEO1lBQ0QsMENBQVksQ0FBQyxHQUFHLENBQUM7UUFDbEIsQ0FBQztRQUNELElBQUksQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3BCLENBQUMsRUFBRSxLQUFLLENBQUM7SUFFVCxJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFO1FBQ3hCLEdBQUcsR0FBRyxJQUFJLGlEQUFtQixDQUM1QixHQUFHLEVBQ0gsZ0NBQWdDLEVBQ2hDO1lBQ0MsU0FBUyxFQUFFLFFBQVE7U0FDbkIsQ0FDRDtRQUNELDBDQUFZLENBQUMsR0FBRyxDQUFDO1FBRWpCLCtDQUNNLENBQUMsZUFBZSxDQUFDO2FBQ3JCLEdBQUcsQ0FBQyxZQUFZLEVBQUUsd0NBQVUsQ0FBQzthQUM3QixHQUFHLENBQUMsWUFBWSxFQUFFLFNBQVMsQ0FBQzthQUM1QixJQUFJLENBQUM7WUFDTCxFQUFFLEVBQUUsUUFBUTtZQUNaLEtBQUssRUFBRSxHQUFHLENBQUMsT0FBTztTQUNsQixDQUFDO2FBQ0QsR0FBRyxFQUFFO2FBQ0wsSUFBSSxDQUFDLENBQUMsSUFBc0IsRUFBRSxFQUFFO1lBQ2hDLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztnQkFDeEIsR0FBRyxHQUFHLElBQUksaURBQW1CLENBQzVCLElBQUksRUFDSiw2QkFBNkIsRUFDN0I7b0JBQ0MsU0FBUyxFQUFFLFFBQVE7b0JBQ25CLGNBQWMsRUFBRSxJQUFJLENBQUMsTUFBTTtvQkFDM0IsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2lCQUNmLENBQ0Q7Z0JBQ0QsMENBQVksQ0FBQyxHQUFHLENBQUM7WUFDbEIsQ0FBQztRQUNGLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQ1YsR0FBRyxHQUFHLElBQUksaURBQW1CLENBQzVCLEdBQUcsRUFDSCw2QkFBNkIsRUFDN0I7Z0JBQ0MsU0FBUyxFQUFFLFFBQVE7YUFDbkIsQ0FDRDtZQUNELDBDQUFZLENBQUMsR0FBRyxDQUFDO1FBQ2xCLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztJQUVGLElBQUksQ0FBQyxFQUFFLENBQUMsTUFBTSxFQUFFLENBQUMsSUFBWSxFQUFFLE1BQWMsRUFBRSxFQUFFO1FBQ2hELE9BQU8sS0FBSyxDQUFDLFFBQVEsQ0FBQztRQUV0QixJQUFJLElBQUksS0FBSyxDQUFDLEVBQUUsQ0FBQztZQUNoQixJQUFJLEdBQUcsR0FBRyxJQUFJLGlEQUFtQixDQUNoQyxJQUFJLEVBQ0oscUNBQXFDLEVBQ3JDO2dCQUNDLFNBQVMsRUFBRSxRQUFRO2dCQUNuQixTQUFTLEVBQUUsSUFBSTtnQkFDZixNQUFNLEVBQUUsTUFBTTthQUNkLENBQ0Q7WUFDRCwwQ0FBWSxDQUFDLEdBQUcsQ0FBQztZQUVqQiwrQ0FDTSxDQUFDLGVBQWUsQ0FBQztpQkFDckIsR0FBRyxDQUFDLFlBQVksRUFBRSx3Q0FBVSxDQUFDO2lCQUM3QixHQUFHLENBQUMsWUFBWSxFQUFFLFNBQVMsQ0FBQztpQkFDNUIsSUFBSSxDQUFDO2dCQUNMLEVBQUUsRUFBRSxRQUFRO2dCQUNaLEtBQUssRUFBRSxHQUFHLENBQUMsT0FBTzthQUNsQixDQUFDO2lCQUNELEdBQUcsRUFBRTtpQkFDTCxJQUFJLENBQUMsQ0FBQyxJQUFzQixFQUFFLEVBQUU7Z0JBQ2hDLElBQUksSUFBSSxDQUFDLE1BQU0sSUFBSSxHQUFHLEVBQUUsQ0FBQztvQkFDeEIsR0FBRyxHQUFHLElBQUksaURBQW1CLENBQzVCLElBQUksRUFDSiw2QkFBNkIsRUFDN0I7d0JBQ0MsU0FBUyxFQUFFLFFBQVE7d0JBQ25CLGNBQWMsRUFBRSxJQUFJLENBQUMsTUFBTTt3QkFDM0IsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO3FCQUNmLENBQ0Q7b0JBQ0QsMENBQVksQ0FBQyxHQUFHLENBQUM7Z0JBQ2xCLENBQUM7WUFDRixDQUFDLEVBQUUsQ0FBQyxHQUFHLEVBQUUsRUFBRTtnQkFDVixHQUFHLEdBQUcsSUFBSSxpREFBbUIsQ0FDNUIsR0FBRyxFQUNILDZCQUE2QixFQUM3QjtvQkFDQyxTQUFTLEVBQUUsUUFBUTtpQkFDbkIsQ0FDRDtnQkFDRCwwQ0FBWSxDQUFDLEdBQUcsQ0FBQztZQUNsQixDQUFDLENBQUM7UUFDSixDQUFDO0lBQ0YsQ0FBQyxDQUFDO0lBRUYsSUFBSSxTQUFTLEdBQUcsRUFBRTtJQUNsQixJQUFJLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxJQUFJLEVBQUUsRUFBRTtRQUMvQixTQUFTLElBQUksSUFBSTtRQUNqQixJQUFJLENBQUMsU0FBUyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1lBQy9CLE9BQU07UUFDUCxDQUFDO1FBQ0QsSUFBSSxLQUFLLEdBQUcsU0FBUyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUM7UUFDakMsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQztRQUNuQixTQUFTLEdBQUcsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO1FBRXJDLElBQUksT0FBNkI7UUFDakMsSUFBSSxDQUFDO1lBQ0osT0FBTyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUM7UUFDOUMsQ0FBQztRQUFDLE1BQU0sQ0FBQztZQUNSLElBQUksR0FBRyxHQUFHLElBQUksaURBQW1CLENBQ2hDLElBQUksRUFDSiwyQkFBMkIsRUFDM0I7Z0JBQ0MsU0FBUyxFQUFFLFFBQVE7Z0JBQ25CLElBQUksRUFBRSxJQUFJO2FBQ1YsQ0FDRDtZQUNELDBDQUFZLENBQUMsR0FBRyxDQUFDO1lBQ2pCLE9BQU07UUFDUCxDQUFDO1FBRUQsK0NBQ00sQ0FBQyxlQUFlLENBQUM7YUFDckIsR0FBRyxDQUFDLFlBQVksRUFBRSx3Q0FBVSxDQUFDO2FBQzdCLEdBQUcsQ0FBQyxZQUFZLEVBQUUsU0FBUyxDQUFDO2FBQzVCLElBQUksQ0FBQztZQUNMLEVBQUUsRUFBRSxRQUFRO1lBQ1osVUFBVSxFQUFFLE9BQU8sQ0FBQyxVQUFVO1lBQzlCLFdBQVcsRUFBRSxPQUFPLENBQUMsUUFBUTtZQUM3QixTQUFTLEVBQUUsT0FBTyxDQUFDLFNBQVM7U0FDNUIsQ0FBQzthQUNELEdBQUcsRUFBRTthQUNMLElBQUksQ0FBQyxDQUFDLElBQXNCLEVBQUUsRUFBRTtZQUNoQyxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksR0FBRyxFQUFFLENBQUM7Z0JBQ3hCLElBQUksR0FBRyxHQUFHLElBQUksaURBQW1CLENBQ2hDLElBQUksRUFDSiw2QkFBNkIsRUFDN0I7b0JBQ0MsU0FBUyxFQUFFLFFBQVE7b0JBQ25CLGNBQWMsRUFBRSxJQUFJLENBQUMsTUFBTTtvQkFDM0IsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO2lCQUNmLENBQ0Q7Z0JBQ0QsMENBQVksQ0FBQyxHQUFHLENBQUM7WUFDbEIsQ0FBQztRQUNGLENBQUMsRUFBRSxDQUFDLEdBQUcsRUFBRSxFQUFFO1lBQ1YsR0FBRyxHQUFHLElBQUksaURBQW1CLENBQzVCLEdBQUcsRUFDSCw2QkFBNkIsRUFDN0I7Z0JBQ0MsU0FBUyxFQUFFLFFBQVE7YUFDbkIsQ0FDRDtZQUNELDBDQUFZLENBQUMsR0FBRyxDQUFDO1FBQ2xCLENBQUMsQ0FBQztJQUNKLENBQUMsQ0FBQztJQUVGLElBQUksQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLE1BQU0sRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFO1FBQy9CLE1BQU0sSUFBSSxJQUFJO0lBQ2YsQ0FBQyxDQUFDO0lBRUYsSUFBSSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQztRQUMvQixVQUFVLEVBQUUsU0FBUztLQUNyQixDQUFDLEdBQUcsSUFBSSxDQUFDO0lBRVYsS0FBSyxDQUFDLFFBQVEsQ0FBQyxHQUFHLElBQUk7QUFDdkIsQ0FBQztBQUVNLFNBQVMsSUFBSSxDQUFDLFFBQWdCLEVBQUUsUUFBZ0I7SUFDdEQsSUFBSSxJQUFJLEdBQUcsS0FBSyxDQUFDLFFBQVEsQ0FBQztJQUMxQixJQUFJLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDWCxPQUFNO0lBQ1AsQ0FBQztJQUVELElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUM7UUFDL0IsV0FBVyxFQUFFLFFBQVE7S0FDckIsQ0FBQyxHQUFHLElBQUksQ0FBQztBQUNYLENBQUM7QUFFTSxTQUFTLEtBQUssQ0FBQyxRQUFnQjtJQUNyQyxJQUFJLElBQUksR0FBRyxLQUFLLENBQUMsUUFBUSxDQUFDO0lBQzFCLElBQUksQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNYLE9BQU07SUFDUCxDQUFDO0lBRUQsSUFBSSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7QUFDcEIsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9tYWluL1RwbS50cz9mMzU3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYXRoIGZyb20gXCJwYXRoXCJcbmltcG9ydCBjaGlsZHByb2Nlc3MgZnJvbSBcImNoaWxkX3Byb2Nlc3NcIlxuaW1wb3J0ICogYXMgTG9nZ2VyIGZyb20gXCIuL0xvZ2dlclwiXG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSBcIi4vRXJyb3JzXCJcbmltcG9ydCAqIGFzIFJlcXVlc3QgZnJvbSBcIi4vUmVxdWVzdFwiXG5pbXBvcnQgKiBhcyBSZXF1ZXN0VXRpbHMgZnJvbSAnLi9SZXF1ZXN0VXRpbHMnXG5pbXBvcnQgKiBhcyBBdXRoIGZyb20gXCIuL0F1dGhcIlxuaW1wb3J0IHByb2Nlc3MgZnJvbSBcInByb2Nlc3NcIjtcblxubGV0IGRldmljZUF1dGhQYXRoID0gcGF0aC5qb2luKFwiL1wiLCBcIkFwcGxpY2F0aW9uc1wiLCBcIlByaXR1bmwuYXBwXCIsXG5cdFwiQ29udGVudHNcIiwgXCJSZXNvdXJjZXNcIiwgXCJQcml0dW5sIERldmljZSBBdXRoZW50aWNhdGlvblwiKVxuaWYgKHByb2Nlc3MuYXJndi5pbmRleE9mKFwiLS1kZXZcIikgIT09IC0xKSB7XG5cdGRldmljZUF1dGhQYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLlwiLCBcIi4uXCIsIFwiLi5cIixcblx0XHRcInNlcnZpY2VfbWFjb3NcIiwgXCJQcml0dW5sIERldmljZSBBdXRoZW50aWNhdGlvblwiKTtcbn1cblxubGV0IHByb2NzOiB7W2tleTogc3RyaW5nXTogY2hpbGRwcm9jZXNzLkNoaWxkUHJvY2Vzc30gPSB7fVxuXG5leHBvcnQgZnVuY3Rpb24gb3BlbihjYWxsZXJJZDogc3RyaW5nLCBwcml2S2V5NjQ6IHN0cmluZyk6IHZvaWQge1xuXHRsZXQgcHJvYyA9IGNoaWxkcHJvY2Vzcy5leGVjRmlsZShkZXZpY2VBdXRoUGF0aClcblx0bGV0IHN0ZGVyciA9IFwiXCJcblxuXHRzZXRUaW1lb3V0KCgpID0+IHtcblx0XHRpZiAocHJvYy5leGl0Q29kZSA9PT0gbnVsbCkge1xuXHRcdFx0bGV0IGVyciA9IG5ldyBFcnJvcnMuUHJvY2Vzc0Vycm9yKFxuXHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcIlRwbTogU2VjdXJlIGVuY2xhdmUgcHJvY2VzcyB0aW1lZCBvdXRcIixcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNhbGxlcl9pZDogY2FsbGVySWQsXG5cdFx0XHRcdH0sXG5cdFx0XHQpXG5cdFx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXHRcdH1cblx0XHRwcm9jLmtpbGwoXCJTSUdJTlRcIilcblx0fSwgMTAwMDApXG5cblx0cHJvYy5vbihcImVycm9yXCIsIChlcnIpID0+IHtcblx0XHRlcnIgPSBuZXcgRXJyb3JzLlByb2Nlc3NFcnJvcihcblx0XHRcdGVycixcblx0XHRcdFwiVHBtOiBTZWN1cmUgZW5jbGF2ZSBleGVjIGVycm9yXCIsXG5cdFx0XHR7XG5cdFx0XHRcdGNhbGxlcl9pZDogY2FsbGVySWQsXG5cdFx0XHR9LFxuXHRcdClcblx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXG5cdFx0UmVxdWVzdFV0aWxzXG5cdFx0XHQucG9zdChcIi90cG0vY2FsbGJhY2tcIilcblx0XHRcdC5zZXQoXCJBdXRoLVRva2VuXCIsIEF1dGgudG9rZW4pXG5cdFx0XHQuc2V0KFwiVXNlci1BZ2VudFwiLCBcInByaXR1bmxcIilcblx0XHRcdC5zZW5kKHtcblx0XHRcdFx0aWQ6IGNhbGxlcklkLFxuXHRcdFx0XHRlcnJvcjogZXJyLm1lc3NhZ2UsXG5cdFx0XHR9KVxuXHRcdFx0LmVuZCgpXG5cdFx0XHQudGhlbigocmVzcDogUmVxdWVzdC5SZXNwb25zZSkgPT4ge1xuXHRcdFx0XHRpZiAocmVzcC5zdGF0dXMgIT0gMjAwKSB7XG5cdFx0XHRcdFx0ZXJyID0gbmV3IEVycm9ycy5SZXF1ZXN0RXJyb3IoXG5cdFx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdFx0XCJUcG06IENhbGxiYWNrIHJlcXVlc3QgZXJyb3JcIixcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0Y2FsbGVyX2lkOiBjYWxsZXJJZCxcblx0XHRcdFx0XHRcdFx0cmVwb25zZV9zdGF0dXM6IHJlc3Auc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRkYXRhOiByZXNwLmRhdGEsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXHRcdFx0XHR9XG5cdFx0XHR9LCAoZXJyKSA9PiB7XG5cdFx0XHRcdGVyciA9IG5ldyBFcnJvcnMuUmVxdWVzdEVycm9yKFxuXHRcdFx0XHRcdGVycixcblx0XHRcdFx0XHRcIlRwbTogQ2FsbGJhY2sgcmVxdWVzdCBlcnJvclwiLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNhbGxlcl9pZDogY2FsbGVySWQsXG5cdFx0XHRcdFx0fSxcblx0XHRcdFx0KVxuXHRcdFx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXHRcdFx0fSlcblx0fSlcblxuXHRwcm9jLm9uKFwiZXhpdFwiLCAoY29kZTogbnVtYmVyLCBzaWduYWw6IHN0cmluZykgPT4ge1xuXHRcdGRlbGV0ZSBwcm9jc1tjYWxsZXJJZF1cblxuXHRcdGlmIChjb2RlICE9PSAwKSB7XG5cdFx0XHRsZXQgZXJyID0gbmV3IEVycm9ycy5Qcm9jZXNzRXJyb3IoXG5cdFx0XHRcdG51bGwsXG5cdFx0XHRcdFwiVHBtOiBTZWN1cmUgZW5jbGF2ZSBleGVjIGNvZGUgZXJyb3JcIixcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGNhbGxlcl9pZDogY2FsbGVySWQsXG5cdFx0XHRcdFx0ZXhpdF9jb2RlOiBjb2RlLFxuXHRcdFx0XHRcdG91dHB1dDogc3RkZXJyLFxuXHRcdFx0XHR9LFxuXHRcdFx0KVxuXHRcdFx0TG9nZ2VyLmVycm9yKGVycilcblxuXHRcdFx0UmVxdWVzdFV0aWxzXG5cdFx0XHRcdC5wb3N0KFwiL3RwbS9jYWxsYmFja1wiKVxuXHRcdFx0XHQuc2V0KFwiQXV0aC1Ub2tlblwiLCBBdXRoLnRva2VuKVxuXHRcdFx0XHQuc2V0KFwiVXNlci1BZ2VudFwiLCBcInByaXR1bmxcIilcblx0XHRcdFx0LnNlbmQoe1xuXHRcdFx0XHRcdGlkOiBjYWxsZXJJZCxcblx0XHRcdFx0XHRlcnJvcjogZXJyLm1lc3NhZ2UsXG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5lbmQoKVxuXHRcdFx0XHQudGhlbigocmVzcDogUmVxdWVzdC5SZXNwb25zZSkgPT4ge1xuXHRcdFx0XHRcdGlmIChyZXNwLnN0YXR1cyAhPSAyMDApIHtcblx0XHRcdFx0XHRcdGVyciA9IG5ldyBFcnJvcnMuUmVxdWVzdEVycm9yKFxuXHRcdFx0XHRcdFx0XHRudWxsLFxuXHRcdFx0XHRcdFx0XHRcIlRwbTogQ2FsbGJhY2sgcmVxdWVzdCBlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdFx0Y2FsbGVyX2lkOiBjYWxsZXJJZCxcblx0XHRcdFx0XHRcdFx0XHRyZXBvbnNlX3N0YXR1czogcmVzcC5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0ZGF0YTogcmVzcC5kYXRhLFxuXHRcdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0TG9nZ2VyLmVycm9yKGVycilcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sIChlcnIpID0+IHtcblx0XHRcdFx0XHRlcnIgPSBuZXcgRXJyb3JzLlJlcXVlc3RFcnJvcihcblx0XHRcdFx0XHRcdGVycixcblx0XHRcdFx0XHRcdFwiVHBtOiBDYWxsYmFjayByZXF1ZXN0IGVycm9yXCIsXG5cdFx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRcdGNhbGxlcl9pZDogY2FsbGVySWQsXG5cdFx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdClcblx0XHRcdFx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXHRcdFx0XHR9KVxuXHRcdH1cblx0fSlcblxuXHRsZXQgb3V0QnVmZmVyID0gXCJcIlxuXHRwcm9jLnN0ZG91dC5vbihcImRhdGFcIiwgKGRhdGEpID0+IHtcblx0XHRvdXRCdWZmZXIgKz0gZGF0YVxuXHRcdGlmICghb3V0QnVmZmVyLmluY2x1ZGVzKFwiXFxuXCIpKSB7XG5cdFx0XHRyZXR1cm5cblx0XHR9XG5cdFx0bGV0IGxpbmVzID0gb3V0QnVmZmVyLnNwbGl0KFwiXFxuXCIpXG5cdFx0bGV0IGxpbmUgPSBsaW5lc1swXVxuXHRcdG91dEJ1ZmZlciA9IGxpbmVzLnNsaWNlKDEpLmpvaW4oXCJcXG5cIilcblxuXHRcdGxldCBkYXRhT2JqOiB7W2tleTogc3RyaW5nXTogYW55fVxuXHRcdHRyeSB7XG5cdFx0XHRkYXRhT2JqID0gSlNPTi5wYXJzZShsaW5lLnJlcGxhY2UoL1xccy9nLCBcIlwiKSlcblx0XHR9IGNhdGNoIHtcblx0XHRcdGxldCBlcnIgPSBuZXcgRXJyb3JzLlJlcXVlc3RFcnJvcihcblx0XHRcdFx0bnVsbCxcblx0XHRcdFx0XCJUcG06IEZhaWxlZCB0byBwYXJzZSBsaW5lXCIsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjYWxsZXJfaWQ6IGNhbGxlcklkLFxuXHRcdFx0XHRcdGxpbmU6IGRhdGEsXG5cdFx0XHRcdH0sXG5cdFx0XHQpXG5cdFx0XHRMb2dnZXIuZXJyb3IoZXJyKVxuXHRcdFx0cmV0dXJuXG5cdFx0fVxuXG5cdFx0UmVxdWVzdFV0aWxzXG5cdFx0XHQucG9zdChcIi90cG0vY2FsbGJhY2tcIilcblx0XHRcdC5zZXQoXCJBdXRoLVRva2VuXCIsIEF1dGgudG9rZW4pXG5cdFx0XHQuc2V0KFwiVXNlci1BZ2VudFwiLCBcInByaXR1bmxcIilcblx0XHRcdC5zZW5kKHtcblx0XHRcdFx0aWQ6IGNhbGxlcklkLFxuXHRcdFx0XHRwdWJsaWNfa2V5OiBkYXRhT2JqLnB1YmxpY19rZXksXG5cdFx0XHRcdHByaXZhdGVfa2V5OiBkYXRhT2JqLmtleV9kYXRhLFxuXHRcdFx0XHRzaWduYXR1cmU6IGRhdGFPYmouc2lnbmF0dXJlLFxuXHRcdFx0fSlcblx0XHRcdC5lbmQoKVxuXHRcdFx0LnRoZW4oKHJlc3A6IFJlcXVlc3QuUmVzcG9uc2UpID0+IHtcblx0XHRcdFx0aWYgKHJlc3Auc3RhdHVzICE9IDIwMCkge1xuXHRcdFx0XHRcdGxldCBlcnIgPSBuZXcgRXJyb3JzLlJlcXVlc3RFcnJvcihcblx0XHRcdFx0XHRcdG51bGwsXG5cdFx0XHRcdFx0XHRcIlRwbTogQ2FsbGJhY2sgcmVxdWVzdCBlcnJvclwiLFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHRjYWxsZXJfaWQ6IGNhbGxlcklkLFxuXHRcdFx0XHRcdFx0XHRyZXBvbnNlX3N0YXR1czogcmVzcC5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdGRhdGE6IHJlc3AuZGF0YSxcblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHRcdExvZ2dlci5lcnJvcihlcnIpXG5cdFx0XHRcdH1cblx0XHRcdH0sIChlcnIpID0+IHtcblx0XHRcdFx0ZXJyID0gbmV3IEVycm9ycy5SZXF1ZXN0RXJyb3IoXG5cdFx0XHRcdFx0ZXJyLFxuXHRcdFx0XHRcdFwiVHBtOiBDYWxsYmFjayByZXF1ZXN0IGVycm9yXCIsXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0Y2FsbGVyX2lkOiBjYWxsZXJJZCxcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHQpXG5cdFx0XHRcdExvZ2dlci5lcnJvcihlcnIpXG5cdFx0XHR9KVxuXHR9KVxuXG5cdHByb2Muc3RkZXJyLm9uKFwiZGF0YVwiLCAoZGF0YSkgPT4ge1xuXHRcdHN0ZGVyciArPSBkYXRhXG5cdH0pXG5cblx0cHJvYy5zdGRpbi53cml0ZShKU09OLnN0cmluZ2lmeSh7XG5cdFx0XCJrZXlfZGF0YVwiOiBwcml2S2V5NjQsXG5cdH0pICsgXCJcXG5cIilcblxuXHRwcm9jc1tjYWxsZXJJZF0gPSBwcm9jXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzaWduKGNhbGxlcklkOiBzdHJpbmcsIHNpZ25EYXRhOiBzdHJpbmcpOiB2b2lkIHtcblx0bGV0IHByb2MgPSBwcm9jc1tjYWxsZXJJZF1cblx0aWYgKCFwcm9jKSB7XG5cdFx0cmV0dXJuXG5cdH1cblxuXHRwcm9jLnN0ZGluLndyaXRlKEpTT04uc3RyaW5naWZ5KHtcblx0XHRcInNpZ25fZGF0YVwiOiBzaWduRGF0YSxcblx0fSkgKyBcIlxcblwiKVxufVxuXG5leHBvcnQgZnVuY3Rpb24gY2xvc2UoY2FsbGVySWQ6IHN0cmluZyk6IHZvaWQge1xuXHRsZXQgcHJvYyA9IHByb2NzW2NhbGxlcklkXVxuXHRpZiAoIXByb2MpIHtcblx0XHRyZXR1cm5cblx0fVxuXG5cdHByb2Mua2lsbChcIlNJR0lOVFwiKVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./main/Tpm.js\n");

/***/ }),

/***/ "./main/Utils.js":
/*!***********************!*\
  !*** ./main/Utils.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   openLink: () => (/* binding */ openLink),\n/* harmony export */   uuid: () => (/* binding */ uuid),\n/* harmony export */   uuidRand: () => (/* binding */ uuidRand)\n/* harmony export */ });\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! electron */ \"electron\");\n/* harmony import */ var electron__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(electron__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! process */ \"process\");\n/* harmony import */ var process__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(process__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! child_process */ \"child_process\");\n/* harmony import */ var child_process__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(child_process__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nfunction uuid() {\n    return (+new Date() + Math.floor(Math.random() * 999999)).toString(36);\n}\nfunction uuidRand() {\n    let id = \"\";\n    for (let i = 0; i < 4; i++) {\n        id += Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);\n    }\n    return id;\n}\nfunction openLink(url) {\n    let u = new URL(url);\n    if (u.protocol !== \"http:\" && u.protocol !== \"https:\") {\n        return false;\n    }\n    if (!u.hostname) {\n        return false;\n    }\n    if (u.port && Number.isNaN(u.port)) {\n        return false;\n    }\n    let urlParsed = u.protocol + \"//\" + u.hostname;\n    if (u.port) {\n        urlParsed += \":\" + u.port;\n    }\n    if (u.pathname) {\n        urlParsed += u.pathname;\n    }\n    if (u.search) {\n        urlParsed += u.search;\n    }\n    if (u.hash) {\n        urlParsed += u.hash;\n    }\n    if ((process__WEBPACK_IMPORTED_MODULE_1___default().platform) === \"linux\") {\n        child_process__WEBPACK_IMPORTED_MODULE_2___default().execFile(\"xdg-open\", [urlParsed], (err) => {\n            if (err) {\n                electron__WEBPACK_IMPORTED_MODULE_0___default().shell.openExternal(urlParsed);\n            }\n        });\n    }\n    else {\n        electron__WEBPACK_IMPORTED_MODULE_0___default().shell.openExternal(urlParsed);\n    }\n    return true;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9tYWluL1V0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUErQjtBQUNEO0FBQ1c7QUFFbEMsU0FBUyxJQUFJO0lBQ25CLE9BQU8sQ0FBQyxDQUFDLElBQUksSUFBSSxFQUFFLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxRQUFRLENBQUMsRUFBRSxDQUFDLENBQUM7QUFDeEUsQ0FBQztBQUVNLFNBQVMsUUFBUTtJQUN2QixJQUFJLEVBQUUsR0FBRyxFQUFFO0lBRVgsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEVBQUUsRUFBRSxDQUFDO1FBQzVCLEVBQUUsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLEVBQUUsQ0FBQyxHQUFHLE9BQU8sQ0FBQyxDQUFDLFFBQVEsQ0FDdkQsRUFBRSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDO0lBQ25CLENBQUM7SUFFRCxPQUFPLEVBQUUsQ0FBQztBQUNYLENBQUM7QUFFTSxTQUFTLFFBQVEsQ0FBQyxHQUFXO0lBQ25DLElBQUksQ0FBQyxHQUFHLElBQUksR0FBRyxDQUFDLEdBQUcsQ0FBQztJQUVwQixJQUFJLENBQUMsQ0FBQyxRQUFRLEtBQUssT0FBTyxJQUFJLENBQUMsQ0FBQyxRQUFRLEtBQUssUUFBUSxFQUFFLENBQUM7UUFDdkQsT0FBTyxLQUFLO0lBQ2IsQ0FBQztJQUNELElBQUksQ0FBQyxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDakIsT0FBTyxLQUFLO0lBQ2IsQ0FBQztJQUNELElBQUksQ0FBQyxDQUFDLElBQUksSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQ3BDLE9BQU8sS0FBSztJQUNiLENBQUM7SUFFRCxJQUFJLFNBQVMsR0FBRyxDQUFDLENBQUMsUUFBUSxHQUFHLElBQUksR0FBRyxDQUFDLENBQUMsUUFBUTtJQUM5QyxJQUFJLENBQUMsQ0FBQyxJQUFJLEVBQUUsQ0FBQztRQUNaLFNBQVMsSUFBSSxHQUFHLEdBQUcsQ0FBQyxDQUFDLElBQUk7SUFDMUIsQ0FBQztJQUNELElBQUksQ0FBQyxDQUFDLFFBQVEsRUFBRSxDQUFDO1FBQ2hCLFNBQVMsSUFBSSxDQUFDLENBQUMsUUFBUTtJQUN4QixDQUFDO0lBQ0QsSUFBSSxDQUFDLENBQUMsTUFBTSxFQUFFLENBQUM7UUFDZCxTQUFTLElBQUksQ0FBQyxDQUFDLE1BQU07SUFDdEIsQ0FBQztJQUNELElBQUksQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO1FBQ1osU0FBUyxJQUFJLENBQUMsQ0FBQyxJQUFJO0lBQ3BCLENBQUM7SUFFRCxJQUFJLHlEQUFnQixLQUFLLE9BQU8sRUFBRSxDQUFDO1FBQ2xDLDZEQUFxQixDQUNwQixVQUFVLEVBQUUsQ0FBQyxTQUFTLENBQUMsRUFDdkIsQ0FBQyxHQUFHLEVBQUUsRUFBRTtZQUNQLElBQUksR0FBRyxFQUFFLENBQUM7Z0JBQ1QscURBQWMsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDO1lBQ3ZDLENBQUM7UUFDRixDQUFDLENBQ0Q7SUFDRixDQUFDO1NBQU0sQ0FBQztRQUNQLHFEQUFjLENBQUMsWUFBWSxDQUFDLFNBQVMsQ0FBQztJQUN2QyxDQUFDO0lBRUQsT0FBTyxJQUFJO0FBQ1osQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9tYWluL1V0aWxzLnRzPzgxMDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGVsZWN0cm9uIGZyb20gXCJlbGVjdHJvblwiXG5pbXBvcnQgcHJvY2VzcyBmcm9tIFwicHJvY2Vzc1wiO1xuaW1wb3J0IGNoaWxkcHJvY2VzcyBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXVpZCgpOiBzdHJpbmcge1xuXHRyZXR1cm4gKCtuZXcgRGF0ZSgpICsgTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogOTk5OTk5KSkudG9TdHJpbmcoMzYpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdXVpZFJhbmQoKTogc3RyaW5nIHtcblx0bGV0IGlkID0gXCJcIlxuXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0aWQgKz0gTWF0aC5mbG9vcigoMSArIE1hdGgucmFuZG9tKCkpICogMHgxMDAwMCkudG9TdHJpbmcoXG5cdFx0XHQxNikuc3Vic3RyaW5nKDEpO1xuXHR9XG5cblx0cmV0dXJuIGlkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gb3BlbkxpbmsodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcblx0bGV0IHUgPSBuZXcgVVJMKHVybClcblxuXHRpZiAodS5wcm90b2NvbCAhPT0gXCJodHRwOlwiICYmIHUucHJvdG9jb2wgIT09IFwiaHR0cHM6XCIpIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRpZiAoIXUuaG9zdG5hbWUpIHtcblx0XHRyZXR1cm4gZmFsc2Vcblx0fVxuXHRpZiAodS5wb3J0ICYmIE51bWJlci5pc05hTih1LnBvcnQpKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cblxuXHRsZXQgdXJsUGFyc2VkID0gdS5wcm90b2NvbCArIFwiLy9cIiArIHUuaG9zdG5hbWVcblx0aWYgKHUucG9ydCkge1xuXHRcdHVybFBhcnNlZCArPSBcIjpcIiArIHUucG9ydFxuXHR9XG5cdGlmICh1LnBhdGhuYW1lKSB7XG5cdFx0dXJsUGFyc2VkICs9IHUucGF0aG5hbWVcblx0fVxuXHRpZiAodS5zZWFyY2gpIHtcblx0XHR1cmxQYXJzZWQgKz0gdS5zZWFyY2hcblx0fVxuXHRpZiAodS5oYXNoKSB7XG5cdFx0dXJsUGFyc2VkICs9IHUuaGFzaFxuXHR9XG5cblx0aWYgKHByb2Nlc3MucGxhdGZvcm0gPT09IFwibGludXhcIikge1xuXHRcdGNoaWxkcHJvY2Vzcy5leGVjRmlsZShcblx0XHRcdFwieGRnLW9wZW5cIiwgW3VybFBhcnNlZF0sXG5cdFx0XHQoZXJyKSA9PiB7XG5cdFx0XHRcdGlmIChlcnIpIHtcblx0XHRcdFx0XHRlbGVjdHJvbi5zaGVsbC5vcGVuRXh0ZXJuYWwodXJsUGFyc2VkKVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdClcblx0fSBlbHNlIHtcblx0XHRlbGVjdHJvbi5zaGVsbC5vcGVuRXh0ZXJuYWwodXJsUGFyc2VkKVxuXHR9XG5cblx0cmV0dXJuIHRydWVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./main/Utils.js\n");

/***/ }),

/***/ "./node_modules/chownr/chownr.js":
/*!***************************************!*\
  !*** ./node_modules/chownr/chownr.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n/* istanbul ignore next */\nconst LCHOWN = fs.lchown ? 'lchown' : 'chown'\n/* istanbul ignore next */\nconst LCHOWNSYNC = fs.lchownSync ? 'lchownSync' : 'chownSync'\n\n/* istanbul ignore next */\nconst needEISDIRHandled = fs.lchown &&\n  !process.version.match(/v1[1-9]+\\./) &&\n  !process.version.match(/v10\\.[6-9]/)\n\nconst lchownSync = (path, uid, gid) => {\n  try {\n    return fs[LCHOWNSYNC](path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst chownSync = (path, uid, gid) => {\n  try {\n    return fs.chownSync(path, uid, gid)\n  } catch (er) {\n    if (er.code !== 'ENOENT')\n      throw er\n  }\n}\n\n/* istanbul ignore next */\nconst handleEISDIR =\n  needEISDIRHandled ? (path, uid, gid, cb) => er => {\n    // Node prior to v10 had a very questionable implementation of\n    // fs.lchown, which would always try to call fs.open on a directory\n    // Fall back to fs.chown in those cases.\n    if (!er || er.code !== 'EISDIR')\n      cb(er)\n    else\n      fs.chown(path, uid, gid, cb)\n  }\n  : (_, __, ___, cb) => cb\n\n/* istanbul ignore next */\nconst handleEISDirSync =\n  needEISDIRHandled ? (path, uid, gid) => {\n    try {\n      return lchownSync(path, uid, gid)\n    } catch (er) {\n      if (er.code !== 'EISDIR')\n        throw er\n      chownSync(path, uid, gid)\n    }\n  }\n  : (path, uid, gid) => lchownSync(path, uid, gid)\n\n// fs.readdir could only accept an options object as of node v6\nconst nodeVersion = process.version\nlet readdir = (path, options, cb) => fs.readdir(path, options, cb)\nlet readdirSync = (path, options) => fs.readdirSync(path, options)\n/* istanbul ignore next */\nif (/^v4\\./.test(nodeVersion))\n  readdir = (path, options, cb) => fs.readdir(path, cb)\n\nconst chown = (cpath, uid, gid, cb) => {\n  fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, er => {\n    // Skip ENOENT error\n    cb(er && er.code !== 'ENOENT' ? er : null)\n  }))\n}\n\nconst chownrKid = (p, child, uid, gid, cb) => {\n  if (typeof child === 'string')\n    return fs.lstat(path.resolve(p, child), (er, stats) => {\n      // Skip ENOENT error\n      if (er)\n        return cb(er.code !== 'ENOENT' ? er : null)\n      stats.name = child\n      chownrKid(p, stats, uid, gid, cb)\n    })\n\n  if (child.isDirectory()) {\n    chownr(path.resolve(p, child.name), uid, gid, er => {\n      if (er)\n        return cb(er)\n      const cpath = path.resolve(p, child.name)\n      chown(cpath, uid, gid, cb)\n    })\n  } else {\n    const cpath = path.resolve(p, child.name)\n    chown(cpath, uid, gid, cb)\n  }\n}\n\n\nconst chownr = (p, uid, gid, cb) => {\n  readdir(p, { withFileTypes: true }, (er, children) => {\n    // any error other than ENOTDIR or ENOTSUP means it's not readable,\n    // or doesn't exist.  give up.\n    if (er) {\n      if (er.code === 'ENOENT')\n        return cb()\n      else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n        return cb(er)\n    }\n    if (er || !children.length)\n      return chown(p, uid, gid, cb)\n\n    let len = children.length\n    let errState = null\n    const then = er => {\n      if (errState)\n        return\n      if (er)\n        return cb(errState = er)\n      if (-- len === 0)\n        return chown(p, uid, gid, cb)\n    }\n\n    children.forEach(child => chownrKid(p, child, uid, gid, then))\n  })\n}\n\nconst chownrKidSync = (p, child, uid, gid) => {\n  if (typeof child === 'string') {\n    try {\n      const stats = fs.lstatSync(path.resolve(p, child))\n      stats.name = child\n      child = stats\n    } catch (er) {\n      if (er.code === 'ENOENT')\n        return\n      else\n        throw er\n    }\n  }\n\n  if (child.isDirectory())\n    chownrSync(path.resolve(p, child.name), uid, gid)\n\n  handleEISDirSync(path.resolve(p, child.name), uid, gid)\n}\n\nconst chownrSync = (p, uid, gid) => {\n  let children\n  try {\n    children = readdirSync(p, { withFileTypes: true })\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return\n    else if (er.code === 'ENOTDIR' || er.code === 'ENOTSUP')\n      return handleEISDirSync(p, uid, gid)\n    else\n      throw er\n  }\n\n  if (children && children.length)\n    children.forEach(child => chownrKidSync(p, child, uid, gid))\n\n  return handleEISDirSync(p, uid, gid)\n}\n\nmodule.exports = chownr\nchownr.sync = chownrSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY2hvd25yL2Nob3duci5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBLGVBQWUscUJBQXFCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy9jaG93bnIvY2hvd25yLmpzPzlhOGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IExDSE9XTiA9IGZzLmxjaG93biA/ICdsY2hvd24nIDogJ2Nob3duJ1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IExDSE9XTlNZTkMgPSBmcy5sY2hvd25TeW5jID8gJ2xjaG93blN5bmMnIDogJ2Nob3duU3luYydcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IG5lZWRFSVNESVJIYW5kbGVkID0gZnMubGNob3duICYmXG4gICFwcm9jZXNzLnZlcnNpb24ubWF0Y2goL3YxWzEtOV0rXFwuLykgJiZcbiAgIXByb2Nlc3MudmVyc2lvbi5tYXRjaCgvdjEwXFwuWzYtOV0vKVxuXG5jb25zdCBsY2hvd25TeW5jID0gKHBhdGgsIHVpZCwgZ2lkKSA9PiB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZzW0xDSE9XTlNZTkNdKHBhdGgsIHVpZCwgZ2lkKVxuICB9IGNhdGNoIChlcikge1xuICAgIGlmIChlci5jb2RlICE9PSAnRU5PRU5UJylcbiAgICAgIHRocm93IGVyXG4gIH1cbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IGNob3duU3luYyA9IChwYXRoLCB1aWQsIGdpZCkgPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBmcy5jaG93blN5bmMocGF0aCwgdWlkLCBnaWQpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgIT09ICdFTk9FTlQnKVxuICAgICAgdGhyb3cgZXJcbiAgfVxufVxuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuY29uc3QgaGFuZGxlRUlTRElSID1cbiAgbmVlZEVJU0RJUkhhbmRsZWQgPyAocGF0aCwgdWlkLCBnaWQsIGNiKSA9PiBlciA9PiB7XG4gICAgLy8gTm9kZSBwcmlvciB0byB2MTAgaGFkIGEgdmVyeSBxdWVzdGlvbmFibGUgaW1wbGVtZW50YXRpb24gb2ZcbiAgICAvLyBmcy5sY2hvd24sIHdoaWNoIHdvdWxkIGFsd2F5cyB0cnkgdG8gY2FsbCBmcy5vcGVuIG9uIGEgZGlyZWN0b3J5XG4gICAgLy8gRmFsbCBiYWNrIHRvIGZzLmNob3duIGluIHRob3NlIGNhc2VzLlxuICAgIGlmICghZXIgfHwgZXIuY29kZSAhPT0gJ0VJU0RJUicpXG4gICAgICBjYihlcilcbiAgICBlbHNlXG4gICAgICBmcy5jaG93bihwYXRoLCB1aWQsIGdpZCwgY2IpXG4gIH1cbiAgOiAoXywgX18sIF9fXywgY2IpID0+IGNiXG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCBoYW5kbGVFSVNEaXJTeW5jID1cbiAgbmVlZEVJU0RJUkhhbmRsZWQgPyAocGF0aCwgdWlkLCBnaWQpID0+IHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGxjaG93blN5bmMocGF0aCwgdWlkLCBnaWQpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGlmIChlci5jb2RlICE9PSAnRUlTRElSJylcbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIGNob3duU3luYyhwYXRoLCB1aWQsIGdpZClcbiAgICB9XG4gIH1cbiAgOiAocGF0aCwgdWlkLCBnaWQpID0+IGxjaG93blN5bmMocGF0aCwgdWlkLCBnaWQpXG5cbi8vIGZzLnJlYWRkaXIgY291bGQgb25seSBhY2NlcHQgYW4gb3B0aW9ucyBvYmplY3QgYXMgb2Ygbm9kZSB2NlxuY29uc3Qgbm9kZVZlcnNpb24gPSBwcm9jZXNzLnZlcnNpb25cbmxldCByZWFkZGlyID0gKHBhdGgsIG9wdGlvbnMsIGNiKSA9PiBmcy5yZWFkZGlyKHBhdGgsIG9wdGlvbnMsIGNiKVxubGV0IHJlYWRkaXJTeW5jID0gKHBhdGgsIG9wdGlvbnMpID0+IGZzLnJlYWRkaXJTeW5jKHBhdGgsIG9wdGlvbnMpXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuaWYgKC9edjRcXC4vLnRlc3Qobm9kZVZlcnNpb24pKVxuICByZWFkZGlyID0gKHBhdGgsIG9wdGlvbnMsIGNiKSA9PiBmcy5yZWFkZGlyKHBhdGgsIGNiKVxuXG5jb25zdCBjaG93biA9IChjcGF0aCwgdWlkLCBnaWQsIGNiKSA9PiB7XG4gIGZzW0xDSE9XTl0oY3BhdGgsIHVpZCwgZ2lkLCBoYW5kbGVFSVNESVIoY3BhdGgsIHVpZCwgZ2lkLCBlciA9PiB7XG4gICAgLy8gU2tpcCBFTk9FTlQgZXJyb3JcbiAgICBjYihlciAmJiBlci5jb2RlICE9PSAnRU5PRU5UJyA/IGVyIDogbnVsbClcbiAgfSkpXG59XG5cbmNvbnN0IGNob3ducktpZCA9IChwLCBjaGlsZCwgdWlkLCBnaWQsIGNiKSA9PiB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKVxuICAgIHJldHVybiBmcy5sc3RhdChwYXRoLnJlc29sdmUocCwgY2hpbGQpLCAoZXIsIHN0YXRzKSA9PiB7XG4gICAgICAvLyBTa2lwIEVOT0VOVCBlcnJvclxuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gY2IoZXIuY29kZSAhPT0gJ0VOT0VOVCcgPyBlciA6IG51bGwpXG4gICAgICBzdGF0cy5uYW1lID0gY2hpbGRcbiAgICAgIGNob3ducktpZChwLCBzdGF0cywgdWlkLCBnaWQsIGNiKVxuICAgIH0pXG5cbiAgaWYgKGNoaWxkLmlzRGlyZWN0b3J5KCkpIHtcbiAgICBjaG93bnIocGF0aC5yZXNvbHZlKHAsIGNoaWxkLm5hbWUpLCB1aWQsIGdpZCwgZXIgPT4ge1xuICAgICAgaWYgKGVyKVxuICAgICAgICByZXR1cm4gY2IoZXIpXG4gICAgICBjb25zdCBjcGF0aCA9IHBhdGgucmVzb2x2ZShwLCBjaGlsZC5uYW1lKVxuICAgICAgY2hvd24oY3BhdGgsIHVpZCwgZ2lkLCBjYilcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNwYXRoID0gcGF0aC5yZXNvbHZlKHAsIGNoaWxkLm5hbWUpXG4gICAgY2hvd24oY3BhdGgsIHVpZCwgZ2lkLCBjYilcbiAgfVxufVxuXG5cbmNvbnN0IGNob3duciA9IChwLCB1aWQsIGdpZCwgY2IpID0+IHtcbiAgcmVhZGRpcihwLCB7IHdpdGhGaWxlVHlwZXM6IHRydWUgfSwgKGVyLCBjaGlsZHJlbikgPT4ge1xuICAgIC8vIGFueSBlcnJvciBvdGhlciB0aGFuIEVOT1RESVIgb3IgRU5PVFNVUCBtZWFucyBpdCdzIG5vdCByZWFkYWJsZSxcbiAgICAvLyBvciBkb2Vzbid0IGV4aXN0LiAgZ2l2ZSB1cC5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGlmIChlci5jb2RlID09PSAnRU5PRU5UJylcbiAgICAgICAgcmV0dXJuIGNiKClcbiAgICAgIGVsc2UgaWYgKGVyLmNvZGUgIT09ICdFTk9URElSJyAmJiBlci5jb2RlICE9PSAnRU5PVFNVUCcpXG4gICAgICAgIHJldHVybiBjYihlcilcbiAgICB9XG4gICAgaWYgKGVyIHx8ICFjaGlsZHJlbi5sZW5ndGgpXG4gICAgICByZXR1cm4gY2hvd24ocCwgdWlkLCBnaWQsIGNiKVxuXG4gICAgbGV0IGxlbiA9IGNoaWxkcmVuLmxlbmd0aFxuICAgIGxldCBlcnJTdGF0ZSA9IG51bGxcbiAgICBjb25zdCB0aGVuID0gZXIgPT4ge1xuICAgICAgaWYgKGVyclN0YXRlKVxuICAgICAgICByZXR1cm5cbiAgICAgIGlmIChlcilcbiAgICAgICAgcmV0dXJuIGNiKGVyclN0YXRlID0gZXIpXG4gICAgICBpZiAoLS0gbGVuID09PSAwKVxuICAgICAgICByZXR1cm4gY2hvd24ocCwgdWlkLCBnaWQsIGNiKVxuICAgIH1cblxuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hvd25yS2lkKHAsIGNoaWxkLCB1aWQsIGdpZCwgdGhlbikpXG4gIH0pXG59XG5cbmNvbnN0IGNob3ducktpZFN5bmMgPSAocCwgY2hpbGQsIHVpZCwgZ2lkKSA9PiB7XG4gIGlmICh0eXBlb2YgY2hpbGQgPT09ICdzdHJpbmcnKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHN0YXRzID0gZnMubHN0YXRTeW5jKHBhdGgucmVzb2x2ZShwLCBjaGlsZCkpXG4gICAgICBzdGF0cy5uYW1lID0gY2hpbGRcbiAgICAgIGNoaWxkID0gc3RhdHNcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgICByZXR1cm5cbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgZXJcbiAgICB9XG4gIH1cblxuICBpZiAoY2hpbGQuaXNEaXJlY3RvcnkoKSlcbiAgICBjaG93bnJTeW5jKHBhdGgucmVzb2x2ZShwLCBjaGlsZC5uYW1lKSwgdWlkLCBnaWQpXG5cbiAgaGFuZGxlRUlTRGlyU3luYyhwYXRoLnJlc29sdmUocCwgY2hpbGQubmFtZSksIHVpZCwgZ2lkKVxufVxuXG5jb25zdCBjaG93bnJTeW5jID0gKHAsIHVpZCwgZ2lkKSA9PiB7XG4gIGxldCBjaGlsZHJlblxuICB0cnkge1xuICAgIGNoaWxkcmVuID0gcmVhZGRpclN5bmMocCwgeyB3aXRoRmlsZVR5cGVzOiB0cnVlIH0pXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgcmV0dXJuXG4gICAgZWxzZSBpZiAoZXIuY29kZSA9PT0gJ0VOT1RESVInIHx8IGVyLmNvZGUgPT09ICdFTk9UU1VQJylcbiAgICAgIHJldHVybiBoYW5kbGVFSVNEaXJTeW5jKHAsIHVpZCwgZ2lkKVxuICAgIGVsc2VcbiAgICAgIHRocm93IGVyXG4gIH1cblxuICBpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoKVxuICAgIGNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4gY2hvd25yS2lkU3luYyhwLCBjaGlsZCwgdWlkLCBnaWQpKVxuXG4gIHJldHVybiBoYW5kbGVFSVNEaXJTeW5jKHAsIHVpZCwgZ2lkKVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNob3duclxuY2hvd25yLnN5bmMgPSBjaG93bnJTeW5jXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/chownr/chownr.js\n");

/***/ }),

/***/ "./node_modules/fs-minipass/index.js":
/*!*******************************************!*\
  !*** ./node_modules/fs-minipass/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst MiniPass = __webpack_require__(/*! minipass */ \"./node_modules/fs-minipass/node_modules/minipass/index.js\")\nconst EE = (__webpack_require__(/*! events */ \"events\").EventEmitter)\nconst fs = __webpack_require__(/*! fs */ \"fs\")\n\nlet writev = fs.writev\n/* istanbul ignore next */\nif (!writev) {\n  // This entire block can be removed if support for earlier than Node.js\n  // 12.9.0 is not needed.\n  const binding = process.binding('fs')\n  const FSReqWrap = binding.FSReqWrap || binding.FSReqCallback\n\n  writev = (fd, iovec, pos, cb) => {\n    const done = (er, bw) => cb(er, bw, iovec)\n    const req = new FSReqWrap()\n    req.oncomplete = done\n    binding.writeBuffers(fd, iovec, pos, req)\n  }\n}\n\nconst _autoClose = Symbol('_autoClose')\nconst _close = Symbol('_close')\nconst _ended = Symbol('_ended')\nconst _fd = Symbol('_fd')\nconst _finished = Symbol('_finished')\nconst _flags = Symbol('_flags')\nconst _flush = Symbol('_flush')\nconst _handleChunk = Symbol('_handleChunk')\nconst _makeBuf = Symbol('_makeBuf')\nconst _mode = Symbol('_mode')\nconst _needDrain = Symbol('_needDrain')\nconst _onerror = Symbol('_onerror')\nconst _onopen = Symbol('_onopen')\nconst _onread = Symbol('_onread')\nconst _onwrite = Symbol('_onwrite')\nconst _open = Symbol('_open')\nconst _path = Symbol('_path')\nconst _pos = Symbol('_pos')\nconst _queue = Symbol('_queue')\nconst _read = Symbol('_read')\nconst _readSize = Symbol('_readSize')\nconst _reading = Symbol('_reading')\nconst _remain = Symbol('_remain')\nconst _size = Symbol('_size')\nconst _write = Symbol('_write')\nconst _writing = Symbol('_writing')\nconst _defaultFlag = Symbol('_defaultFlag')\nconst _errored = Symbol('_errored')\n\nclass ReadStream extends MiniPass {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.readable = true\n    this.writable = false\n\n    if (typeof path !== 'string')\n      throw new TypeError('path must be a string')\n\n    this[_errored] = false\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_path] = path\n    this[_readSize] = opt.readSize || 16*1024*1024\n    this[_reading] = false\n    this[_size] = typeof opt.size === 'number' ? opt.size : Infinity\n    this[_remain] = this[_size]\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    if (typeof this[_fd] === 'number')\n      this[_read]()\n    else\n      this[_open]()\n  }\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  write () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  end () {\n    throw new TypeError('this is a readable stream')\n  }\n\n  [_open] () {\n    fs.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_read]()\n    }\n  }\n\n  [_makeBuf] () {\n    return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]))\n  }\n\n  [_read] () {\n    if (!this[_reading]) {\n      this[_reading] = true\n      const buf = this[_makeBuf]()\n      /* istanbul ignore if */\n      if (buf.length === 0)\n        return process.nextTick(() => this[_onread](null, 0, buf))\n      fs.read(this[_fd], buf, 0, buf.length, null, (er, br, buf) =>\n        this[_onread](er, br, buf))\n    }\n  }\n\n  [_onread] (er, br, buf) {\n    this[_reading] = false\n    if (er)\n      this[_onerror](er)\n    else if (this[_handleChunk](br, buf))\n      this[_read]()\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n\n  [_onerror] (er) {\n    this[_reading] = true\n    this[_close]()\n    this.emit('error', er)\n  }\n\n  [_handleChunk] (br, buf) {\n    let ret = false\n    // no effect if infinite\n    this[_remain] -= br\n    if (br > 0)\n      ret = super.write(br < buf.length ? buf.slice(0, br) : buf)\n\n    if (br === 0 || this[_remain] <= 0) {\n      ret = false\n      this[_close]()\n      super.end()\n    }\n\n    return ret\n  }\n\n  emit (ev, data) {\n    switch (ev) {\n      case 'prefinish':\n      case 'finish':\n        break\n\n      case 'drain':\n        if (typeof this[_fd] === 'number')\n          this[_read]()\n        break\n\n      case 'error':\n        if (this[_errored])\n          return\n        this[_errored] = true\n        return super.emit(ev, data)\n\n      default:\n        return super.emit(ev, data)\n    }\n  }\n}\n\nclass ReadStreamSync extends ReadStream {\n  [_open] () {\n    let threw = true\n    try {\n      this[_onopen](null, fs.openSync(this[_path], 'r'))\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_read] () {\n    let threw = true\n    try {\n      if (!this[_reading]) {\n        this[_reading] = true\n        do {\n          const buf = this[_makeBuf]()\n          /* istanbul ignore next */\n          const br = buf.length === 0 ? 0\n            : fs.readSync(this[_fd], buf, 0, buf.length, null)\n          if (!this[_handleChunk](br, buf))\n            break\n        } while (true)\n        this[_reading] = false\n      }\n      threw = false\n    } finally {\n      if (threw)\n        this[_close]()\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n}\n\nclass WriteStream extends EE {\n  constructor (path, opt) {\n    opt = opt || {}\n    super(opt)\n    this.readable = false\n    this.writable = true\n    this[_errored] = false\n    this[_writing] = false\n    this[_ended] = false\n    this[_needDrain] = false\n    this[_queue] = []\n    this[_path] = path\n    this[_fd] = typeof opt.fd === 'number' ? opt.fd : null\n    this[_mode] = opt.mode === undefined ? 0o666 : opt.mode\n    this[_pos] = typeof opt.start === 'number' ? opt.start : null\n    this[_autoClose] = typeof opt.autoClose === 'boolean' ?\n      opt.autoClose : true\n\n    // truncating makes no sense when writing into the middle\n    const defaultFlag = this[_pos] !== null ? 'r+' : 'w'\n    this[_defaultFlag] = opt.flags === undefined\n    this[_flags] = this[_defaultFlag] ? defaultFlag : opt.flags\n\n    if (this[_fd] === null)\n      this[_open]()\n  }\n\n  emit (ev, data) {\n    if (ev === 'error') {\n      if (this[_errored])\n        return\n      this[_errored] = true\n    }\n    return super.emit(ev, data)\n  }\n\n\n  get fd () { return this[_fd] }\n  get path () { return this[_path] }\n\n  [_onerror] (er) {\n    this[_close]()\n    this[_writing] = true\n    this.emit('error', er)\n  }\n\n  [_open] () {\n    fs.open(this[_path], this[_flags], this[_mode],\n      (er, fd) => this[_onopen](er, fd))\n  }\n\n  [_onopen] (er, fd) {\n    if (this[_defaultFlag] &&\n        this[_flags] === 'r+' &&\n        er && er.code === 'ENOENT') {\n      this[_flags] = 'w'\n      this[_open]()\n    } else if (er)\n      this[_onerror](er)\n    else {\n      this[_fd] = fd\n      this.emit('open', fd)\n      this[_flush]()\n    }\n  }\n\n  end (buf, enc) {\n    if (buf)\n      this.write(buf, enc)\n\n    this[_ended] = true\n\n    // synthetic after-write logic, where drain/finish live\n    if (!this[_writing] && !this[_queue].length &&\n        typeof this[_fd] === 'number')\n      this[_onwrite](null, 0)\n    return this\n  }\n\n  write (buf, enc) {\n    if (typeof buf === 'string')\n      buf = Buffer.from(buf, enc)\n\n    if (this[_ended]) {\n      this.emit('error', new Error('write() after end()'))\n      return false\n    }\n\n    if (this[_fd] === null || this[_writing] || this[_queue].length) {\n      this[_queue].push(buf)\n      this[_needDrain] = true\n      return false\n    }\n\n    this[_writing] = true\n    this[_write](buf)\n    return true\n  }\n\n  [_write] (buf) {\n    fs.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) =>\n      this[_onwrite](er, bw))\n  }\n\n  [_onwrite] (er, bw) {\n    if (er)\n      this[_onerror](er)\n    else {\n      if (this[_pos] !== null)\n        this[_pos] += bw\n      if (this[_queue].length)\n        this[_flush]()\n      else {\n        this[_writing] = false\n\n        if (this[_ended] && !this[_finished]) {\n          this[_finished] = true\n          this[_close]()\n          this.emit('finish')\n        } else if (this[_needDrain]) {\n          this[_needDrain] = false\n          this.emit('drain')\n        }\n      }\n    }\n  }\n\n  [_flush] () {\n    if (this[_queue].length === 0) {\n      if (this[_ended])\n        this[_onwrite](null, 0)\n    } else if (this[_queue].length === 1)\n      this[_write](this[_queue].pop())\n    else {\n      const iovec = this[_queue]\n      this[_queue] = []\n      writev(this[_fd], iovec, this[_pos],\n        (er, bw) => this[_onwrite](er, bw))\n    }\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.close(fd, er => er ? this.emit('error', er) : this.emit('close'))\n    }\n  }\n}\n\nclass WriteStreamSync extends WriteStream {\n  [_open] () {\n    let fd\n    // only wrap in a try{} block if we know we'll retry, to avoid\n    // the rethrow obscuring the error's source frame in most cases.\n    if (this[_defaultFlag] && this[_flags] === 'r+') {\n      try {\n        fd = fs.openSync(this[_path], this[_flags], this[_mode])\n      } catch (er) {\n        if (er.code === 'ENOENT') {\n          this[_flags] = 'w'\n          return this[_open]()\n        } else\n          throw er\n      }\n    } else\n      fd = fs.openSync(this[_path], this[_flags], this[_mode])\n\n    this[_onopen](null, fd)\n  }\n\n  [_close] () {\n    if (this[_autoClose] && typeof this[_fd] === 'number') {\n      const fd = this[_fd]\n      this[_fd] = null\n      fs.closeSync(fd)\n      this.emit('close')\n    }\n  }\n\n  [_write] (buf) {\n    // throw the original, but try to close if it fails\n    let threw = true\n    try {\n      this[_onwrite](null,\n        fs.writeSync(this[_fd], buf, 0, buf.length, this[_pos]))\n      threw = false\n    } finally {\n      if (threw)\n        try { this[_close]() } catch (_) {}\n    }\n  }\n}\n\nexports.ReadStream = ReadStream\nexports.ReadStreamSync = ReadStreamSync\n\nexports.WriteStream = WriteStream\nexports.WriteStreamSync = WriteStreamSync\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtbWluaXBhc3MvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixpQkFBaUIsbUJBQU8sQ0FBQywyRUFBVTtBQUNuQyxXQUFXLDBEQUE4QjtBQUN6QyxXQUFXLG1CQUFPLENBQUMsY0FBSTs7QUFFdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGNBQWM7QUFDZCxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLGNBQWM7QUFDZCxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsY0FBYyxpQkFBaUI7QUFDL0I7QUFDQTtBQUNBOztBQUVBLGtCQUFrQjtBQUNsQixzQkFBc0I7O0FBRXRCLG1CQUFtQjtBQUNuQix1QkFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL2ZzLW1pbmlwYXNzL2luZGV4LmpzP2Y3MzEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBNaW5pUGFzcyA9IHJlcXVpcmUoJ21pbmlwYXNzJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcblxubGV0IHdyaXRldiA9IGZzLndyaXRldlxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmlmICghd3JpdGV2KSB7XG4gIC8vIFRoaXMgZW50aXJlIGJsb2NrIGNhbiBiZSByZW1vdmVkIGlmIHN1cHBvcnQgZm9yIGVhcmxpZXIgdGhhbiBOb2RlLmpzXG4gIC8vIDEyLjkuMCBpcyBub3QgbmVlZGVkLlxuICBjb25zdCBiaW5kaW5nID0gcHJvY2Vzcy5iaW5kaW5nKCdmcycpXG4gIGNvbnN0IEZTUmVxV3JhcCA9IGJpbmRpbmcuRlNSZXFXcmFwIHx8IGJpbmRpbmcuRlNSZXFDYWxsYmFja1xuXG4gIHdyaXRldiA9IChmZCwgaW92ZWMsIHBvcywgY2IpID0+IHtcbiAgICBjb25zdCBkb25lID0gKGVyLCBidykgPT4gY2IoZXIsIGJ3LCBpb3ZlYylcbiAgICBjb25zdCByZXEgPSBuZXcgRlNSZXFXcmFwKClcbiAgICByZXEub25jb21wbGV0ZSA9IGRvbmVcbiAgICBiaW5kaW5nLndyaXRlQnVmZmVycyhmZCwgaW92ZWMsIHBvcywgcmVxKVxuICB9XG59XG5cbmNvbnN0IF9hdXRvQ2xvc2UgPSBTeW1ib2woJ19hdXRvQ2xvc2UnKVxuY29uc3QgX2Nsb3NlID0gU3ltYm9sKCdfY2xvc2UnKVxuY29uc3QgX2VuZGVkID0gU3ltYm9sKCdfZW5kZWQnKVxuY29uc3QgX2ZkID0gU3ltYm9sKCdfZmQnKVxuY29uc3QgX2ZpbmlzaGVkID0gU3ltYm9sKCdfZmluaXNoZWQnKVxuY29uc3QgX2ZsYWdzID0gU3ltYm9sKCdfZmxhZ3MnKVxuY29uc3QgX2ZsdXNoID0gU3ltYm9sKCdfZmx1c2gnKVxuY29uc3QgX2hhbmRsZUNodW5rID0gU3ltYm9sKCdfaGFuZGxlQ2h1bmsnKVxuY29uc3QgX21ha2VCdWYgPSBTeW1ib2woJ19tYWtlQnVmJylcbmNvbnN0IF9tb2RlID0gU3ltYm9sKCdfbW9kZScpXG5jb25zdCBfbmVlZERyYWluID0gU3ltYm9sKCdfbmVlZERyYWluJylcbmNvbnN0IF9vbmVycm9yID0gU3ltYm9sKCdfb25lcnJvcicpXG5jb25zdCBfb25vcGVuID0gU3ltYm9sKCdfb25vcGVuJylcbmNvbnN0IF9vbnJlYWQgPSBTeW1ib2woJ19vbnJlYWQnKVxuY29uc3QgX29ud3JpdGUgPSBTeW1ib2woJ19vbndyaXRlJylcbmNvbnN0IF9vcGVuID0gU3ltYm9sKCdfb3BlbicpXG5jb25zdCBfcGF0aCA9IFN5bWJvbCgnX3BhdGgnKVxuY29uc3QgX3BvcyA9IFN5bWJvbCgnX3BvcycpXG5jb25zdCBfcXVldWUgPSBTeW1ib2woJ19xdWV1ZScpXG5jb25zdCBfcmVhZCA9IFN5bWJvbCgnX3JlYWQnKVxuY29uc3QgX3JlYWRTaXplID0gU3ltYm9sKCdfcmVhZFNpemUnKVxuY29uc3QgX3JlYWRpbmcgPSBTeW1ib2woJ19yZWFkaW5nJylcbmNvbnN0IF9yZW1haW4gPSBTeW1ib2woJ19yZW1haW4nKVxuY29uc3QgX3NpemUgPSBTeW1ib2woJ19zaXplJylcbmNvbnN0IF93cml0ZSA9IFN5bWJvbCgnX3dyaXRlJylcbmNvbnN0IF93cml0aW5nID0gU3ltYm9sKCdfd3JpdGluZycpXG5jb25zdCBfZGVmYXVsdEZsYWcgPSBTeW1ib2woJ19kZWZhdWx0RmxhZycpXG5jb25zdCBfZXJyb3JlZCA9IFN5bWJvbCgnX2Vycm9yZWQnKVxuXG5jbGFzcyBSZWFkU3RyZWFtIGV4dGVuZHMgTWluaVBhc3Mge1xuICBjb25zdHJ1Y3RvciAocGF0aCwgb3B0KSB7XG4gICAgb3B0ID0gb3B0IHx8IHt9XG4gICAgc3VwZXIob3B0KVxuXG4gICAgdGhpcy5yZWFkYWJsZSA9IHRydWVcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2VcblxuICAgIGlmICh0eXBlb2YgcGF0aCAhPT0gJ3N0cmluZycpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYSBzdHJpbmcnKVxuXG4gICAgdGhpc1tfZXJyb3JlZF0gPSBmYWxzZVxuICAgIHRoaXNbX2ZkXSA9IHR5cGVvZiBvcHQuZmQgPT09ICdudW1iZXInID8gb3B0LmZkIDogbnVsbFxuICAgIHRoaXNbX3BhdGhdID0gcGF0aFxuICAgIHRoaXNbX3JlYWRTaXplXSA9IG9wdC5yZWFkU2l6ZSB8fCAxNioxMDI0KjEwMjRcbiAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlXG4gICAgdGhpc1tfc2l6ZV0gPSB0eXBlb2Ygb3B0LnNpemUgPT09ICdudW1iZXInID8gb3B0LnNpemUgOiBJbmZpbml0eVxuICAgIHRoaXNbX3JlbWFpbl0gPSB0aGlzW19zaXplXVxuICAgIHRoaXNbX2F1dG9DbG9zZV0gPSB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgIG9wdC5hdXRvQ2xvc2UgOiB0cnVlXG5cbiAgICBpZiAodHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpXG4gICAgICB0aGlzW19yZWFkXSgpXG4gICAgZWxzZVxuICAgICAgdGhpc1tfb3Blbl0oKVxuICB9XG5cbiAgZ2V0IGZkICgpIHsgcmV0dXJuIHRoaXNbX2ZkXSB9XG4gIGdldCBwYXRoICgpIHsgcmV0dXJuIHRoaXNbX3BhdGhdIH1cblxuICB3cml0ZSAoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcigndGhpcyBpcyBhIHJlYWRhYmxlIHN0cmVhbScpXG4gIH1cblxuICBlbmQgKCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3RoaXMgaXMgYSByZWFkYWJsZSBzdHJlYW0nKVxuICB9XG5cbiAgW19vcGVuXSAoKSB7XG4gICAgZnMub3Blbih0aGlzW19wYXRoXSwgJ3InLCAoZXIsIGZkKSA9PiB0aGlzW19vbm9wZW5dKGVyLCBmZCkpXG4gIH1cblxuICBbX29ub3Blbl0gKGVyLCBmZCkge1xuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tfZmRdID0gZmRcbiAgICAgIHRoaXMuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgdGhpc1tfcmVhZF0oKVxuICAgIH1cbiAgfVxuXG4gIFtfbWFrZUJ1Zl0gKCkge1xuICAgIHJldHVybiBCdWZmZXIuYWxsb2NVbnNhZmUoTWF0aC5taW4odGhpc1tfcmVhZFNpemVdLCB0aGlzW19yZW1haW5dKSlcbiAgfVxuXG4gIFtfcmVhZF0gKCkge1xuICAgIGlmICghdGhpc1tfcmVhZGluZ10pIHtcbiAgICAgIHRoaXNbX3JlYWRpbmddID0gdHJ1ZVxuICAgICAgY29uc3QgYnVmID0gdGhpc1tfbWFrZUJ1Zl0oKVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soKCkgPT4gdGhpc1tfb25yZWFkXShudWxsLCAwLCBidWYpKVxuICAgICAgZnMucmVhZCh0aGlzW19mZF0sIGJ1ZiwgMCwgYnVmLmxlbmd0aCwgbnVsbCwgKGVyLCBiciwgYnVmKSA9PlxuICAgICAgICB0aGlzW19vbnJlYWRdKGVyLCBiciwgYnVmKSlcbiAgICB9XG4gIH1cblxuICBbX29ucmVhZF0gKGVyLCBiciwgYnVmKSB7XG4gICAgdGhpc1tfcmVhZGluZ10gPSBmYWxzZVxuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2UgaWYgKHRoaXNbX2hhbmRsZUNodW5rXShiciwgYnVmKSlcbiAgICAgIHRoaXNbX3JlYWRdKClcbiAgfVxuXG4gIFtfY2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgZmQgPSB0aGlzW19mZF1cbiAgICAgIHRoaXNbX2ZkXSA9IG51bGxcbiAgICAgIGZzLmNsb3NlKGZkLCBlciA9PiBlciA/IHRoaXMuZW1pdCgnZXJyb3InLCBlcikgOiB0aGlzLmVtaXQoJ2Nsb3NlJykpXG4gICAgfVxuICB9XG5cbiAgW19vbmVycm9yXSAoZXIpIHtcbiAgICB0aGlzW19yZWFkaW5nXSA9IHRydWVcbiAgICB0aGlzW19jbG9zZV0oKVxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgfVxuXG4gIFtfaGFuZGxlQ2h1bmtdIChiciwgYnVmKSB7XG4gICAgbGV0IHJldCA9IGZhbHNlXG4gICAgLy8gbm8gZWZmZWN0IGlmIGluZmluaXRlXG4gICAgdGhpc1tfcmVtYWluXSAtPSBiclxuICAgIGlmIChiciA+IDApXG4gICAgICByZXQgPSBzdXBlci53cml0ZShiciA8IGJ1Zi5sZW5ndGggPyBidWYuc2xpY2UoMCwgYnIpIDogYnVmKVxuXG4gICAgaWYgKGJyID09PSAwIHx8IHRoaXNbX3JlbWFpbl0gPD0gMCkge1xuICAgICAgcmV0ID0gZmFsc2VcbiAgICAgIHRoaXNbX2Nsb3NlXSgpXG4gICAgICBzdXBlci5lbmQoKVxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGVtaXQgKGV2LCBkYXRhKSB7XG4gICAgc3dpdGNoIChldikge1xuICAgICAgY2FzZSAncHJlZmluaXNoJzpcbiAgICAgIGNhc2UgJ2ZpbmlzaCc6XG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ2RyYWluJzpcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzW19mZF0gPT09ICdudW1iZXInKVxuICAgICAgICAgIHRoaXNbX3JlYWRdKClcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnZXJyb3InOlxuICAgICAgICBpZiAodGhpc1tfZXJyb3JlZF0pXG4gICAgICAgICAgcmV0dXJuXG4gICAgICAgIHRoaXNbX2Vycm9yZWRdID0gdHJ1ZVxuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgZGF0YSlcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIGRhdGEpXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFJlYWRTdHJlYW1TeW5jIGV4dGVuZHMgUmVhZFN0cmVhbSB7XG4gIFtfb3Blbl0gKCkge1xuICAgIGxldCB0aHJldyA9IHRydWVcbiAgICB0cnkge1xuICAgICAgdGhpc1tfb25vcGVuXShudWxsLCBmcy5vcGVuU3luYyh0aGlzW19wYXRoXSwgJ3InKSlcbiAgICAgIHRocmV3ID0gZmFsc2VcbiAgICB9IGZpbmFsbHkge1xuICAgICAgaWYgKHRocmV3KVxuICAgICAgICB0aGlzW19jbG9zZV0oKVxuICAgIH1cbiAgfVxuXG4gIFtfcmVhZF0gKCkge1xuICAgIGxldCB0aHJldyA9IHRydWVcbiAgICB0cnkge1xuICAgICAgaWYgKCF0aGlzW19yZWFkaW5nXSkge1xuICAgICAgICB0aGlzW19yZWFkaW5nXSA9IHRydWVcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGNvbnN0IGJ1ZiA9IHRoaXNbX21ha2VCdWZdKClcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICAgICAgICAgIGNvbnN0IGJyID0gYnVmLmxlbmd0aCA9PT0gMCA/IDBcbiAgICAgICAgICAgIDogZnMucmVhZFN5bmModGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIG51bGwpXG4gICAgICAgICAgaWYgKCF0aGlzW19oYW5kbGVDaHVua10oYnIsIGJ1ZikpXG4gICAgICAgICAgICBicmVha1xuICAgICAgICB9IHdoaWxlICh0cnVlKVxuICAgICAgICB0aGlzW19yZWFkaW5nXSA9IGZhbHNlXG4gICAgICB9XG4gICAgICB0aHJldyA9IGZhbHNlXG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmICh0aHJldylcbiAgICAgICAgdGhpc1tfY2xvc2VdKClcbiAgICB9XG4gIH1cblxuICBbX2Nsb3NlXSAoKSB7XG4gICAgaWYgKHRoaXNbX2F1dG9DbG9zZV0gJiYgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IGZkID0gdGhpc1tfZmRdXG4gICAgICB0aGlzW19mZF0gPSBudWxsXG4gICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cbn1cblxuY2xhc3MgV3JpdGVTdHJlYW0gZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChwYXRoLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG4gICAgdGhpcy53cml0YWJsZSA9IHRydWVcbiAgICB0aGlzW19lcnJvcmVkXSA9IGZhbHNlXG4gICAgdGhpc1tfd3JpdGluZ10gPSBmYWxzZVxuICAgIHRoaXNbX2VuZGVkXSA9IGZhbHNlXG4gICAgdGhpc1tfbmVlZERyYWluXSA9IGZhbHNlXG4gICAgdGhpc1tfcXVldWVdID0gW11cbiAgICB0aGlzW19wYXRoXSA9IHBhdGhcbiAgICB0aGlzW19mZF0gPSB0eXBlb2Ygb3B0LmZkID09PSAnbnVtYmVyJyA/IG9wdC5mZCA6IG51bGxcbiAgICB0aGlzW19tb2RlXSA9IG9wdC5tb2RlID09PSB1bmRlZmluZWQgPyAwbzY2NiA6IG9wdC5tb2RlXG4gICAgdGhpc1tfcG9zXSA9IHR5cGVvZiBvcHQuc3RhcnQgPT09ICdudW1iZXInID8gb3B0LnN0YXJ0IDogbnVsbFxuICAgIHRoaXNbX2F1dG9DbG9zZV0gPSB0eXBlb2Ygb3B0LmF1dG9DbG9zZSA9PT0gJ2Jvb2xlYW4nID9cbiAgICAgIG9wdC5hdXRvQ2xvc2UgOiB0cnVlXG5cbiAgICAvLyB0cnVuY2F0aW5nIG1ha2VzIG5vIHNlbnNlIHdoZW4gd3JpdGluZyBpbnRvIHRoZSBtaWRkbGVcbiAgICBjb25zdCBkZWZhdWx0RmxhZyA9IHRoaXNbX3Bvc10gIT09IG51bGwgPyAncisnIDogJ3cnXG4gICAgdGhpc1tfZGVmYXVsdEZsYWddID0gb3B0LmZsYWdzID09PSB1bmRlZmluZWRcbiAgICB0aGlzW19mbGFnc10gPSB0aGlzW19kZWZhdWx0RmxhZ10gPyBkZWZhdWx0RmxhZyA6IG9wdC5mbGFnc1xuXG4gICAgaWYgKHRoaXNbX2ZkXSA9PT0gbnVsbClcbiAgICAgIHRoaXNbX29wZW5dKClcbiAgfVxuXG4gIGVtaXQgKGV2LCBkYXRhKSB7XG4gICAgaWYgKGV2ID09PSAnZXJyb3InKSB7XG4gICAgICBpZiAodGhpc1tfZXJyb3JlZF0pXG4gICAgICAgIHJldHVyblxuICAgICAgdGhpc1tfZXJyb3JlZF0gPSB0cnVlXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCBkYXRhKVxuICB9XG5cblxuICBnZXQgZmQgKCkgeyByZXR1cm4gdGhpc1tfZmRdIH1cbiAgZ2V0IHBhdGggKCkgeyByZXR1cm4gdGhpc1tfcGF0aF0gfVxuXG4gIFtfb25lcnJvcl0gKGVyKSB7XG4gICAgdGhpc1tfY2xvc2VdKClcbiAgICB0aGlzW193cml0aW5nXSA9IHRydWVcbiAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gIH1cblxuICBbX29wZW5dICgpIHtcbiAgICBmcy5vcGVuKHRoaXNbX3BhdGhdLCB0aGlzW19mbGFnc10sIHRoaXNbX21vZGVdLFxuICAgICAgKGVyLCBmZCkgPT4gdGhpc1tfb25vcGVuXShlciwgZmQpKVxuICB9XG5cbiAgW19vbm9wZW5dIChlciwgZmQpIHtcbiAgICBpZiAodGhpc1tfZGVmYXVsdEZsYWddICYmXG4gICAgICAgIHRoaXNbX2ZsYWdzXSA9PT0gJ3IrJyAmJlxuICAgICAgICBlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJykge1xuICAgICAgdGhpc1tfZmxhZ3NdID0gJ3cnXG4gICAgICB0aGlzW19vcGVuXSgpXG4gICAgfSBlbHNlIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tfZmRdID0gZmRcbiAgICAgIHRoaXMuZW1pdCgnb3BlbicsIGZkKVxuICAgICAgdGhpc1tfZmx1c2hdKClcbiAgICB9XG4gIH1cblxuICBlbmQgKGJ1ZiwgZW5jKSB7XG4gICAgaWYgKGJ1ZilcbiAgICAgIHRoaXMud3JpdGUoYnVmLCBlbmMpXG5cbiAgICB0aGlzW19lbmRlZF0gPSB0cnVlXG5cbiAgICAvLyBzeW50aGV0aWMgYWZ0ZXItd3JpdGUgbG9naWMsIHdoZXJlIGRyYWluL2ZpbmlzaCBsaXZlXG4gICAgaWYgKCF0aGlzW193cml0aW5nXSAmJiAhdGhpc1tfcXVldWVdLmxlbmd0aCAmJlxuICAgICAgICB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJylcbiAgICAgIHRoaXNbX29ud3JpdGVdKG51bGwsIDApXG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHdyaXRlIChidWYsIGVuYykge1xuICAgIGlmICh0eXBlb2YgYnVmID09PSAnc3RyaW5nJylcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZiwgZW5jKVxuXG4gICAgaWYgKHRoaXNbX2VuZGVkXSkge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignd3JpdGUoKSBhZnRlciBlbmQoKScpKVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKHRoaXNbX2ZkXSA9PT0gbnVsbCB8fCB0aGlzW193cml0aW5nXSB8fCB0aGlzW19xdWV1ZV0ubGVuZ3RoKSB7XG4gICAgICB0aGlzW19xdWV1ZV0ucHVzaChidWYpXG4gICAgICB0aGlzW19uZWVkRHJhaW5dID0gdHJ1ZVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgdGhpc1tfd3JpdGluZ10gPSB0cnVlXG4gICAgdGhpc1tfd3JpdGVdKGJ1ZilcbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgW193cml0ZV0gKGJ1Zikge1xuICAgIGZzLndyaXRlKHRoaXNbX2ZkXSwgYnVmLCAwLCBidWYubGVuZ3RoLCB0aGlzW19wb3NdLCAoZXIsIGJ3KSA9PlxuICAgICAgdGhpc1tfb253cml0ZV0oZXIsIGJ3KSlcbiAgfVxuXG4gIFtfb253cml0ZV0gKGVyLCBidykge1xuICAgIGlmIChlcilcbiAgICAgIHRoaXNbX29uZXJyb3JdKGVyKVxuICAgIGVsc2Uge1xuICAgICAgaWYgKHRoaXNbX3Bvc10gIT09IG51bGwpXG4gICAgICAgIHRoaXNbX3Bvc10gKz0gYndcbiAgICAgIGlmICh0aGlzW19xdWV1ZV0ubGVuZ3RoKVxuICAgICAgICB0aGlzW19mbHVzaF0oKVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXNbX3dyaXRpbmddID0gZmFsc2VcblxuICAgICAgICBpZiAodGhpc1tfZW5kZWRdICYmICF0aGlzW19maW5pc2hlZF0pIHtcbiAgICAgICAgICB0aGlzW19maW5pc2hlZF0gPSB0cnVlXG4gICAgICAgICAgdGhpc1tfY2xvc2VdKClcbiAgICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICAgIH0gZWxzZSBpZiAodGhpc1tfbmVlZERyYWluXSkge1xuICAgICAgICAgIHRoaXNbX25lZWREcmFpbl0gPSBmYWxzZVxuICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgW19mbHVzaF0gKCkge1xuICAgIGlmICh0aGlzW19xdWV1ZV0ubGVuZ3RoID09PSAwKSB7XG4gICAgICBpZiAodGhpc1tfZW5kZWRdKVxuICAgICAgICB0aGlzW19vbndyaXRlXShudWxsLCAwKVxuICAgIH0gZWxzZSBpZiAodGhpc1tfcXVldWVdLmxlbmd0aCA9PT0gMSlcbiAgICAgIHRoaXNbX3dyaXRlXSh0aGlzW19xdWV1ZV0ucG9wKCkpXG4gICAgZWxzZSB7XG4gICAgICBjb25zdCBpb3ZlYyA9IHRoaXNbX3F1ZXVlXVxuICAgICAgdGhpc1tfcXVldWVdID0gW11cbiAgICAgIHdyaXRldih0aGlzW19mZF0sIGlvdmVjLCB0aGlzW19wb3NdLFxuICAgICAgICAoZXIsIGJ3KSA9PiB0aGlzW19vbndyaXRlXShlciwgYncpKVxuICAgIH1cbiAgfVxuXG4gIFtfY2xvc2VdICgpIHtcbiAgICBpZiAodGhpc1tfYXV0b0Nsb3NlXSAmJiB0eXBlb2YgdGhpc1tfZmRdID09PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgZmQgPSB0aGlzW19mZF1cbiAgICAgIHRoaXNbX2ZkXSA9IG51bGxcbiAgICAgIGZzLmNsb3NlKGZkLCBlciA9PiBlciA/IHRoaXMuZW1pdCgnZXJyb3InLCBlcikgOiB0aGlzLmVtaXQoJ2Nsb3NlJykpXG4gICAgfVxuICB9XG59XG5cbmNsYXNzIFdyaXRlU3RyZWFtU3luYyBleHRlbmRzIFdyaXRlU3RyZWFtIHtcbiAgW19vcGVuXSAoKSB7XG4gICAgbGV0IGZkXG4gICAgLy8gb25seSB3cmFwIGluIGEgdHJ5e30gYmxvY2sgaWYgd2Uga25vdyB3ZSdsbCByZXRyeSwgdG8gYXZvaWRcbiAgICAvLyB0aGUgcmV0aHJvdyBvYnNjdXJpbmcgdGhlIGVycm9yJ3Mgc291cmNlIGZyYW1lIGluIG1vc3QgY2FzZXMuXG4gICAgaWYgKHRoaXNbX2RlZmF1bHRGbGFnXSAmJiB0aGlzW19mbGFnc10gPT09ICdyKycpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZkID0gZnMub3BlblN5bmModGhpc1tfcGF0aF0sIHRoaXNbX2ZsYWdzXSwgdGhpc1tfbW9kZV0pXG4gICAgICB9IGNhdGNoIChlcikge1xuICAgICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgICB0aGlzW19mbGFnc10gPSAndydcbiAgICAgICAgICByZXR1cm4gdGhpc1tfb3Blbl0oKVxuICAgICAgICB9IGVsc2VcbiAgICAgICAgICB0aHJvdyBlclxuICAgICAgfVxuICAgIH0gZWxzZVxuICAgICAgZmQgPSBmcy5vcGVuU3luYyh0aGlzW19wYXRoXSwgdGhpc1tfZmxhZ3NdLCB0aGlzW19tb2RlXSlcblxuICAgIHRoaXNbX29ub3Blbl0obnVsbCwgZmQpXG4gIH1cblxuICBbX2Nsb3NlXSAoKSB7XG4gICAgaWYgKHRoaXNbX2F1dG9DbG9zZV0gJiYgdHlwZW9mIHRoaXNbX2ZkXSA9PT0gJ251bWJlcicpIHtcbiAgICAgIGNvbnN0IGZkID0gdGhpc1tfZmRdXG4gICAgICB0aGlzW19mZF0gPSBudWxsXG4gICAgICBmcy5jbG9zZVN5bmMoZmQpXG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICB9XG4gIH1cblxuICBbX3dyaXRlXSAoYnVmKSB7XG4gICAgLy8gdGhyb3cgdGhlIG9yaWdpbmFsLCBidXQgdHJ5IHRvIGNsb3NlIGlmIGl0IGZhaWxzXG4gICAgbGV0IHRocmV3ID0gdHJ1ZVxuICAgIHRyeSB7XG4gICAgICB0aGlzW19vbndyaXRlXShudWxsLFxuICAgICAgICBmcy53cml0ZVN5bmModGhpc1tfZmRdLCBidWYsIDAsIGJ1Zi5sZW5ndGgsIHRoaXNbX3Bvc10pKVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhyZXcpXG4gICAgICAgIHRyeSB7IHRoaXNbX2Nsb3NlXSgpIH0gY2F0Y2ggKF8pIHt9XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydHMuUmVhZFN0cmVhbSA9IFJlYWRTdHJlYW1cbmV4cG9ydHMuUmVhZFN0cmVhbVN5bmMgPSBSZWFkU3RyZWFtU3luY1xuXG5leHBvcnRzLldyaXRlU3RyZWFtID0gV3JpdGVTdHJlYW1cbmV4cG9ydHMuV3JpdGVTdHJlYW1TeW5jID0gV3JpdGVTdHJlYW1TeW5jXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/fs-minipass/index.js\n");

/***/ }),

/***/ "./node_modules/fs-minipass/node_modules/minipass/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/fs-minipass/node_modules/minipass/index.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null,\n}\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Stream = __webpack_require__(/*! stream */ \"stream\")\nconst SD = (__webpack_require__(/*! string_decoder */ \"string_decoder\").StringDecoder)\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor (src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe () {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors () {}\n  end () {\n    this.unpipe()\n    if (this.opts.end)\n      this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe () {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor (src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = []\n    this.buffer = []\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[ASYNC] = options && !!options.async || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\n\n  get ['async'] () { return this[ASYNC] }\n  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0)\n        this[FLUSH](true)\n\n      if (this.flowing)\n        this.emit('data', chunk)\n      else\n        this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n\n      if (cb)\n        fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0)\n      this[FLUSH](true)\n\n    if (this.flowing)\n      this.emit('data', chunk)\n    else\n      this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0)\n      this.emit('readable')\n\n    if (cb)\n      fn(cb)\n\n    return this.flowing\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE])\n      n = null\n\n    if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding)\n        this.buffer = [this.buffer.join('')]\n      else\n        this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this.buffer[0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer[0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer[0].length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] (noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end)\n        dest.end()\n    } else {\n      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts)\n        : new PipeProxyErrors(this, dest, opts))\n      if (this[ASYNC])\n        defer(() => this[RESUME]())\n      else\n        this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe (dest) {\n    const p = this.pipes.find(p => p.dest === dest)\n    if (p) {\n      this.pipes.splice(this.pipes.indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this.pipes.length && !this.flowing)\n      this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC])\n        defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else\n        fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !data ? false\n        : this[ASYNC] ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      const ret = super.emit('error', data)\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA] (data) {\n    for (const p of this.pipes) {\n      if (p.dest.write(data) === false)\n        this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND] () {\n    if (this[EMITTED_END])\n      return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC])\n      defer(() => this[EMITEND2]())\n    else\n      this[EMITEND2]()\n  }\n\n  [EMITEND2] () {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this.pipes) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this.pipes) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer.length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvZnMtbWluaXBhc3Mvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsc0JBQVE7QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFdBQVcsMkVBQXVDOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsd0JBQXdCOztBQUV4QixxQkFBcUI7QUFDckIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCOztBQUUxRDtBQUNBLGlDQUFpQyxZQUFZOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvZnMtbWluaXBhc3Mvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzPzUwYjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBwcm9jID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MgPyBwcm9jZXNzIDoge1xuICBzdGRvdXQ6IG51bGwsXG4gIHN0ZGVycjogbnVsbCxcbn1cbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuXG5jb25zdCBFT0YgPSBTeW1ib2woJ0VPRicpXG5jb25zdCBNQVlCRV9FTUlUX0VORCA9IFN5bWJvbCgnbWF5YmVFbWl0RW5kJylcbmNvbnN0IEVNSVRURURfRU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJylcbmNvbnN0IEVNSVRUSU5HX0VORCA9IFN5bWJvbCgnZW1pdHRpbmdFbmQnKVxuY29uc3QgRU1JVFRFRF9FUlJPUiA9IFN5bWJvbCgnZW1pdHRlZEVycm9yJylcbmNvbnN0IENMT1NFRCA9IFN5bWJvbCgnY2xvc2VkJylcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKVxuY29uc3QgRkxVU0ggPSBTeW1ib2woJ2ZsdXNoJylcbmNvbnN0IEZMVVNIQ0hVTksgPSBTeW1ib2woJ2ZsdXNoQ2h1bmsnKVxuY29uc3QgRU5DT0RJTkcgPSBTeW1ib2woJ2VuY29kaW5nJylcbmNvbnN0IERFQ09ERVIgPSBTeW1ib2woJ2RlY29kZXInKVxuY29uc3QgRkxPV0lORyA9IFN5bWJvbCgnZmxvd2luZycpXG5jb25zdCBQQVVTRUQgPSBTeW1ib2woJ3BhdXNlZCcpXG5jb25zdCBSRVNVTUUgPSBTeW1ib2woJ3Jlc3VtZScpXG5jb25zdCBCVUZGRVJMRU5HVEggPSBTeW1ib2woJ2J1ZmZlckxlbmd0aCcpXG5jb25zdCBCVUZGRVJQVVNIID0gU3ltYm9sKCdidWZmZXJQdXNoJylcbmNvbnN0IEJVRkZFUlNISUZUID0gU3ltYm9sKCdidWZmZXJTaGlmdCcpXG5jb25zdCBPQkpFQ1RNT0RFID0gU3ltYm9sKCdvYmplY3RNb2RlJylcbmNvbnN0IERFU1RST1lFRCA9IFN5bWJvbCgnZGVzdHJveWVkJylcbmNvbnN0IEVNSVREQVRBID0gU3ltYm9sKCdlbWl0RGF0YScpXG5jb25zdCBFTUlURU5EID0gU3ltYm9sKCdlbWl0RW5kJylcbmNvbnN0IEVNSVRFTkQyID0gU3ltYm9sKCdlbWl0RW5kMicpXG5jb25zdCBBU1lOQyA9IFN5bWJvbCgnYXN5bmMnKVxuXG5jb25zdCBkZWZlciA9IGZuID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pXG5cbi8vIFRPRE8gcmVtb3ZlIHdoZW4gTm9kZSB2OCBzdXBwb3J0IGRyb3BzXG5jb25zdCBkb0l0ZXIgPSBnbG9iYWwuX01QX05PX0lURVJBVE9SX1NZTUJPTFNfICAhPT0gJzEnXG5jb25zdCBBU1lOQ0lURVJBVE9SID0gZG9JdGVyICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yXG4gIHx8IFN5bWJvbCgnYXN5bmNJdGVyYXRvciBub3QgaW1wbGVtZW50ZWQnKVxuY29uc3QgSVRFUkFUT1IgPSBkb0l0ZXIgJiYgU3ltYm9sLml0ZXJhdG9yXG4gIHx8IFN5bWJvbCgnaXRlcmF0b3Igbm90IGltcGxlbWVudGVkJylcblxuLy8gZXZlbnRzIHRoYXQgbWVhbiAndGhlIHN0cmVhbSBpcyBvdmVyJ1xuLy8gdGhlc2UgYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBhbmQgcmUtZW1pdHRlZFxuLy8gaWYgdGhleSBhcmUgbGlzdGVuZWQgZm9yIGFmdGVyIGVtaXR0aW5nLlxuY29uc3QgaXNFbmRpc2ggPSBldiA9PlxuICBldiA9PT0gJ2VuZCcgfHxcbiAgZXYgPT09ICdmaW5pc2gnIHx8XG4gIGV2ID09PSAncHJlZmluaXNoJ1xuXG5jb25zdCBpc0FycmF5QnVmZmVyID0gYiA9PiBiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmXG4gIGIuY29uc3RydWN0b3IgJiZcbiAgYi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gIGIuYnl0ZUxlbmd0aCA+PSAwXG5cbmNvbnN0IGlzQXJyYXlCdWZmZXJWaWV3ID0gYiA9PiAhQnVmZmVyLmlzQnVmZmVyKGIpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKVxuXG5jbGFzcyBQaXBlIHtcbiAgY29uc3RydWN0b3IgKHNyYywgZGVzdCwgb3B0cykge1xuICAgIHRoaXMuc3JjID0gc3JjXG4gICAgdGhpcy5kZXN0ID0gZGVzdFxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLm9uZHJhaW4gPSAoKSA9PiBzcmNbUkVTVU1FXSgpXG4gICAgZGVzdC5vbignZHJhaW4nLCB0aGlzLm9uZHJhaW4pXG4gIH1cbiAgdW5waXBlICgpIHtcbiAgICB0aGlzLmRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgdGhpcy5vbmRyYWluKVxuICB9XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gb25seSBoZXJlIGZvciB0aGUgcHJvdG90eXBlXG4gIHByb3h5RXJyb3JzICgpIHt9XG4gIGVuZCAoKSB7XG4gICAgdGhpcy51bnBpcGUoKVxuICAgIGlmICh0aGlzLm9wdHMuZW5kKVxuICAgICAgdGhpcy5kZXN0LmVuZCgpXG4gIH1cbn1cblxuY2xhc3MgUGlwZVByb3h5RXJyb3JzIGV4dGVuZHMgUGlwZSB7XG4gIHVucGlwZSAoKSB7XG4gICAgdGhpcy5zcmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycylcbiAgICBzdXBlci51bnBpcGUoKVxuICB9XG4gIGNvbnN0cnVjdG9yIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgICBzdXBlcihzcmMsIGRlc3QsIG9wdHMpXG4gICAgdGhpcy5wcm94eUVycm9ycyA9IGVyID0+IGRlc3QuZW1pdCgnZXJyb3InLCBlcilcbiAgICBzcmMub24oJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1pbmlwYXNzIGV4dGVuZHMgU3RyZWFtIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgLy8gd2hldGhlciB3ZSdyZSBleHBsaWNpdGx5IHBhdXNlZFxuICAgIHRoaXNbUEFVU0VEXSA9IGZhbHNlXG4gICAgdGhpcy5waXBlcyA9IFtdXG4gICAgdGhpcy5idWZmZXIgPSBbXVxuICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBvcHRpb25zICYmIG9wdGlvbnMub2JqZWN0TW9kZSB8fCBmYWxzZVxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsXG4gICAgZWxzZVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgfHwgbnVsbFxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSA9PT0gJ2J1ZmZlcicpXG4gICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGxcbiAgICB0aGlzW0FTWU5DXSA9IG9wdGlvbnMgJiYgISFvcHRpb25zLmFzeW5jIHx8IGZhbHNlXG4gICAgdGhpc1tERUNPREVSXSA9IHRoaXNbRU5DT0RJTkddID8gbmV3IFNEKHRoaXNbRU5DT0RJTkddKSA6IG51bGxcbiAgICB0aGlzW0VPRl0gPSBmYWxzZVxuICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gZmFsc2VcbiAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSBmYWxzZVxuICAgIHRoaXNbQ0xPU0VEXSA9IGZhbHNlXG4gICAgdGhpc1tFTUlUVEVEX0VSUk9SXSA9IG51bGxcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gICAgdGhpc1tCVUZGRVJMRU5HVEhdID0gMFxuICAgIHRoaXNbREVTVFJPWUVEXSA9IGZhbHNlXG4gIH1cblxuICBnZXQgYnVmZmVyTGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbQlVGRkVSTEVOR1RIXSB9XG5cbiAgZ2V0IGVuY29kaW5nICgpIHsgcmV0dXJuIHRoaXNbRU5DT0RJTkddIH1cbiAgc2V0IGVuY29kaW5nIChlbmMpIHtcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBlbmNvZGluZyBpbiBvYmplY3RNb2RlJylcblxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSAmJiBlbmMgIT09IHRoaXNbRU5DT0RJTkddICYmXG4gICAgICAgICh0aGlzW0RFQ09ERVJdICYmIHRoaXNbREVDT0RFUl0ubGFzdE5lZWQgfHwgdGhpc1tCVUZGRVJMRU5HVEhdKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNoYW5nZSBlbmNvZGluZycpXG5cbiAgICBpZiAodGhpc1tFTkNPRElOR10gIT09IGVuYykge1xuICAgICAgdGhpc1tERUNPREVSXSA9IGVuYyA/IG5ldyBTRChlbmMpIDogbnVsbFxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5tYXAoY2h1bmsgPT4gdGhpc1tERUNPREVSXS53cml0ZShjaHVuaykpXG4gICAgfVxuXG4gICAgdGhpc1tFTkNPRElOR10gPSBlbmNcbiAgfVxuXG4gIHNldEVuY29kaW5nIChlbmMpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jXG4gIH1cblxuICBnZXQgb2JqZWN0TW9kZSAoKSB7IHJldHVybiB0aGlzW09CSkVDVE1PREVdIH1cbiAgc2V0IG9iamVjdE1vZGUgKG9tKSB7IHRoaXNbT0JKRUNUTU9ERV0gPSB0aGlzW09CSkVDVE1PREVdIHx8ICEhb20gfVxuXG4gIGdldCBbJ2FzeW5jJ10gKCkgeyByZXR1cm4gdGhpc1tBU1lOQ10gfVxuICBzZXQgWydhc3luYyddIChhKSB7IHRoaXNbQVNZTkNdID0gdGhpc1tBU1lOQ10gfHwgISFhIH1cblxuICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpXG5cbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCB3cml0ZSBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJyksXG4gICAgICAgIHsgY29kZTogJ0VSUl9TVFJFQU1fREVTVFJPWUVEJyB9XG4gICAgICApKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBlbmNvZGluZywgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIGlmICghZW5jb2RpbmcpXG4gICAgICBlbmNvZGluZyA9ICd1dGY4J1xuXG4gICAgY29uc3QgZm4gPSB0aGlzW0FTWU5DXSA/IGRlZmVyIDogZiA9PiBmKClcblxuICAgIC8vIGNvbnZlcnQgYXJyYXkgYnVmZmVycyBhbmQgdHlwZWQgYXJyYXkgdmlld3MgaW50byBidWZmZXJzXG4gICAgLy8gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCB3ZSBtYXkgd2FudCB0byBkbyB0aGUgb3Bwb3NpdGUhXG4gICAgLy8gbGVhdmUgc3RyaW5ncyBhbmQgYnVmZmVycyBhcy1pc1xuICAgIC8vIGFueXRoaW5nIGVsc2Ugc3dpdGNoZXMgdXMgaW50byBvYmplY3QgbW9kZVxuICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpXG4gICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaylcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpXG4gICAgICAgIC8vIHVzZSB0aGUgc2V0dGVyIHNvIHdlIHRocm93IGlmIHdlIGhhdmUgZW5jb2Rpbmcgc2V0XG4gICAgICAgIHRoaXMub2JqZWN0TW9kZSA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgb2JqZWN0IG1vZGUgdXAgZnJvbnQsIHNpbmNlIGl0J3Mgc2ltcGxlclxuICAgIC8vIHRoaXMgeWllbGRzIGJldHRlciBwZXJmb3JtYW5jZSwgZmV3ZXIgY2hlY2tzIGxhdGVyLlxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLSBtYXliZSBpbXBvc3NpYmxlPyAqL1xuICAgICAgaWYgKHRoaXMuZmxvd2luZyAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXNbRkxVU0hdKHRydWUpXG5cbiAgICAgIGlmICh0aGlzLmZsb3dpbmcpXG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW0JVRkZFUlBVU0hdKGNodW5rKVxuXG4gICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcblxuICAgICAgaWYgKGNiKVxuICAgICAgICBmbihjYilcblxuICAgICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGNodW5rIGlzIGEgYnVmZmVyIG9yIHN0cmluZ1xuICAgIC8vIGRvbid0IGJ1ZmZlciBpdCB1cCBvciBzZW5kIGl0IHRvIHRoZSBkZWNvZGVyXG4gICAgaWYgKCFjaHVuay5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKVxuICAgICAgaWYgKGNiKVxuICAgICAgICBmbihjYilcbiAgICAgIHJldHVybiB0aGlzLmZsb3dpbmdcbiAgICB9XG5cbiAgICAvLyBmYXN0LXBhdGggd3JpdGluZyBzdHJpbmdzIG9mIHNhbWUgZW5jb2RpbmcgdG8gYSBzdHJlYW0gd2l0aFxuICAgIC8vIGFuIGVtcHR5IGJ1ZmZlciwgc2tpcHBpbmcgdGhlIGJ1ZmZlci9kZWNvZGVyIGRhbmNlXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgc3RyaW5nIGFscmVhZHkgcmVhZHkgZm9yIHVzIHRvIHVzZVxuICAgICAgICAhKGVuY29kaW5nID09PSB0aGlzW0VOQ09ESU5HXSAmJiAhdGhpc1tERUNPREVSXS5sYXN0TmVlZCkpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgIH1cblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHRoaXNbRU5DT0RJTkddKVxuICAgICAgY2h1bmsgPSB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKVxuXG4gICAgLy8gTm90ZTogZmx1c2hpbmcgQ0FOIHBvdGVudGlhbGx5IHN3aXRjaCB1cyBpbnRvIG5vdC1mbG93aW5nIG1vZGVcbiAgICBpZiAodGhpcy5mbG93aW5nICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgIHRoaXNbRkxVU0hdKHRydWUpXG5cbiAgICBpZiAodGhpcy5mbG93aW5nKVxuICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspXG4gICAgZWxzZVxuICAgICAgdGhpc1tCVUZGRVJQVVNIXShjaHVuaylcblxuICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcblxuICAgIGlmIChjYilcbiAgICAgIGZuKGNiKVxuXG4gICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICB9XG5cbiAgcmVhZCAobikge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSA9PT0gMCB8fCBuID09PSAwIHx8IG4gPiB0aGlzW0JVRkZFUkxFTkdUSF0pIHtcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICBuID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDEgJiYgIXRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgIGlmICh0aGlzLmVuY29kaW5nKVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKV1cbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZmZlciwgdGhpc1tCVUZGRVJMRU5HVEhdKV1cbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSB0aGlzW1JFQURdKG4gfHwgbnVsbCwgdGhpcy5idWZmZXJbMF0pXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtSRUFEXSAobiwgY2h1bmspIHtcbiAgICBpZiAobiA9PT0gY2h1bmsubGVuZ3RoIHx8IG4gPT09IG51bGwpXG4gICAgICB0aGlzW0JVRkZFUlNISUZUXSgpXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlclswXSA9IGNodW5rLnNsaWNlKG4pXG4gICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIG4pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gblxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuXG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuXG4gICAgcmV0dXJuIGNodW5rXG4gIH1cblxuICBlbmQgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBjaHVuaywgY2h1bmsgPSBudWxsXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gZW5jb2RpbmcsIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgaWYgKGNodW5rKVxuICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgaWYgKGNiKVxuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBjYilcbiAgICB0aGlzW0VPRl0gPSB0cnVlXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IHdyaXR0ZW4gYW55dGhpbmcsIHRoZW4gZ28gYWhlYWQgYW5kIGVtaXQsXG4gICAgLy8gZXZlbiBpZiB3ZSdyZSBub3QgcmVhZGluZy5cbiAgICAvLyB3ZSdsbCByZS1lbWl0IGlmIGEgbmV3ICdlbmQnIGxpc3RlbmVyIGlzIGFkZGVkIGFueXdheS5cbiAgICAvLyBUaGlzIG1ha2VzIE1QIG1vcmUgc3VpdGFibGUgdG8gd3JpdGUtb25seSB1c2UgY2FzZXMuXG4gICAgaWYgKHRoaXMuZmxvd2luZyB8fCAhdGhpc1tQQVVTRURdKVxuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBkb24ndCBsZXQgdGhlIGludGVybmFsIHJlc3VtZSBiZSBvdmVyd3JpdHRlblxuICBbUkVTVU1FXSAoKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVyblxuXG4gICAgdGhpc1tQQVVTRURdID0gZmFsc2VcbiAgICB0aGlzW0ZMT1dJTkddID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgncmVzdW1lJylcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgdGhpc1tGTFVTSF0oKVxuICAgIGVsc2UgaWYgKHRoaXNbRU9GXSlcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICBlbHNlXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbUkVTVU1FXSgpXG4gIH1cblxuICBwYXVzZSAoKSB7XG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgdGhpc1tQQVVTRURdID0gdHJ1ZVxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbREVTVFJPWUVEXVxuICB9XG5cbiAgZ2V0IGZsb3dpbmcgKCkge1xuICAgIHJldHVybiB0aGlzW0ZMT1dJTkddXG4gIH1cblxuICBnZXQgcGF1c2VkICgpIHtcbiAgICByZXR1cm4gdGhpc1tQQVVTRURdXG4gIH1cblxuICBbQlVGRkVSUFVTSF0gKGNodW5rKSB7XG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gMVxuICAgIGVsc2VcbiAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSBjaHVuay5sZW5ndGhcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGNodW5rKVxuICB9XG5cbiAgW0JVRkZFUlNISUZUXSAoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSAxXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSB0aGlzLmJ1ZmZlclswXS5sZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNoaWZ0KClcbiAgfVxuXG4gIFtGTFVTSF0gKG5vRHJhaW4pIHtcbiAgICBkbyB7fSB3aGlsZSAodGhpc1tGTFVTSENIVU5LXSh0aGlzW0JVRkZFUlNISUZUXSgpKSlcblxuICAgIGlmICghbm9EcmFpbiAmJiAhdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIFtGTFVTSENIVU5LXSAoY2h1bmspIHtcbiAgICByZXR1cm4gY2h1bmsgPyAodGhpcy5lbWl0KCdkYXRhJywgY2h1bmspLCB0aGlzLmZsb3dpbmcpIDogZmFsc2VcbiAgfVxuXG4gIHBpcGUgKGRlc3QsIG9wdHMpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG5cbiAgICBjb25zdCBlbmRlZCA9IHRoaXNbRU1JVFRFRF9FTkRdXG4gICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICBpZiAoZGVzdCA9PT0gcHJvYy5zdGRvdXQgfHwgZGVzdCA9PT0gcHJvYy5zdGRlcnIpXG4gICAgICBvcHRzLmVuZCA9IGZhbHNlXG4gICAgZWxzZVxuICAgICAgb3B0cy5lbmQgPSBvcHRzLmVuZCAhPT0gZmFsc2VcbiAgICBvcHRzLnByb3h5RXJyb3JzID0gISFvcHRzLnByb3h5RXJyb3JzXG5cbiAgICAvLyBwaXBpbmcgYW4gZW5kZWQgc3RyZWFtIGVuZHMgaW1tZWRpYXRlbHlcbiAgICBpZiAoZW5kZWQpIHtcbiAgICAgIGlmIChvcHRzLmVuZClcbiAgICAgICAgZGVzdC5lbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBpcGVzLnB1c2goIW9wdHMucHJveHlFcnJvcnMgPyBuZXcgUGlwZSh0aGlzLCBkZXN0LCBvcHRzKVxuICAgICAgICA6IG5ldyBQaXBlUHJveHlFcnJvcnModGhpcywgZGVzdCwgb3B0cykpXG4gICAgICBpZiAodGhpc1tBU1lOQ10pXG4gICAgICAgIGRlZmVyKCgpID0+IHRoaXNbUkVTVU1FXSgpKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW1JFU1VNRV0oKVxuICAgIH1cblxuICAgIHJldHVybiBkZXN0XG4gIH1cblxuICB1bnBpcGUgKGRlc3QpIHtcbiAgICBjb25zdCBwID0gdGhpcy5waXBlcy5maW5kKHAgPT4gcC5kZXN0ID09PSBkZXN0KVxuICAgIGlmIChwKSB7XG4gICAgICB0aGlzLnBpcGVzLnNwbGljZSh0aGlzLnBpcGVzLmluZGV4T2YocCksIDEpXG4gICAgICBwLnVucGlwZSgpXG4gICAgfVxuICB9XG5cbiAgYWRkTGlzdGVuZXIgKGV2LCBmbikge1xuICAgIHJldHVybiB0aGlzLm9uKGV2LCBmbilcbiAgfVxuXG4gIG9uIChldiwgZm4pIHtcbiAgICBjb25zdCByZXQgPSBzdXBlci5vbihldiwgZm4pXG4gICAgaWYgKGV2ID09PSAnZGF0YScgJiYgIXRoaXMucGlwZXMubGVuZ3RoICYmICF0aGlzLmZsb3dpbmcpXG4gICAgICB0aGlzW1JFU1VNRV0oKVxuICAgIGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgIHN1cGVyLmVtaXQoJ3JlYWRhYmxlJylcbiAgICBlbHNlIGlmIChpc0VuZGlzaChldikgJiYgdGhpc1tFTUlUVEVEX0VORF0pIHtcbiAgICAgIHN1cGVyLmVtaXQoZXYpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnZXJyb3InICYmIHRoaXNbRU1JVFRFRF9FUlJPUl0pIHtcbiAgICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgICAgZGVmZXIoKCkgPT4gZm4uY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKSlcbiAgICAgIGVsc2VcbiAgICAgICAgZm4uY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgZW1pdHRlZEVuZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbRU1JVFRFRF9FTkRdXG4gIH1cblxuICBbTUFZQkVfRU1JVF9FTkRdICgpIHtcbiAgICBpZiAoIXRoaXNbRU1JVFRJTkdfRU5EXSAmJlxuICAgICAgICAhdGhpc1tFTUlUVEVEX0VORF0gJiZcbiAgICAgICAgIXRoaXNbREVTVFJPWUVEXSAmJlxuICAgICAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgdGhpc1tFT0ZdKSB7XG4gICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSB0cnVlXG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpXG4gICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICBpZiAodGhpc1tDTE9TRURdKVxuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZW1pdCAoZXYsIGRhdGEsIC4uLmV4dHJhKSB7XG4gICAgLy8gZXJyb3IgYW5kIGNsb3NlIGFyZSBvbmx5IGV2ZW50cyBhbGxvd2VkIGFmdGVyIGNhbGxpbmcgZGVzdHJveSgpXG4gICAgaWYgKGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnY2xvc2UnICYmIGV2ICE9PSBERVNUUk9ZRUQgJiYgdGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG4gICAgZWxzZSBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgcmV0dXJuICFkYXRhID8gZmFsc2VcbiAgICAgICAgOiB0aGlzW0FTWU5DXSA/IGRlZmVyKCgpID0+IHRoaXNbRU1JVERBVEFdKGRhdGEpKVxuICAgICAgICA6IHRoaXNbRU1JVERBVEFdKGRhdGEpXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2VuZCcpIHtcbiAgICAgIHJldHVybiB0aGlzW0VNSVRFTkRdKClcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnY2xvc2UnKSB7XG4gICAgICB0aGlzW0NMT1NFRF0gPSB0cnVlXG4gICAgICAvLyBkb24ndCBlbWl0IGNsb3NlIGJlZm9yZSAnZW5kJyBhbmQgJ2ZpbmlzaCdcbiAgICAgIGlmICghdGhpc1tFTUlUVEVEX0VORF0gJiYgIXRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdjbG9zZScpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKVxuICAgICAgcmV0dXJuIHJldFxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdlcnJvcicpIHtcbiAgICAgIHRoaXNbRU1JVFRFRF9FUlJPUl0gPSBkYXRhXG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ3Jlc3VtZScpIHtcbiAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ3Jlc3VtZScpXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2ZpbmlzaCcgfHwgZXYgPT09ICdwcmVmaW5pc2gnKSB7XG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KGV2KVxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgLy8gU29tZSBvdGhlciB1bmtub3duIGV2ZW50XG4gICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldiwgZGF0YSwgLi4uZXh0cmEpXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlUREFUQV0gKGRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5waXBlcykge1xuICAgICAgaWYgKHAuZGVzdC53cml0ZShkYXRhKSA9PT0gZmFsc2UpXG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgIH1cbiAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgW0VNSVRFTkRdICgpIHtcbiAgICBpZiAodGhpc1tFTUlUVEVEX0VORF0pXG4gICAgICByZXR1cm5cblxuICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgIGRlZmVyKCgpID0+IHRoaXNbRU1JVEVORDJdKCkpXG4gICAgZWxzZVxuICAgICAgdGhpc1tFTUlURU5EMl0oKVxuICB9XG5cbiAgW0VNSVRFTkQyXSAoKSB7XG4gICAgaWYgKHRoaXNbREVDT0RFUl0pIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzW0RFQ09ERVJdLmVuZCgpXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5waXBlcykge1xuICAgICAgICAgIHAuZGVzdC53cml0ZShkYXRhKVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBpcGVzKSB7XG4gICAgICBwLmVuZCgpXG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ2VuZCcpXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLy8gY29uc3QgYWxsID0gYXdhaXQgc3RyZWFtLmNvbGxlY3QoKVxuICBjb2xsZWN0ICgpIHtcbiAgICBjb25zdCBidWYgPSBbXVxuICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIGJ1Zi5kYXRhTGVuZ3RoID0gMFxuICAgIC8vIHNldCB0aGUgcHJvbWlzZSBmaXJzdCwgaW4gY2FzZSBhbiBlcnJvciBpcyByYWlzZWRcbiAgICAvLyBieSB0cmlnZ2VyaW5nIHRoZSBmbG93IGhlcmUuXG4gICAgY29uc3QgcCA9IHRoaXMucHJvbWlzZSgpXG4gICAgdGhpcy5vbignZGF0YScsIGMgPT4ge1xuICAgICAgYnVmLnB1c2goYylcbiAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgYnVmLmRhdGFMZW5ndGggKz0gYy5sZW5ndGhcbiAgICB9KVxuICAgIHJldHVybiBwLnRoZW4oKCkgPT4gYnVmKVxuICB9XG5cbiAgLy8gY29uc3QgZGF0YSA9IGF3YWl0IHN0cmVhbS5jb25jYXQoKVxuICBjb25jYXQgKCkge1xuICAgIHJldHVybiB0aGlzW09CSkVDVE1PREVdXG4gICAgICA/IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJykpXG4gICAgICA6IHRoaXMuY29sbGVjdCgpLnRoZW4oYnVmID0+XG4gICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpKVxuICAgICAgICAgICAgOiB0aGlzW0VOQ09ESU5HXSA/IGJ1Zi5qb2luKCcnKSA6IEJ1ZmZlci5jb25jYXQoYnVmLCBidWYuZGF0YUxlbmd0aCkpXG4gIH1cblxuICAvLyBzdHJlYW0ucHJvbWlzZSgpLnRoZW4oKCkgPT4gZG9uZSwgZXIgPT4gZW1pdHRlZCBlcnJvcilcbiAgcHJvbWlzZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub24oREVTVFJPWUVELCAoKSA9PiByZWplY3QobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpKVxuICAgICAgdGhpcy5vbignZXJyb3InLCBlciA9PiByZWplY3QoZXIpKVxuICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gcmVzb2x2ZSgpKVxuICAgIH0pXG4gIH1cblxuICAvLyBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pXG4gIFtBU1lOQ0lURVJBVE9SXSAoKSB7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHRoaXMucmVhZCgpXG4gICAgICBpZiAocmVzICE9PSBudWxsKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlOiByZXMgfSlcblxuICAgICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUgfSlcblxuICAgICAgbGV0IHJlc29sdmUgPSBudWxsXG4gICAgICBsZXQgcmVqZWN0ID0gbnVsbFxuICAgICAgY29uc3Qgb25lcnIgPSBlciA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICByZWplY3QoZXIpXG4gICAgICB9XG4gICAgICBjb25zdCBvbmRhdGEgPSB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISF0aGlzW0VPRl0gfSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKVxuICAgICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSB9KVxuICAgICAgfVxuICAgICAgY29uc3Qgb25kZXN0cm95ID0gKCkgPT4gb25lcnIobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlamVjdCA9IHJlalxuICAgICAgICByZXNvbHZlID0gcmVzXG4gICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIG9uZGVzdHJveSlcbiAgICAgICAgdGhpcy5vbmNlKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLm9uY2UoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7IG5leHQgfVxuICB9XG5cbiAgLy8gZm9yIChsZXQgY2h1bmsgb2Ygc3RyZWFtKVxuICBbSVRFUkFUT1JdICgpIHtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlYWQoKVxuICAgICAgY29uc3QgZG9uZSA9IHZhbHVlID09PSBudWxsXG4gICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZSB9XG4gICAgfVxuICAgIHJldHVybiB7IG5leHQgfVxuICB9XG5cbiAgZGVzdHJveSAoZXIpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpc1tERVNUUk9ZRURdID0gdHJ1ZVxuXG4gICAgLy8gdGhyb3cgYXdheSBhbGwgYnVmZmVyZWQgZGF0YSwgaXQncyBuZXZlciBjb21pbmcgb3V0XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMFxuICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDBcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpc1tDTE9TRURdKVxuICAgICAgdGhpcy5jbG9zZSgpXG5cbiAgICBpZiAoZXIpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgZWxzZSAvLyBpZiBubyBlcnJvciB0byBlbWl0LCBzdGlsbCByZWplY3QgcGVuZGluZyBwcm9taXNlc1xuICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGF0aWMgaXNTdHJlYW0gKHMpIHtcbiAgICByZXR1cm4gISFzICYmIChzIGluc3RhbmNlb2YgTWluaXBhc3MgfHwgcyBpbnN0YW5jZW9mIFN0cmVhbSB8fFxuICAgICAgcyBpbnN0YW5jZW9mIEVFICYmIChcbiAgICAgICAgdHlwZW9mIHMucGlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyByZWFkYWJsZVxuICAgICAgICAodHlwZW9mIHMud3JpdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHMuZW5kID09PSAnZnVuY3Rpb24nKSAvLyB3cml0YWJsZVxuICAgICAgKSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/fs-minipass/node_modules/minipass/index.js\n");

/***/ }),

/***/ "./node_modules/minizlib/constants.js":
/*!********************************************!*\
  !*** ./node_modules/minizlib/constants.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst realZlibConstants = (__webpack_require__(/*! zlib */ \"zlib\").constants) ||\n  /* istanbul ignore next */ { ZLIB_VERNUM: 4736 }\n\nmodule.exports = Object.freeze(Object.assign(Object.create(null), {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_VERSION_ERROR: -6,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  DEFLATE: 1,\n  INFLATE: 2,\n  GZIP: 3,\n  GUNZIP: 4,\n  DEFLATERAW: 5,\n  INFLATERAW: 6,\n  UNZIP: 7,\n  BROTLI_DECODE: 8,\n  BROTLI_ENCODE: 9,\n  Z_MIN_WINDOWBITS: 8,\n  Z_MAX_WINDOWBITS: 15,\n  Z_DEFAULT_WINDOWBITS: 15,\n  Z_MIN_CHUNK: 64,\n  Z_MAX_CHUNK: Infinity,\n  Z_DEFAULT_CHUNK: 16384,\n  Z_MIN_MEMLEVEL: 1,\n  Z_MAX_MEMLEVEL: 9,\n  Z_DEFAULT_MEMLEVEL: 8,\n  Z_MIN_LEVEL: -1,\n  Z_MAX_LEVEL: 9,\n  Z_DEFAULT_LEVEL: -1,\n  BROTLI_OPERATION_PROCESS: 0,\n  BROTLI_OPERATION_FLUSH: 1,\n  BROTLI_OPERATION_FINISH: 2,\n  BROTLI_OPERATION_EMIT_METADATA: 3,\n  BROTLI_MODE_GENERIC: 0,\n  BROTLI_MODE_TEXT: 1,\n  BROTLI_MODE_FONT: 2,\n  BROTLI_DEFAULT_MODE: 0,\n  BROTLI_MIN_QUALITY: 0,\n  BROTLI_MAX_QUALITY: 11,\n  BROTLI_DEFAULT_QUALITY: 11,\n  BROTLI_MIN_WINDOW_BITS: 10,\n  BROTLI_MAX_WINDOW_BITS: 24,\n  BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n  BROTLI_DEFAULT_WINDOW: 22,\n  BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n  BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n  BROTLI_PARAM_MODE: 0,\n  BROTLI_PARAM_QUALITY: 1,\n  BROTLI_PARAM_LGWIN: 2,\n  BROTLI_PARAM_LGBLOCK: 3,\n  BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n  BROTLI_PARAM_SIZE_HINT: 5,\n  BROTLI_PARAM_LARGE_WINDOW: 6,\n  BROTLI_PARAM_NPOSTFIX: 7,\n  BROTLI_PARAM_NDIRECT: 8,\n  BROTLI_DECODER_RESULT_ERROR: 0,\n  BROTLI_DECODER_RESULT_SUCCESS: 1,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n  BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n  BROTLI_DECODER_NO_ERROR: 0,\n  BROTLI_DECODER_SUCCESS: 1,\n  BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n  BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n  BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n  BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n  BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n  BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n  BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n  BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n  BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n  BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n  BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n  BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n  BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n  BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n  BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n  BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n  BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n  BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n  BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n  BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n  BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvY29uc3RhbnRzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1EQUF5QjtBQUNuRCwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy9taW5pemxpYi9jb25zdGFudHMuanM/MTQ3ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBVcGRhdGUgd2l0aCBhbnkgemxpYiBjb25zdGFudHMgdGhhdCBhcmUgYWRkZWQgb3IgY2hhbmdlZCBpbiB0aGUgZnV0dXJlLlxuLy8gTm9kZSB2NiBkaWRuJ3QgZXhwb3J0IHRoaXMsIHNvIHdlIGp1c3QgaGFyZCBjb2RlIHRoZSB2ZXJzaW9uIGFuZCByZWx5XG4vLyBvbiBhbGwgdGhlIG90aGVyIGhhcmQtY29kZWQgdmFsdWVzIGZyb20gemxpYiB2NDczNi4gIFdoZW4gbm9kZSB2NlxuLy8gc3VwcG9ydCBkcm9wcywgd2UgY2FuIGp1c3QgZXhwb3J0IHRoZSByZWFsWmxpYkNvbnN0YW50cyBvYmplY3QuXG5jb25zdCByZWFsWmxpYkNvbnN0YW50cyA9IHJlcXVpcmUoJ3psaWInKS5jb25zdGFudHMgfHxcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8geyBaTElCX1ZFUk5VTTogNDczNiB9XG5cbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmZyZWV6ZShPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIHtcbiAgWl9OT19GTFVTSDogMCxcbiAgWl9QQVJUSUFMX0ZMVVNIOiAxLFxuICBaX1NZTkNfRkxVU0g6IDIsXG4gIFpfRlVMTF9GTFVTSDogMyxcbiAgWl9GSU5JU0g6IDQsXG4gIFpfQkxPQ0s6IDUsXG4gIFpfT0s6IDAsXG4gIFpfU1RSRUFNX0VORDogMSxcbiAgWl9ORUVEX0RJQ1Q6IDIsXG4gIFpfRVJSTk86IC0xLFxuICBaX1NUUkVBTV9FUlJPUjogLTIsXG4gIFpfREFUQV9FUlJPUjogLTMsXG4gIFpfTUVNX0VSUk9SOiAtNCxcbiAgWl9CVUZfRVJST1I6IC01LFxuICBaX1ZFUlNJT05fRVJST1I6IC02LFxuICBaX05PX0NPTVBSRVNTSU9OOiAwLFxuICBaX0JFU1RfU1BFRUQ6IDEsXG4gIFpfQkVTVF9DT01QUkVTU0lPTjogOSxcbiAgWl9ERUZBVUxUX0NPTVBSRVNTSU9OOiAtMSxcbiAgWl9GSUxURVJFRDogMSxcbiAgWl9IVUZGTUFOX09OTFk6IDIsXG4gIFpfUkxFOiAzLFxuICBaX0ZJWEVEOiA0LFxuICBaX0RFRkFVTFRfU1RSQVRFR1k6IDAsXG4gIERFRkxBVEU6IDEsXG4gIElORkxBVEU6IDIsXG4gIEdaSVA6IDMsXG4gIEdVTlpJUDogNCxcbiAgREVGTEFURVJBVzogNSxcbiAgSU5GTEFURVJBVzogNixcbiAgVU5aSVA6IDcsXG4gIEJST1RMSV9ERUNPREU6IDgsXG4gIEJST1RMSV9FTkNPREU6IDksXG4gIFpfTUlOX1dJTkRPV0JJVFM6IDgsXG4gIFpfTUFYX1dJTkRPV0JJVFM6IDE1LFxuICBaX0RFRkFVTFRfV0lORE9XQklUUzogMTUsXG4gIFpfTUlOX0NIVU5LOiA2NCxcbiAgWl9NQVhfQ0hVTks6IEluZmluaXR5LFxuICBaX0RFRkFVTFRfQ0hVTks6IDE2Mzg0LFxuICBaX01JTl9NRU1MRVZFTDogMSxcbiAgWl9NQVhfTUVNTEVWRUw6IDksXG4gIFpfREVGQVVMVF9NRU1MRVZFTDogOCxcbiAgWl9NSU5fTEVWRUw6IC0xLFxuICBaX01BWF9MRVZFTDogOSxcbiAgWl9ERUZBVUxUX0xFVkVMOiAtMSxcbiAgQlJPVExJX09QRVJBVElPTl9QUk9DRVNTOiAwLFxuICBCUk9UTElfT1BFUkFUSU9OX0ZMVVNIOiAxLFxuICBCUk9UTElfT1BFUkFUSU9OX0ZJTklTSDogMixcbiAgQlJPVExJX09QRVJBVElPTl9FTUlUX01FVEFEQVRBOiAzLFxuICBCUk9UTElfTU9ERV9HRU5FUklDOiAwLFxuICBCUk9UTElfTU9ERV9URVhUOiAxLFxuICBCUk9UTElfTU9ERV9GT05UOiAyLFxuICBCUk9UTElfREVGQVVMVF9NT0RFOiAwLFxuICBCUk9UTElfTUlOX1FVQUxJVFk6IDAsXG4gIEJST1RMSV9NQVhfUVVBTElUWTogMTEsXG4gIEJST1RMSV9ERUZBVUxUX1FVQUxJVFk6IDExLFxuICBCUk9UTElfTUlOX1dJTkRPV19CSVRTOiAxMCxcbiAgQlJPVExJX01BWF9XSU5ET1dfQklUUzogMjQsXG4gIEJST1RMSV9MQVJHRV9NQVhfV0lORE9XX0JJVFM6IDMwLFxuICBCUk9UTElfREVGQVVMVF9XSU5ET1c6IDIyLFxuICBCUk9UTElfTUlOX0lOUFVUX0JMT0NLX0JJVFM6IDE2LFxuICBCUk9UTElfTUFYX0lOUFVUX0JMT0NLX0JJVFM6IDI0LFxuICBCUk9UTElfUEFSQU1fTU9ERTogMCxcbiAgQlJPVExJX1BBUkFNX1FVQUxJVFk6IDEsXG4gIEJST1RMSV9QQVJBTV9MR1dJTjogMixcbiAgQlJPVExJX1BBUkFNX0xHQkxPQ0s6IDMsXG4gIEJST1RMSV9QQVJBTV9ESVNBQkxFX0xJVEVSQUxfQ09OVEVYVF9NT0RFTElORzogNCxcbiAgQlJPVExJX1BBUkFNX1NJWkVfSElOVDogNSxcbiAgQlJPVExJX1BBUkFNX0xBUkdFX1dJTkRPVzogNixcbiAgQlJPVExJX1BBUkFNX05QT1NURklYOiA3LFxuICBCUk9UTElfUEFSQU1fTkRJUkVDVDogOCxcbiAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX0VSUk9SOiAwLFxuICBCUk9UTElfREVDT0RFUl9SRVNVTFRfU1VDQ0VTUzogMSxcbiAgQlJPVExJX0RFQ09ERVJfUkVTVUxUX05FRURTX01PUkVfSU5QVVQ6IDIsXG4gIEJST1RMSV9ERUNPREVSX1JFU1VMVF9ORUVEU19NT1JFX09VVFBVVDogMyxcbiAgQlJPVExJX0RFQ09ERVJfUEFSQU1fRElTQUJMRV9SSU5HX0JVRkZFUl9SRUFMTE9DQVRJT046IDAsXG4gIEJST1RMSV9ERUNPREVSX1BBUkFNX0xBUkdFX1dJTkRPVzogMSxcbiAgQlJPVExJX0RFQ09ERVJfTk9fRVJST1I6IDAsXG4gIEJST1RMSV9ERUNPREVSX1NVQ0NFU1M6IDEsXG4gIEJST1RMSV9ERUNPREVSX05FRURTX01PUkVfSU5QVVQ6IDIsXG4gIEJST1RMSV9ERUNPREVSX05FRURTX01PUkVfT1VUUFVUOiAzLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfRVhVQkVSQU5UX05JQkJMRTogLTEsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9SRVNFUlZFRDogLTIsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9FWFVCRVJBTlRfTUVUQV9OSUJCTEU6IC0zLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfU0lNUExFX0hVRkZNQU5fQUxQSEFCRVQ6IC00LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfU0lNUExFX0hVRkZNQU5fU0FNRTogLTUsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9DTF9TUEFDRTogLTYsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9IVUZGTUFOX1NQQUNFOiAtNyxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0NPTlRFWFRfTUFQX1JFUEVBVDogLTgsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9CTE9DS19MRU5HVEhfMTogLTksXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9CTE9DS19MRU5HVEhfMjogLTEwLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfVFJBTlNGT1JNOiAtMTEsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9ESUNUSU9OQVJZOiAtMTIsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9XSU5ET1dfQklUUzogLTEzLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9GT1JNQVRfUEFERElOR18xOiAtMTQsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0ZPUk1BVF9QQURESU5HXzI6IC0xNSxcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfRk9STUFUX0RJU1RBTkNFOiAtMTYsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0RJQ1RJT05BUllfTk9UX1NFVDogLTE5LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9JTlZBTElEX0FSR1VNRU5UUzogLTIwLFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19DT05URVhUX01PREVTOiAtMjEsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX1RSRUVfR1JPVVBTOiAtMjIsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX0NPTlRFWFRfTUFQOiAtMjUsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX0FMTE9DX1JJTkdfQlVGRkVSXzE6IC0yNixcbiAgQlJPVExJX0RFQ09ERVJfRVJST1JfQUxMT0NfUklOR19CVUZGRVJfMjogLTI3LFxuICBCUk9UTElfREVDT0RFUl9FUlJPUl9BTExPQ19CTE9DS19UWVBFX1RSRUVTOiAtMzAsXG4gIEJST1RMSV9ERUNPREVSX0VSUk9SX1VOUkVBQ0hBQkxFOiAtMzEsXG59LCByZWFsWmxpYkNvbnN0YW50cykpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/minizlib/constants.js\n");

/***/ }),

/***/ "./node_modules/minizlib/index.js":
/*!****************************************!*\
  !*** ./node_modules/minizlib/index.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst Buffer = (__webpack_require__(/*! buffer */ \"buffer\").Buffer)\nconst realZlib = __webpack_require__(/*! zlib */ \"zlib\")\n\nconst constants = exports.constants = __webpack_require__(/*! ./constants.js */ \"./node_modules/minizlib/constants.js\")\nconst Minipass = __webpack_require__(/*! minipass */ \"./node_modules/minizlib/node_modules/minipass/index.js\")\n\nconst OriginalBufferConcat = Buffer.concat\n\nconst _superWrite = Symbol('_superWrite')\nclass ZlibError extends Error {\n  constructor (err) {\n    super('zlib: ' + err.message)\n    this.code = err.code\n    this.errno = err.errno\n    /* istanbul ignore if */\n    if (!this.code)\n      this.code = 'ZLIB_ERROR'\n\n    this.message = 'zlib: ' + err.message\n    Error.captureStackTrace(this, this.constructor)\n  }\n\n  get name () {\n    return 'ZlibError'\n  }\n}\n\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _opts = Symbol('opts')\nconst _flushFlag = Symbol('flushFlag')\nconst _finishFlushFlag = Symbol('finishFlushFlag')\nconst _fullFlushFlag = Symbol('fullFlushFlag')\nconst _handle = Symbol('handle')\nconst _onError = Symbol('onError')\nconst _sawError = Symbol('sawError')\nconst _level = Symbol('level')\nconst _strategy = Symbol('strategy')\nconst _ended = Symbol('ended')\nconst _defaultFullFlush = Symbol('_defaultFullFlush')\n\nclass ZlibBase extends Minipass {\n  constructor (opts, mode) {\n    if (!opts || typeof opts !== 'object')\n      throw new TypeError('invalid options for ZlibBase constructor')\n\n    super(opts)\n    this[_sawError] = false\n    this[_ended] = false\n    this[_opts] = opts\n\n    this[_flushFlag] = opts.flush\n    this[_finishFlushFlag] = opts.finishFlush\n    // this will throw if any options are invalid for the class selected\n    try {\n      this[_handle] = new realZlib[mode](opts)\n    } catch (er) {\n      // make sure that all errors get decorated properly\n      throw new ZlibError(er)\n    }\n\n    this[_onError] = (err) => {\n      // no sense raising multiple errors, since we abort on the first one.\n      if (this[_sawError])\n        return\n\n      this[_sawError] = true\n\n      // there is no way to cleanly recover.\n      // continuing only obscures problems.\n      this.close()\n      this.emit('error', err)\n    }\n\n    this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n    this.once('end', () => this.close)\n  }\n\n  close () {\n    if (this[_handle]) {\n      this[_handle].close()\n      this[_handle] = null\n      this.emit('close')\n    }\n  }\n\n  reset () {\n    if (!this[_sawError]) {\n      assert(this[_handle], 'zlib binding closed')\n      return this[_handle].reset()\n    }\n  }\n\n  flush (flushFlag) {\n    if (this.ended)\n      return\n\n    if (typeof flushFlag !== 'number')\n      flushFlag = this[_fullFlushFlag]\n    this.write(Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }))\n  }\n\n  end (chunk, encoding, cb) {\n    if (chunk)\n      this.write(chunk, encoding)\n    this.flush(this[_finishFlushFlag])\n    this[_ended] = true\n    return super.end(null, null, cb)\n  }\n\n  get ended () {\n    return this[_ended]\n  }\n\n  write (chunk, encoding, cb) {\n    // process the chunk using the sync process\n    // then super.write() all the outputted chunks\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (typeof chunk === 'string')\n      chunk = Buffer.from(chunk, encoding)\n\n    if (this[_sawError])\n      return\n    assert(this[_handle], 'zlib binding closed')\n\n    // _processChunk tries to .close() the native handle after it's done, so we\n    // intercept that by temporarily making it a no-op.\n    const nativeHandle = this[_handle]._handle\n    const originalNativeClose = nativeHandle.close\n    nativeHandle.close = () => {}\n    const originalClose = this[_handle].close\n    this[_handle].close = () => {}\n    // It also calls `Buffer.concat()` at the end, which may be convenient\n    // for some, but which we are not interested in as it slows us down.\n    Buffer.concat = (args) => args\n    let result\n    try {\n      const flushFlag = typeof chunk[_flushFlag] === 'number'\n        ? chunk[_flushFlag] : this[_flushFlag]\n      result = this[_handle]._processChunk(chunk, flushFlag)\n      // if we don't throw, reset it back how it was\n      Buffer.concat = OriginalBufferConcat\n    } catch (err) {\n      // or if we do, put Buffer.concat() back before we emit error\n      // Error events call into user code, which may call Buffer.concat()\n      Buffer.concat = OriginalBufferConcat\n      this[_onError](new ZlibError(err))\n    } finally {\n      if (this[_handle]) {\n        // Core zlib resets `_handle` to null after attempting to close the\n        // native handle. Our no-op handler prevented actual closure, but we\n        // need to restore the `._handle` property.\n        this[_handle]._handle = nativeHandle\n        nativeHandle.close = originalNativeClose\n        this[_handle].close = originalClose\n        // `_processChunk()` adds an 'error' listener. If we don't remove it\n        // after each call, these handlers start piling up.\n        this[_handle].removeAllListeners('error')\n        // make sure OUR error listener is still attached tho\n      }\n    }\n\n    if (this[_handle])\n      this[_handle].on('error', er => this[_onError](new ZlibError(er)))\n\n    let writeReturn\n    if (result) {\n      if (Array.isArray(result) && result.length > 0) {\n        // The first buffer is always `handle._outBuffer`, which would be\n        // re-used for later invocations; so, we always have to copy that one.\n        writeReturn = this[_superWrite](Buffer.from(result[0]))\n        for (let i = 1; i < result.length; i++) {\n          writeReturn = this[_superWrite](result[i])\n        }\n      } else {\n        writeReturn = this[_superWrite](Buffer.from(result))\n      }\n    }\n\n    if (cb)\n      cb()\n    return writeReturn\n  }\n\n  [_superWrite] (data) {\n    return super.write(data)\n  }\n}\n\nclass Zlib extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.Z_NO_FLUSH\n    opts.finishFlush = opts.finishFlush || constants.Z_FINISH\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.Z_FULL_FLUSH\n    this[_level] = opts.level\n    this[_strategy] = opts.strategy\n  }\n\n  params (level, strategy) {\n    if (this[_sawError])\n      return\n\n    if (!this[_handle])\n      throw new Error('cannot switch params when binding is closed')\n\n    // no way to test this without also not supporting params at all\n    /* istanbul ignore if */\n    if (!this[_handle].params)\n      throw new Error('not supported in this implementation')\n\n    if (this[_level] !== level || this[_strategy] !== strategy) {\n      this.flush(constants.Z_SYNC_FLUSH)\n      assert(this[_handle], 'zlib binding closed')\n      // .params() calls .flush(), but the latter is always async in the\n      // core zlib. We override .flush() temporarily to intercept that and\n      // flush synchronously.\n      const origFlush = this[_handle].flush\n      this[_handle].flush = (flushFlag, cb) => {\n        this.flush(flushFlag)\n        cb()\n      }\n      try {\n        this[_handle].params(level, strategy)\n      } finally {\n        this[_handle].flush = origFlush\n      }\n      /* istanbul ignore else */\n      if (this[_handle]) {\n        this[_level] = level\n        this[_strategy] = strategy\n      }\n    }\n  }\n}\n\n// minimal 2-byte header\nclass Deflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Deflate')\n  }\n}\n\nclass Inflate extends Zlib {\n  constructor (opts) {\n    super(opts, 'Inflate')\n  }\n}\n\n// gzip - bigger header, same deflate compression\nconst _portable = Symbol('_portable')\nclass Gzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gzip')\n    this[_portable] = opts && !!opts.portable\n  }\n\n  [_superWrite] (data) {\n    if (!this[_portable])\n      return super[_superWrite](data)\n\n    // we'll always get the header emitted in one first chunk\n    // overwrite the OS indicator byte with 0xFF\n    this[_portable] = false\n    data[9] = 255\n    return super[_superWrite](data)\n  }\n}\n\nclass Gunzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Gunzip')\n  }\n}\n\n// raw - no header\nclass DeflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'DeflateRaw')\n  }\n}\n\nclass InflateRaw extends Zlib {\n  constructor (opts) {\n    super(opts, 'InflateRaw')\n  }\n}\n\n// auto-detect header.\nclass Unzip extends Zlib {\n  constructor (opts) {\n    super(opts, 'Unzip')\n  }\n}\n\nclass Brotli extends ZlibBase {\n  constructor (opts, mode) {\n    opts = opts || {}\n\n    opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS\n    opts.finishFlush = opts.finishFlush || constants.BROTLI_OPERATION_FINISH\n\n    super(opts, mode)\n\n    this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH\n  }\n}\n\nclass BrotliCompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliCompress')\n  }\n}\n\nclass BrotliDecompress extends Brotli {\n  constructor (opts) {\n    super(opts, 'BrotliDecompress')\n  }\n}\n\nexports.Deflate = Deflate\nexports.Inflate = Inflate\nexports.Gzip = Gzip\nexports.Gunzip = Gunzip\nexports.DeflateRaw = DeflateRaw\nexports.InflateRaw = InflateRaw\nexports.Unzip = Unzip\n/* istanbul ignore else */\nif (typeof realZlib.BrotliCompress === 'function') {\n  exports.BrotliCompress = BrotliCompress\n  exports.BrotliDecompress = BrotliDecompress\n} else {\n  exports.BrotliCompress = exports.BrotliDecompress = class {\n    constructor () {\n      throw new Error('Brotli is not supported in this version of Node.js')\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVosZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLGVBQWUsb0RBQXdCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLGtCQUFNOztBQUUvQixrQkFBa0IscUdBQTZDO0FBQy9ELGlCQUFpQixtQkFBTyxDQUFDLHdFQUFVOztBQUVuQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0QseUJBQXlCO0FBQ3pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlO0FBQ2YsZUFBZTtBQUNmLFlBQVk7QUFDWixjQUFjO0FBQ2Qsa0JBQWtCO0FBQ2xCLGtCQUFrQjtBQUNsQixhQUFhO0FBQ2I7QUFDQTtBQUNBLEVBQUUsc0JBQXNCO0FBQ3hCLEVBQUUsd0JBQXdCO0FBQzFCLEVBQUU7QUFDRixFQUFFLHNCQUFzQixHQUFHLHdCQUF3QjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy9taW5pemxpYi9pbmRleC5qcz8wNThlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG5jb25zdCBhc3NlcnQgPSByZXF1aXJlKCdhc3NlcnQnKVxuY29uc3QgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyXG5jb25zdCByZWFsWmxpYiA9IHJlcXVpcmUoJ3psaWInKVxuXG5jb25zdCBjb25zdGFudHMgPSBleHBvcnRzLmNvbnN0YW50cyA9IHJlcXVpcmUoJy4vY29uc3RhbnRzLmpzJylcbmNvbnN0IE1pbmlwYXNzID0gcmVxdWlyZSgnbWluaXBhc3MnKVxuXG5jb25zdCBPcmlnaW5hbEJ1ZmZlckNvbmNhdCA9IEJ1ZmZlci5jb25jYXRcblxuY29uc3QgX3N1cGVyV3JpdGUgPSBTeW1ib2woJ19zdXBlcldyaXRlJylcbmNsYXNzIFpsaWJFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IgKGVycikge1xuICAgIHN1cGVyKCd6bGliOiAnICsgZXJyLm1lc3NhZ2UpXG4gICAgdGhpcy5jb2RlID0gZXJyLmNvZGVcbiAgICB0aGlzLmVycm5vID0gZXJyLmVycm5vXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCF0aGlzLmNvZGUpXG4gICAgICB0aGlzLmNvZGUgPSAnWkxJQl9FUlJPUidcblxuICAgIHRoaXMubWVzc2FnZSA9ICd6bGliOiAnICsgZXJyLm1lc3NhZ2VcbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKVxuICB9XG5cbiAgZ2V0IG5hbWUgKCkge1xuICAgIHJldHVybiAnWmxpYkVycm9yJ1xuICB9XG59XG5cbi8vIHRoZSBabGliIGNsYXNzIHRoZXkgYWxsIGluaGVyaXQgZnJvbVxuLy8gVGhpcyB0aGluZyBtYW5hZ2VzIHRoZSBxdWV1ZSBvZiByZXF1ZXN0cywgYW5kIHJldHVybnNcbi8vIHRydWUgb3IgZmFsc2UgaWYgdGhlcmUgaXMgYW55dGhpbmcgaW4gdGhlIHF1ZXVlIHdoZW5cbi8vIHlvdSBjYWxsIHRoZSAud3JpdGUoKSBtZXRob2QuXG5jb25zdCBfb3B0cyA9IFN5bWJvbCgnb3B0cycpXG5jb25zdCBfZmx1c2hGbGFnID0gU3ltYm9sKCdmbHVzaEZsYWcnKVxuY29uc3QgX2ZpbmlzaEZsdXNoRmxhZyA9IFN5bWJvbCgnZmluaXNoRmx1c2hGbGFnJylcbmNvbnN0IF9mdWxsRmx1c2hGbGFnID0gU3ltYm9sKCdmdWxsRmx1c2hGbGFnJylcbmNvbnN0IF9oYW5kbGUgPSBTeW1ib2woJ2hhbmRsZScpXG5jb25zdCBfb25FcnJvciA9IFN5bWJvbCgnb25FcnJvcicpXG5jb25zdCBfc2F3RXJyb3IgPSBTeW1ib2woJ3Nhd0Vycm9yJylcbmNvbnN0IF9sZXZlbCA9IFN5bWJvbCgnbGV2ZWwnKVxuY29uc3QgX3N0cmF0ZWd5ID0gU3ltYm9sKCdzdHJhdGVneScpXG5jb25zdCBfZW5kZWQgPSBTeW1ib2woJ2VuZGVkJylcbmNvbnN0IF9kZWZhdWx0RnVsbEZsdXNoID0gU3ltYm9sKCdfZGVmYXVsdEZ1bGxGbHVzaCcpXG5cbmNsYXNzIFpsaWJCYXNlIGV4dGVuZHMgTWluaXBhc3Mge1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9kZSkge1xuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIG9wdGlvbnMgZm9yIFpsaWJCYXNlIGNvbnN0cnVjdG9yJylcblxuICAgIHN1cGVyKG9wdHMpXG4gICAgdGhpc1tfc2F3RXJyb3JdID0gZmFsc2VcbiAgICB0aGlzW19lbmRlZF0gPSBmYWxzZVxuICAgIHRoaXNbX29wdHNdID0gb3B0c1xuXG4gICAgdGhpc1tfZmx1c2hGbGFnXSA9IG9wdHMuZmx1c2hcbiAgICB0aGlzW19maW5pc2hGbHVzaEZsYWddID0gb3B0cy5maW5pc2hGbHVzaFxuICAgIC8vIHRoaXMgd2lsbCB0aHJvdyBpZiBhbnkgb3B0aW9ucyBhcmUgaW52YWxpZCBmb3IgdGhlIGNsYXNzIHNlbGVjdGVkXG4gICAgdHJ5IHtcbiAgICAgIHRoaXNbX2hhbmRsZV0gPSBuZXcgcmVhbFpsaWJbbW9kZV0ob3B0cylcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgLy8gbWFrZSBzdXJlIHRoYXQgYWxsIGVycm9ycyBnZXQgZGVjb3JhdGVkIHByb3Blcmx5XG4gICAgICB0aHJvdyBuZXcgWmxpYkVycm9yKGVyKVxuICAgIH1cblxuICAgIHRoaXNbX29uRXJyb3JdID0gKGVycikgPT4ge1xuICAgICAgLy8gbm8gc2Vuc2UgcmFpc2luZyBtdWx0aXBsZSBlcnJvcnMsIHNpbmNlIHdlIGFib3J0IG9uIHRoZSBmaXJzdCBvbmUuXG4gICAgICBpZiAodGhpc1tfc2F3RXJyb3JdKVxuICAgICAgICByZXR1cm5cblxuICAgICAgdGhpc1tfc2F3RXJyb3JdID0gdHJ1ZVxuXG4gICAgICAvLyB0aGVyZSBpcyBubyB3YXkgdG8gY2xlYW5seSByZWNvdmVyLlxuICAgICAgLy8gY29udGludWluZyBvbmx5IG9ic2N1cmVzIHByb2JsZW1zLlxuICAgICAgdGhpcy5jbG9zZSgpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKVxuICAgIH1cblxuICAgIHRoaXNbX2hhbmRsZV0ub24oJ2Vycm9yJywgZXIgPT4gdGhpc1tfb25FcnJvcl0obmV3IFpsaWJFcnJvcihlcikpKVxuICAgIHRoaXMub25jZSgnZW5kJywgKCkgPT4gdGhpcy5jbG9zZSlcbiAgfVxuXG4gIGNsb3NlICgpIHtcbiAgICBpZiAodGhpc1tfaGFuZGxlXSkge1xuICAgICAgdGhpc1tfaGFuZGxlXS5jbG9zZSgpXG4gICAgICB0aGlzW19oYW5kbGVdID0gbnVsbFxuICAgICAgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgfVxuICB9XG5cbiAgcmVzZXQgKCkge1xuICAgIGlmICghdGhpc1tfc2F3RXJyb3JdKSB7XG4gICAgICBhc3NlcnQodGhpc1tfaGFuZGxlXSwgJ3psaWIgYmluZGluZyBjbG9zZWQnKVxuICAgICAgcmV0dXJuIHRoaXNbX2hhbmRsZV0ucmVzZXQoKVxuICAgIH1cbiAgfVxuXG4gIGZsdXNoIChmbHVzaEZsYWcpIHtcbiAgICBpZiAodGhpcy5lbmRlZClcbiAgICAgIHJldHVyblxuXG4gICAgaWYgKHR5cGVvZiBmbHVzaEZsYWcgIT09ICdudW1iZXInKVxuICAgICAgZmx1c2hGbGFnID0gdGhpc1tfZnVsbEZsdXNoRmxhZ11cbiAgICB0aGlzLndyaXRlKE9iamVjdC5hc3NpZ24oQnVmZmVyLmFsbG9jKDApLCB7IFtfZmx1c2hGbGFnXTogZmx1c2hGbGFnIH0pKVxuICB9XG5cbiAgZW5kIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKGNodW5rKVxuICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgdGhpcy5mbHVzaCh0aGlzW19maW5pc2hGbHVzaEZsYWddKVxuICAgIHRoaXNbX2VuZGVkXSA9IHRydWVcbiAgICByZXR1cm4gc3VwZXIuZW5kKG51bGwsIG51bGwsIGNiKVxuICB9XG5cbiAgZ2V0IGVuZGVkICgpIHtcbiAgICByZXR1cm4gdGhpc1tfZW5kZWRdXG4gIH1cblxuICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIC8vIHByb2Nlc3MgdGhlIGNodW5rIHVzaW5nIHRoZSBzeW5jIHByb2Nlc3NcbiAgICAvLyB0aGVuIHN1cGVyLndyaXRlKCkgYWxsIHRoZSBvdXRwdXR0ZWQgY2h1bmtzXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gZW5jb2RpbmcsIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJylcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuXG4gICAgaWYgKHRoaXNbX3Nhd0Vycm9yXSlcbiAgICAgIHJldHVyblxuICAgIGFzc2VydCh0aGlzW19oYW5kbGVdLCAnemxpYiBiaW5kaW5nIGNsb3NlZCcpXG5cbiAgICAvLyBfcHJvY2Vzc0NodW5rIHRyaWVzIHRvIC5jbG9zZSgpIHRoZSBuYXRpdmUgaGFuZGxlIGFmdGVyIGl0J3MgZG9uZSwgc28gd2VcbiAgICAvLyBpbnRlcmNlcHQgdGhhdCBieSB0ZW1wb3JhcmlseSBtYWtpbmcgaXQgYSBuby1vcC5cbiAgICBjb25zdCBuYXRpdmVIYW5kbGUgPSB0aGlzW19oYW5kbGVdLl9oYW5kbGVcbiAgICBjb25zdCBvcmlnaW5hbE5hdGl2ZUNsb3NlID0gbmF0aXZlSGFuZGxlLmNsb3NlXG4gICAgbmF0aXZlSGFuZGxlLmNsb3NlID0gKCkgPT4ge31cbiAgICBjb25zdCBvcmlnaW5hbENsb3NlID0gdGhpc1tfaGFuZGxlXS5jbG9zZVxuICAgIHRoaXNbX2hhbmRsZV0uY2xvc2UgPSAoKSA9PiB7fVxuICAgIC8vIEl0IGFsc28gY2FsbHMgYEJ1ZmZlci5jb25jYXQoKWAgYXQgdGhlIGVuZCwgd2hpY2ggbWF5IGJlIGNvbnZlbmllbnRcbiAgICAvLyBmb3Igc29tZSwgYnV0IHdoaWNoIHdlIGFyZSBub3QgaW50ZXJlc3RlZCBpbiBhcyBpdCBzbG93cyB1cyBkb3duLlxuICAgIEJ1ZmZlci5jb25jYXQgPSAoYXJncykgPT4gYXJnc1xuICAgIGxldCByZXN1bHRcbiAgICB0cnkge1xuICAgICAgY29uc3QgZmx1c2hGbGFnID0gdHlwZW9mIGNodW5rW19mbHVzaEZsYWddID09PSAnbnVtYmVyJ1xuICAgICAgICA/IGNodW5rW19mbHVzaEZsYWddIDogdGhpc1tfZmx1c2hGbGFnXVxuICAgICAgcmVzdWx0ID0gdGhpc1tfaGFuZGxlXS5fcHJvY2Vzc0NodW5rKGNodW5rLCBmbHVzaEZsYWcpXG4gICAgICAvLyBpZiB3ZSBkb24ndCB0aHJvdywgcmVzZXQgaXQgYmFjayBob3cgaXQgd2FzXG4gICAgICBCdWZmZXIuY29uY2F0ID0gT3JpZ2luYWxCdWZmZXJDb25jYXRcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIC8vIG9yIGlmIHdlIGRvLCBwdXQgQnVmZmVyLmNvbmNhdCgpIGJhY2sgYmVmb3JlIHdlIGVtaXQgZXJyb3JcbiAgICAgIC8vIEVycm9yIGV2ZW50cyBjYWxsIGludG8gdXNlciBjb2RlLCB3aGljaCBtYXkgY2FsbCBCdWZmZXIuY29uY2F0KClcbiAgICAgIEJ1ZmZlci5jb25jYXQgPSBPcmlnaW5hbEJ1ZmZlckNvbmNhdFxuICAgICAgdGhpc1tfb25FcnJvcl0obmV3IFpsaWJFcnJvcihlcnIpKVxuICAgIH0gZmluYWxseSB7XG4gICAgICBpZiAodGhpc1tfaGFuZGxlXSkge1xuICAgICAgICAvLyBDb3JlIHpsaWIgcmVzZXRzIGBfaGFuZGxlYCB0byBudWxsIGFmdGVyIGF0dGVtcHRpbmcgdG8gY2xvc2UgdGhlXG4gICAgICAgIC8vIG5hdGl2ZSBoYW5kbGUuIE91ciBuby1vcCBoYW5kbGVyIHByZXZlbnRlZCBhY3R1YWwgY2xvc3VyZSwgYnV0IHdlXG4gICAgICAgIC8vIG5lZWQgdG8gcmVzdG9yZSB0aGUgYC5faGFuZGxlYCBwcm9wZXJ0eS5cbiAgICAgICAgdGhpc1tfaGFuZGxlXS5faGFuZGxlID0gbmF0aXZlSGFuZGxlXG4gICAgICAgIG5hdGl2ZUhhbmRsZS5jbG9zZSA9IG9yaWdpbmFsTmF0aXZlQ2xvc2VcbiAgICAgICAgdGhpc1tfaGFuZGxlXS5jbG9zZSA9IG9yaWdpbmFsQ2xvc2VcbiAgICAgICAgLy8gYF9wcm9jZXNzQ2h1bmsoKWAgYWRkcyBhbiAnZXJyb3InIGxpc3RlbmVyLiBJZiB3ZSBkb24ndCByZW1vdmUgaXRcbiAgICAgICAgLy8gYWZ0ZXIgZWFjaCBjYWxsLCB0aGVzZSBoYW5kbGVycyBzdGFydCBwaWxpbmcgdXAuXG4gICAgICAgIHRoaXNbX2hhbmRsZV0ucmVtb3ZlQWxsTGlzdGVuZXJzKCdlcnJvcicpXG4gICAgICAgIC8vIG1ha2Ugc3VyZSBPVVIgZXJyb3IgbGlzdGVuZXIgaXMgc3RpbGwgYXR0YWNoZWQgdGhvXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXNbX2hhbmRsZV0pXG4gICAgICB0aGlzW19oYW5kbGVdLm9uKCdlcnJvcicsIGVyID0+IHRoaXNbX29uRXJyb3JdKG5ldyBabGliRXJyb3IoZXIpKSlcblxuICAgIGxldCB3cml0ZVJldHVyblxuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IGJ1ZmZlciBpcyBhbHdheXMgYGhhbmRsZS5fb3V0QnVmZmVyYCwgd2hpY2ggd291bGQgYmVcbiAgICAgICAgLy8gcmUtdXNlZCBmb3IgbGF0ZXIgaW52b2NhdGlvbnM7IHNvLCB3ZSBhbHdheXMgaGF2ZSB0byBjb3B5IHRoYXQgb25lLlxuICAgICAgICB3cml0ZVJldHVybiA9IHRoaXNbX3N1cGVyV3JpdGVdKEJ1ZmZlci5mcm9tKHJlc3VsdFswXSkpXG4gICAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgcmVzdWx0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgd3JpdGVSZXR1cm4gPSB0aGlzW19zdXBlcldyaXRlXShyZXN1bHRbaV0pXG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHdyaXRlUmV0dXJuID0gdGhpc1tfc3VwZXJXcml0ZV0oQnVmZmVyLmZyb20ocmVzdWx0KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY2IpXG4gICAgICBjYigpXG4gICAgcmV0dXJuIHdyaXRlUmV0dXJuXG4gIH1cblxuICBbX3N1cGVyV3JpdGVdIChkYXRhKSB7XG4gICAgcmV0dXJuIHN1cGVyLndyaXRlKGRhdGEpXG4gIH1cbn1cblxuY2xhc3MgWmxpYiBleHRlbmRzIFpsaWJCYXNlIHtcbiAgY29uc3RydWN0b3IgKG9wdHMsIG1vZGUpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuXG4gICAgb3B0cy5mbHVzaCA9IG9wdHMuZmx1c2ggfHwgY29uc3RhbnRzLlpfTk9fRkxVU0hcbiAgICBvcHRzLmZpbmlzaEZsdXNoID0gb3B0cy5maW5pc2hGbHVzaCB8fCBjb25zdGFudHMuWl9GSU5JU0hcbiAgICBzdXBlcihvcHRzLCBtb2RlKVxuXG4gICAgdGhpc1tfZnVsbEZsdXNoRmxhZ10gPSBjb25zdGFudHMuWl9GVUxMX0ZMVVNIXG4gICAgdGhpc1tfbGV2ZWxdID0gb3B0cy5sZXZlbFxuICAgIHRoaXNbX3N0cmF0ZWd5XSA9IG9wdHMuc3RyYXRlZ3lcbiAgfVxuXG4gIHBhcmFtcyAobGV2ZWwsIHN0cmF0ZWd5KSB7XG4gICAgaWYgKHRoaXNbX3Nhd0Vycm9yXSlcbiAgICAgIHJldHVyblxuXG4gICAgaWYgKCF0aGlzW19oYW5kbGVdKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc3dpdGNoIHBhcmFtcyB3aGVuIGJpbmRpbmcgaXMgY2xvc2VkJylcblxuICAgIC8vIG5vIHdheSB0byB0ZXN0IHRoaXMgd2l0aG91dCBhbHNvIG5vdCBzdXBwb3J0aW5nIHBhcmFtcyBhdCBhbGxcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIXRoaXNbX2hhbmRsZV0ucGFyYW1zKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdub3Qgc3VwcG9ydGVkIGluIHRoaXMgaW1wbGVtZW50YXRpb24nKVxuXG4gICAgaWYgKHRoaXNbX2xldmVsXSAhPT0gbGV2ZWwgfHwgdGhpc1tfc3RyYXRlZ3ldICE9PSBzdHJhdGVneSkge1xuICAgICAgdGhpcy5mbHVzaChjb25zdGFudHMuWl9TWU5DX0ZMVVNIKVxuICAgICAgYXNzZXJ0KHRoaXNbX2hhbmRsZV0sICd6bGliIGJpbmRpbmcgY2xvc2VkJylcbiAgICAgIC8vIC5wYXJhbXMoKSBjYWxscyAuZmx1c2goKSwgYnV0IHRoZSBsYXR0ZXIgaXMgYWx3YXlzIGFzeW5jIGluIHRoZVxuICAgICAgLy8gY29yZSB6bGliLiBXZSBvdmVycmlkZSAuZmx1c2goKSB0ZW1wb3JhcmlseSB0byBpbnRlcmNlcHQgdGhhdCBhbmRcbiAgICAgIC8vIGZsdXNoIHN5bmNocm9ub3VzbHkuXG4gICAgICBjb25zdCBvcmlnRmx1c2ggPSB0aGlzW19oYW5kbGVdLmZsdXNoXG4gICAgICB0aGlzW19oYW5kbGVdLmZsdXNoID0gKGZsdXNoRmxhZywgY2IpID0+IHtcbiAgICAgICAgdGhpcy5mbHVzaChmbHVzaEZsYWcpXG4gICAgICAgIGNiKClcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXNbX2hhbmRsZV0ucGFyYW1zKGxldmVsLCBzdHJhdGVneSlcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHRoaXNbX2hhbmRsZV0uZmx1c2ggPSBvcmlnRmx1c2hcbiAgICAgIH1cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICBpZiAodGhpc1tfaGFuZGxlXSkge1xuICAgICAgICB0aGlzW19sZXZlbF0gPSBsZXZlbFxuICAgICAgICB0aGlzW19zdHJhdGVneV0gPSBzdHJhdGVneVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBtaW5pbWFsIDItYnl0ZSBoZWFkZXJcbmNsYXNzIERlZmxhdGUgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnRGVmbGF0ZScpXG4gIH1cbn1cblxuY2xhc3MgSW5mbGF0ZSBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdJbmZsYXRlJylcbiAgfVxufVxuXG4vLyBnemlwIC0gYmlnZ2VyIGhlYWRlciwgc2FtZSBkZWZsYXRlIGNvbXByZXNzaW9uXG5jb25zdCBfcG9ydGFibGUgPSBTeW1ib2woJ19wb3J0YWJsZScpXG5jbGFzcyBHemlwIGV4dGVuZHMgWmxpYiB7XG4gIGNvbnN0cnVjdG9yIChvcHRzKSB7XG4gICAgc3VwZXIob3B0cywgJ0d6aXAnKVxuICAgIHRoaXNbX3BvcnRhYmxlXSA9IG9wdHMgJiYgISFvcHRzLnBvcnRhYmxlXG4gIH1cblxuICBbX3N1cGVyV3JpdGVdIChkYXRhKSB7XG4gICAgaWYgKCF0aGlzW19wb3J0YWJsZV0pXG4gICAgICByZXR1cm4gc3VwZXJbX3N1cGVyV3JpdGVdKGRhdGEpXG5cbiAgICAvLyB3ZSdsbCBhbHdheXMgZ2V0IHRoZSBoZWFkZXIgZW1pdHRlZCBpbiBvbmUgZmlyc3QgY2h1bmtcbiAgICAvLyBvdmVyd3JpdGUgdGhlIE9TIGluZGljYXRvciBieXRlIHdpdGggMHhGRlxuICAgIHRoaXNbX3BvcnRhYmxlXSA9IGZhbHNlXG4gICAgZGF0YVs5XSA9IDI1NVxuICAgIHJldHVybiBzdXBlcltfc3VwZXJXcml0ZV0oZGF0YSlcbiAgfVxufVxuXG5jbGFzcyBHdW56aXAgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnR3VuemlwJylcbiAgfVxufVxuXG4vLyByYXcgLSBubyBoZWFkZXJcbmNsYXNzIERlZmxhdGVSYXcgZXh0ZW5kcyBabGliIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnRGVmbGF0ZVJhdycpXG4gIH1cbn1cblxuY2xhc3MgSW5mbGF0ZVJhdyBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdJbmZsYXRlUmF3JylcbiAgfVxufVxuXG4vLyBhdXRvLWRldGVjdCBoZWFkZXIuXG5jbGFzcyBVbnppcCBleHRlbmRzIFpsaWIge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdVbnppcCcpXG4gIH1cbn1cblxuY2xhc3MgQnJvdGxpIGV4dGVuZHMgWmxpYkJhc2Uge1xuICBjb25zdHJ1Y3RvciAob3B0cywgbW9kZSkge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9XG5cbiAgICBvcHRzLmZsdXNoID0gb3B0cy5mbHVzaCB8fCBjb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9QUk9DRVNTXG4gICAgb3B0cy5maW5pc2hGbHVzaCA9IG9wdHMuZmluaXNoRmx1c2ggfHwgY29uc3RhbnRzLkJST1RMSV9PUEVSQVRJT05fRklOSVNIXG5cbiAgICBzdXBlcihvcHRzLCBtb2RlKVxuXG4gICAgdGhpc1tfZnVsbEZsdXNoRmxhZ10gPSBjb25zdGFudHMuQlJPVExJX09QRVJBVElPTl9GTFVTSFxuICB9XG59XG5cbmNsYXNzIEJyb3RsaUNvbXByZXNzIGV4dGVuZHMgQnJvdGxpIHtcbiAgY29uc3RydWN0b3IgKG9wdHMpIHtcbiAgICBzdXBlcihvcHRzLCAnQnJvdGxpQ29tcHJlc3MnKVxuICB9XG59XG5cbmNsYXNzIEJyb3RsaURlY29tcHJlc3MgZXh0ZW5kcyBCcm90bGkge1xuICBjb25zdHJ1Y3RvciAob3B0cykge1xuICAgIHN1cGVyKG9wdHMsICdCcm90bGlEZWNvbXByZXNzJylcbiAgfVxufVxuXG5leHBvcnRzLkRlZmxhdGUgPSBEZWZsYXRlXG5leHBvcnRzLkluZmxhdGUgPSBJbmZsYXRlXG5leHBvcnRzLkd6aXAgPSBHemlwXG5leHBvcnRzLkd1bnppcCA9IEd1bnppcFxuZXhwb3J0cy5EZWZsYXRlUmF3ID0gRGVmbGF0ZVJhd1xuZXhwb3J0cy5JbmZsYXRlUmF3ID0gSW5mbGF0ZVJhd1xuZXhwb3J0cy5VbnppcCA9IFVuemlwXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuaWYgKHR5cGVvZiByZWFsWmxpYi5Ccm90bGlDb21wcmVzcyA9PT0gJ2Z1bmN0aW9uJykge1xuICBleHBvcnRzLkJyb3RsaUNvbXByZXNzID0gQnJvdGxpQ29tcHJlc3NcbiAgZXhwb3J0cy5Ccm90bGlEZWNvbXByZXNzID0gQnJvdGxpRGVjb21wcmVzc1xufSBlbHNlIHtcbiAgZXhwb3J0cy5Ccm90bGlDb21wcmVzcyA9IGV4cG9ydHMuQnJvdGxpRGVjb21wcmVzcyA9IGNsYXNzIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Jyb3RsaSBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgdmVyc2lvbiBvZiBOb2RlLmpzJylcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/minizlib/index.js\n");

/***/ }),

/***/ "./node_modules/minizlib/node_modules/minipass/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/minizlib/node_modules/minipass/index.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst proc = typeof process === 'object' && process ? process : {\n  stdout: null,\n  stderr: null,\n}\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Stream = __webpack_require__(/*! stream */ \"stream\")\nconst SD = (__webpack_require__(/*! string_decoder */ \"string_decoder\").StringDecoder)\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\nconst DESTROYED = Symbol('destroyed')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_  !== '1'\nconst ASYNCITERATOR = doIter && Symbol.asyncIterator\n  || Symbol('asyncIterator not implemented')\nconst ITERATOR = doIter && Symbol.iterator\n  || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev =>\n  ev === 'end' ||\n  ev === 'finish' ||\n  ev === 'prefinish'\n\nconst isArrayBuffer = b => b instanceof ArrayBuffer ||\n  typeof b === 'object' &&\n  b.constructor &&\n  b.constructor.name === 'ArrayBuffer' &&\n  b.byteLength >= 0\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor (src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe () {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors () {}\n  end () {\n    this.unpipe()\n    if (this.opts.end)\n      this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe () {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor (src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nmodule.exports = class Minipass extends Stream {\n  constructor (options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this.pipes = []\n    this.buffer = []\n    this[OBJECTMODE] = options && options.objectMode || false\n    if (this[OBJECTMODE])\n      this[ENCODING] = null\n    else\n      this[ENCODING] = options && options.encoding || null\n    if (this[ENCODING] === 'buffer')\n      this[ENCODING] = null\n    this[ASYNC] = options && !!options.async || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n  }\n\n  get bufferLength () { return this[BUFFERLENGTH] }\n\n  get encoding () { return this[ENCODING] }\n  set encoding (enc) {\n    if (this[OBJECTMODE])\n      throw new Error('cannot set encoding in objectMode')\n\n    if (this[ENCODING] && enc !== this[ENCODING] &&\n        (this[DECODER] && this[DECODER].lastNeed || this[BUFFERLENGTH]))\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this.buffer.length)\n        this.buffer = this.buffer.map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding (enc) {\n    this.encoding = enc\n  }\n\n  get objectMode () { return this[OBJECTMODE] }\n  set objectMode (om) { this[OBJECTMODE] = this[OBJECTMODE] || !!om }\n\n  get ['async'] () { return this[ASYNC] }\n  set ['async'] (a) { this[ASYNC] = this[ASYNC] || !!a }\n\n  write (chunk, encoding, cb) {\n    if (this[EOF])\n      throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit('error', Object.assign(\n        new Error('Cannot call write after a stream was destroyed'),\n        { code: 'ERR_STREAM_DESTROYED' }\n      ))\n      return true\n    }\n\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n\n    if (!encoding)\n      encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk))\n        chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0)\n        this[FLUSH](true)\n\n      if (this.flowing)\n        this.emit('data', chunk)\n      else\n        this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n\n      if (cb)\n        fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0)\n        this.emit('readable')\n      if (cb)\n        fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (typeof chunk === 'string' &&\n        // unless it is a string already ready for us to use\n        !(encoding === this[ENCODING] && !this[DECODER].lastNeed)) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0)\n      this[FLUSH](true)\n\n    if (this.flowing)\n      this.emit('data', chunk)\n    else\n      this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0)\n      this.emit('readable')\n\n    if (cb)\n      fn(cb)\n\n    return this.flowing\n  }\n\n  read (n) {\n    if (this[DESTROYED])\n      return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE])\n      n = null\n\n    if (this.buffer.length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding)\n        this.buffer = [this.buffer.join('')]\n      else\n        this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this.buffer[0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ] (n, chunk) {\n    if (n === chunk.length || n === null)\n      this[BUFFERSHIFT]()\n    else {\n      this.buffer[0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this.buffer.length && !this[EOF])\n      this.emit('drain')\n\n    return chunk\n  }\n\n  end (chunk, encoding, cb) {\n    if (typeof chunk === 'function')\n      cb = chunk, chunk = null\n    if (typeof encoding === 'function')\n      cb = encoding, encoding = 'utf8'\n    if (chunk)\n      this.write(chunk, encoding)\n    if (cb)\n      this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED])\n      this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME] () {\n    if (this[DESTROYED])\n      return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this.buffer.length)\n      this[FLUSH]()\n    else if (this[EOF])\n      this[MAYBE_EMIT_END]()\n    else\n      this.emit('drain')\n  }\n\n  resume () {\n    return this[RESUME]()\n  }\n\n  pause () {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed () {\n    return this[DESTROYED]\n  }\n\n  get flowing () {\n    return this[FLOWING]\n  }\n\n  get paused () {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH] (chunk) {\n    if (this[OBJECTMODE])\n      this[BUFFERLENGTH] += 1\n    else\n      this[BUFFERLENGTH] += chunk.length\n    this.buffer.push(chunk)\n  }\n\n  [BUFFERSHIFT] () {\n    if (this.buffer.length) {\n      if (this[OBJECTMODE])\n        this[BUFFERLENGTH] -= 1\n      else\n        this[BUFFERLENGTH] -= this.buffer[0].length\n    }\n    return this.buffer.shift()\n  }\n\n  [FLUSH] (noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()))\n\n    if (!noDrain && !this.buffer.length && !this[EOF])\n      this.emit('drain')\n  }\n\n  [FLUSHCHUNK] (chunk) {\n    return chunk ? (this.emit('data', chunk), this.flowing) : false\n  }\n\n  pipe (dest, opts) {\n    if (this[DESTROYED])\n      return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr)\n      opts.end = false\n    else\n      opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end)\n        dest.end()\n    } else {\n      this.pipes.push(!opts.proxyErrors ? new Pipe(this, dest, opts)\n        : new PipeProxyErrors(this, dest, opts))\n      if (this[ASYNC])\n        defer(() => this[RESUME]())\n      else\n        this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe (dest) {\n    const p = this.pipes.find(p => p.dest === dest)\n    if (p) {\n      this.pipes.splice(this.pipes.indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener (ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on (ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this.pipes.length && !this.flowing)\n      this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC])\n        defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else\n        fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd () {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END] () {\n    if (!this[EMITTING_END] &&\n        !this[EMITTED_END] &&\n        !this[DESTROYED] &&\n        this.buffer.length === 0 &&\n        this[EOF]) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED])\n        this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit (ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !data ? false\n        : this[ASYNC] ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED])\n        return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      const ret = super.emit('error', data)\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA] (data) {\n    for (const p of this.pipes) {\n      if (p.dest.write(data) === false)\n        this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND] () {\n    if (this[EMITTED_END])\n      return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC])\n      defer(() => this[EMITEND2]())\n    else\n      this[EMITEND2]()\n  }\n\n  [EMITEND2] () {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this.pipes) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this.pipes) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect () {\n    const buf = []\n    if (!this[OBJECTMODE])\n      buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE])\n        buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat () {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING] ? buf.join('') : Buffer.concat(buf, buf.dataLength))\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise () {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR] () {\n    const next = () => {\n      const res = this.read()\n      if (res !== null)\n        return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF])\n        return Promise.resolve({ done: true })\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return { next }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR] () {\n    const next = () => {\n      const value = this.read()\n      const done = value === null\n      return { value, done }\n    }\n    return { next }\n  }\n\n  destroy (er) {\n    if (this[DESTROYED]) {\n      if (er)\n        this.emit('error', er)\n      else\n        this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this.buffer.length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED])\n      this.close()\n\n    if (er)\n      this.emit('error', er)\n    else // if no error to emit, still reject pending promises\n      this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream (s) {\n    return !!s && (s instanceof Minipass || s instanceof Stream ||\n      s instanceof EE && (\n        typeof s.pipe === 'function' || // readable\n        (typeof s.write === 'function' && typeof s.end === 'function') // writable\n      ))\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFPLENBQUMsc0JBQVE7QUFDM0IsZUFBZSxtQkFBTyxDQUFDLHNCQUFRO0FBQy9CLFdBQVcsMkVBQXVDOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdCQUF3Qjs7QUFFeEIsb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0I7QUFDdEIsd0JBQXdCOztBQUV4QixxQkFBcUI7QUFDckIsc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMseUJBQXlCOztBQUUxRDtBQUNBLGlDQUFpQyxZQUFZOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlDQUFpQztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQSxhQUFhO0FBQ2I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvbWluaXpsaWIvbm9kZV9tb2R1bGVzL21pbmlwYXNzL2luZGV4LmpzPzc0ZWYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5jb25zdCBwcm9jID0gdHlwZW9mIHByb2Nlc3MgPT09ICdvYmplY3QnICYmIHByb2Nlc3MgPyBwcm9jZXNzIDoge1xuICBzdGRvdXQ6IG51bGwsXG4gIHN0ZGVycjogbnVsbCxcbn1cbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBTRCA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyJykuU3RyaW5nRGVjb2RlclxuXG5jb25zdCBFT0YgPSBTeW1ib2woJ0VPRicpXG5jb25zdCBNQVlCRV9FTUlUX0VORCA9IFN5bWJvbCgnbWF5YmVFbWl0RW5kJylcbmNvbnN0IEVNSVRURURfRU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJylcbmNvbnN0IEVNSVRUSU5HX0VORCA9IFN5bWJvbCgnZW1pdHRpbmdFbmQnKVxuY29uc3QgRU1JVFRFRF9FUlJPUiA9IFN5bWJvbCgnZW1pdHRlZEVycm9yJylcbmNvbnN0IENMT1NFRCA9IFN5bWJvbCgnY2xvc2VkJylcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKVxuY29uc3QgRkxVU0ggPSBTeW1ib2woJ2ZsdXNoJylcbmNvbnN0IEZMVVNIQ0hVTksgPSBTeW1ib2woJ2ZsdXNoQ2h1bmsnKVxuY29uc3QgRU5DT0RJTkcgPSBTeW1ib2woJ2VuY29kaW5nJylcbmNvbnN0IERFQ09ERVIgPSBTeW1ib2woJ2RlY29kZXInKVxuY29uc3QgRkxPV0lORyA9IFN5bWJvbCgnZmxvd2luZycpXG5jb25zdCBQQVVTRUQgPSBTeW1ib2woJ3BhdXNlZCcpXG5jb25zdCBSRVNVTUUgPSBTeW1ib2woJ3Jlc3VtZScpXG5jb25zdCBCVUZGRVJMRU5HVEggPSBTeW1ib2woJ2J1ZmZlckxlbmd0aCcpXG5jb25zdCBCVUZGRVJQVVNIID0gU3ltYm9sKCdidWZmZXJQdXNoJylcbmNvbnN0IEJVRkZFUlNISUZUID0gU3ltYm9sKCdidWZmZXJTaGlmdCcpXG5jb25zdCBPQkpFQ1RNT0RFID0gU3ltYm9sKCdvYmplY3RNb2RlJylcbmNvbnN0IERFU1RST1lFRCA9IFN5bWJvbCgnZGVzdHJveWVkJylcbmNvbnN0IEVNSVREQVRBID0gU3ltYm9sKCdlbWl0RGF0YScpXG5jb25zdCBFTUlURU5EID0gU3ltYm9sKCdlbWl0RW5kJylcbmNvbnN0IEVNSVRFTkQyID0gU3ltYm9sKCdlbWl0RW5kMicpXG5jb25zdCBBU1lOQyA9IFN5bWJvbCgnYXN5bmMnKVxuXG5jb25zdCBkZWZlciA9IGZuID0+IFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZm4pXG5cbi8vIFRPRE8gcmVtb3ZlIHdoZW4gTm9kZSB2OCBzdXBwb3J0IGRyb3BzXG5jb25zdCBkb0l0ZXIgPSBnbG9iYWwuX01QX05PX0lURVJBVE9SX1NZTUJPTFNfICAhPT0gJzEnXG5jb25zdCBBU1lOQ0lURVJBVE9SID0gZG9JdGVyICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yXG4gIHx8IFN5bWJvbCgnYXN5bmNJdGVyYXRvciBub3QgaW1wbGVtZW50ZWQnKVxuY29uc3QgSVRFUkFUT1IgPSBkb0l0ZXIgJiYgU3ltYm9sLml0ZXJhdG9yXG4gIHx8IFN5bWJvbCgnaXRlcmF0b3Igbm90IGltcGxlbWVudGVkJylcblxuLy8gZXZlbnRzIHRoYXQgbWVhbiAndGhlIHN0cmVhbSBpcyBvdmVyJ1xuLy8gdGhlc2UgYXJlIHRyZWF0ZWQgc3BlY2lhbGx5LCBhbmQgcmUtZW1pdHRlZFxuLy8gaWYgdGhleSBhcmUgbGlzdGVuZWQgZm9yIGFmdGVyIGVtaXR0aW5nLlxuY29uc3QgaXNFbmRpc2ggPSBldiA9PlxuICBldiA9PT0gJ2VuZCcgfHxcbiAgZXYgPT09ICdmaW5pc2gnIHx8XG4gIGV2ID09PSAncHJlZmluaXNoJ1xuXG5jb25zdCBpc0FycmF5QnVmZmVyID0gYiA9PiBiIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgdHlwZW9mIGIgPT09ICdvYmplY3QnICYmXG4gIGIuY29uc3RydWN0b3IgJiZcbiAgYi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gIGIuYnl0ZUxlbmd0aCA+PSAwXG5cbmNvbnN0IGlzQXJyYXlCdWZmZXJWaWV3ID0gYiA9PiAhQnVmZmVyLmlzQnVmZmVyKGIpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKVxuXG5jbGFzcyBQaXBlIHtcbiAgY29uc3RydWN0b3IgKHNyYywgZGVzdCwgb3B0cykge1xuICAgIHRoaXMuc3JjID0gc3JjXG4gICAgdGhpcy5kZXN0ID0gZGVzdFxuICAgIHRoaXMub3B0cyA9IG9wdHNcbiAgICB0aGlzLm9uZHJhaW4gPSAoKSA9PiBzcmNbUkVTVU1FXSgpXG4gICAgZGVzdC5vbignZHJhaW4nLCB0aGlzLm9uZHJhaW4pXG4gIH1cbiAgdW5waXBlICgpIHtcbiAgICB0aGlzLmRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgdGhpcy5vbmRyYWluKVxuICB9XG4gIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0IC0gb25seSBoZXJlIGZvciB0aGUgcHJvdG90eXBlXG4gIHByb3h5RXJyb3JzICgpIHt9XG4gIGVuZCAoKSB7XG4gICAgdGhpcy51bnBpcGUoKVxuICAgIGlmICh0aGlzLm9wdHMuZW5kKVxuICAgICAgdGhpcy5kZXN0LmVuZCgpXG4gIH1cbn1cblxuY2xhc3MgUGlwZVByb3h5RXJyb3JzIGV4dGVuZHMgUGlwZSB7XG4gIHVucGlwZSAoKSB7XG4gICAgdGhpcy5zcmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycylcbiAgICBzdXBlci51bnBpcGUoKVxuICB9XG4gIGNvbnN0cnVjdG9yIChzcmMsIGRlc3QsIG9wdHMpIHtcbiAgICBzdXBlcihzcmMsIGRlc3QsIG9wdHMpXG4gICAgdGhpcy5wcm94eUVycm9ycyA9IGVyID0+IGRlc3QuZW1pdCgnZXJyb3InLCBlcilcbiAgICBzcmMub24oJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycylcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzIE1pbmlwYXNzIGV4dGVuZHMgU3RyZWFtIHtcbiAgY29uc3RydWN0b3IgKG9wdGlvbnMpIHtcbiAgICBzdXBlcigpXG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgLy8gd2hldGhlciB3ZSdyZSBleHBsaWNpdGx5IHBhdXNlZFxuICAgIHRoaXNbUEFVU0VEXSA9IGZhbHNlXG4gICAgdGhpcy5waXBlcyA9IFtdXG4gICAgdGhpcy5idWZmZXIgPSBbXVxuICAgIHRoaXNbT0JKRUNUTU9ERV0gPSBvcHRpb25zICYmIG9wdGlvbnMub2JqZWN0TW9kZSB8fCBmYWxzZVxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBudWxsXG4gICAgZWxzZVxuICAgICAgdGhpc1tFTkNPRElOR10gPSBvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcgfHwgbnVsbFxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSA9PT0gJ2J1ZmZlcicpXG4gICAgICB0aGlzW0VOQ09ESU5HXSA9IG51bGxcbiAgICB0aGlzW0FTWU5DXSA9IG9wdGlvbnMgJiYgISFvcHRpb25zLmFzeW5jIHx8IGZhbHNlXG4gICAgdGhpc1tERUNPREVSXSA9IHRoaXNbRU5DT0RJTkddID8gbmV3IFNEKHRoaXNbRU5DT0RJTkddKSA6IG51bGxcbiAgICB0aGlzW0VPRl0gPSBmYWxzZVxuICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gZmFsc2VcbiAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSBmYWxzZVxuICAgIHRoaXNbQ0xPU0VEXSA9IGZhbHNlXG4gICAgdGhpc1tFTUlUVEVEX0VSUk9SXSA9IG51bGxcbiAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSB0cnVlXG4gICAgdGhpc1tCVUZGRVJMRU5HVEhdID0gMFxuICAgIHRoaXNbREVTVFJPWUVEXSA9IGZhbHNlXG4gIH1cblxuICBnZXQgYnVmZmVyTGVuZ3RoICgpIHsgcmV0dXJuIHRoaXNbQlVGRkVSTEVOR1RIXSB9XG5cbiAgZ2V0IGVuY29kaW5nICgpIHsgcmV0dXJuIHRoaXNbRU5DT0RJTkddIH1cbiAgc2V0IGVuY29kaW5nIChlbmMpIHtcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IHNldCBlbmNvZGluZyBpbiBvYmplY3RNb2RlJylcblxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSAmJiBlbmMgIT09IHRoaXNbRU5DT0RJTkddICYmXG4gICAgICAgICh0aGlzW0RFQ09ERVJdICYmIHRoaXNbREVDT0RFUl0ubGFzdE5lZWQgfHwgdGhpc1tCVUZGRVJMRU5HVEhdKSlcbiAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IGNoYW5nZSBlbmNvZGluZycpXG5cbiAgICBpZiAodGhpc1tFTkNPRElOR10gIT09IGVuYykge1xuICAgICAgdGhpc1tERUNPREVSXSA9IGVuYyA/IG5ldyBTRChlbmMpIDogbnVsbFxuICAgICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aClcbiAgICAgICAgdGhpcy5idWZmZXIgPSB0aGlzLmJ1ZmZlci5tYXAoY2h1bmsgPT4gdGhpc1tERUNPREVSXS53cml0ZShjaHVuaykpXG4gICAgfVxuXG4gICAgdGhpc1tFTkNPRElOR10gPSBlbmNcbiAgfVxuXG4gIHNldEVuY29kaW5nIChlbmMpIHtcbiAgICB0aGlzLmVuY29kaW5nID0gZW5jXG4gIH1cblxuICBnZXQgb2JqZWN0TW9kZSAoKSB7IHJldHVybiB0aGlzW09CSkVDVE1PREVdIH1cbiAgc2V0IG9iamVjdE1vZGUgKG9tKSB7IHRoaXNbT0JKRUNUTU9ERV0gPSB0aGlzW09CSkVDVE1PREVdIHx8ICEhb20gfVxuXG4gIGdldCBbJ2FzeW5jJ10gKCkgeyByZXR1cm4gdGhpc1tBU1lOQ10gfVxuICBzZXQgWydhc3luYyddIChhKSB7IHRoaXNbQVNZTkNdID0gdGhpc1tBU1lOQ10gfHwgISFhIH1cblxuICB3cml0ZSAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICAgIGlmICh0aGlzW0VPRl0pXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3dyaXRlIGFmdGVyIGVuZCcpXG5cbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgbmV3IEVycm9yKCdDYW5ub3QgY2FsbCB3cml0ZSBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJyksXG4gICAgICAgIHsgY29kZTogJ0VSUl9TVFJFQU1fREVTVFJPWUVEJyB9XG4gICAgICApKVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBlbmNvZGluZywgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIGlmICghZW5jb2RpbmcpXG4gICAgICBlbmNvZGluZyA9ICd1dGY4J1xuXG4gICAgY29uc3QgZm4gPSB0aGlzW0FTWU5DXSA/IGRlZmVyIDogZiA9PiBmKClcblxuICAgIC8vIGNvbnZlcnQgYXJyYXkgYnVmZmVycyBhbmQgdHlwZWQgYXJyYXkgdmlld3MgaW50byBidWZmZXJzXG4gICAgLy8gYXQgc29tZSBwb2ludCBpbiB0aGUgZnV0dXJlLCB3ZSBtYXkgd2FudCB0byBkbyB0aGUgb3Bwb3NpdGUhXG4gICAgLy8gbGVhdmUgc3RyaW5ncyBhbmQgYnVmZmVycyBhcy1pc1xuICAgIC8vIGFueXRoaW5nIGVsc2Ugc3dpdGNoZXMgdXMgaW50byBvYmplY3QgbW9kZVxuICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgICAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuay5idWZmZXIsIGNodW5rLmJ5dGVPZmZzZXQsIGNodW5rLmJ5dGVMZW5ndGgpXG4gICAgICBlbHNlIGlmIChpc0FycmF5QnVmZmVyKGNodW5rKSlcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaylcbiAgICAgIGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycpXG4gICAgICAgIC8vIHVzZSB0aGUgc2V0dGVyIHNvIHdlIHRocm93IGlmIHdlIGhhdmUgZW5jb2Rpbmcgc2V0XG4gICAgICAgIHRoaXMub2JqZWN0TW9kZSA9IHRydWVcbiAgICB9XG5cbiAgICAvLyBoYW5kbGUgb2JqZWN0IG1vZGUgdXAgZnJvbnQsIHNpbmNlIGl0J3Mgc2ltcGxlclxuICAgIC8vIHRoaXMgeWllbGRzIGJldHRlciBwZXJmb3JtYW5jZSwgZmV3ZXIgY2hlY2tzIGxhdGVyLlxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLSBtYXliZSBpbXBvc3NpYmxlPyAqL1xuICAgICAgaWYgKHRoaXMuZmxvd2luZyAmJiB0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXNbRkxVU0hdKHRydWUpXG5cbiAgICAgIGlmICh0aGlzLmZsb3dpbmcpXG4gICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW0JVRkZFUlBVU0hdKGNodW5rKVxuXG4gICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcblxuICAgICAgaWYgKGNiKVxuICAgICAgICBmbihjYilcblxuICAgICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQgdGhlIGNodW5rIGlzIGEgYnVmZmVyIG9yIHN0cmluZ1xuICAgIC8vIGRvbid0IGJ1ZmZlciBpdCB1cCBvciBzZW5kIGl0IHRvIHRoZSBkZWNvZGVyXG4gICAgaWYgKCFjaHVuay5sZW5ndGgpIHtcbiAgICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICAgIHRoaXMuZW1pdCgncmVhZGFibGUnKVxuICAgICAgaWYgKGNiKVxuICAgICAgICBmbihjYilcbiAgICAgIHJldHVybiB0aGlzLmZsb3dpbmdcbiAgICB9XG5cbiAgICAvLyBmYXN0LXBhdGggd3JpdGluZyBzdHJpbmdzIG9mIHNhbWUgZW5jb2RpbmcgdG8gYSBzdHJlYW0gd2l0aFxuICAgIC8vIGFuIGVtcHR5IGJ1ZmZlciwgc2tpcHBpbmcgdGhlIGJ1ZmZlci9kZWNvZGVyIGRhbmNlXG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgLy8gdW5sZXNzIGl0IGlzIGEgc3RyaW5nIGFscmVhZHkgcmVhZHkgZm9yIHVzIHRvIHVzZVxuICAgICAgICAhKGVuY29kaW5nID09PSB0aGlzW0VOQ09ESU5HXSAmJiAhdGhpc1tERUNPREVSXS5sYXN0TmVlZCkpIHtcbiAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKVxuICAgIH1cblxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIoY2h1bmspICYmIHRoaXNbRU5DT0RJTkddKVxuICAgICAgY2h1bmsgPSB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKVxuXG4gICAgLy8gTm90ZTogZmx1c2hpbmcgQ0FOIHBvdGVudGlhbGx5IHN3aXRjaCB1cyBpbnRvIG5vdC1mbG93aW5nIG1vZGVcbiAgICBpZiAodGhpcy5mbG93aW5nICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgIHRoaXNbRkxVU0hdKHRydWUpXG5cbiAgICBpZiAodGhpcy5mbG93aW5nKVxuICAgICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspXG4gICAgZWxzZVxuICAgICAgdGhpc1tCVUZGRVJQVVNIXShjaHVuaylcblxuICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gIT09IDApXG4gICAgICB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcblxuICAgIGlmIChjYilcbiAgICAgIGZuKGNiKVxuXG4gICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICB9XG5cbiAgcmVhZCAobikge1xuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSA9PT0gMCB8fCBuID09PSAwIHx8IG4gPiB0aGlzW0JVRkZFUkxFTkdUSF0pIHtcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuXG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICBuID0gbnVsbFxuXG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDEgJiYgIXRoaXNbT0JKRUNUTU9ERV0pIHtcbiAgICAgIGlmICh0aGlzLmVuY29kaW5nKVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IFt0aGlzLmJ1ZmZlci5qb2luKCcnKV1cbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5idWZmZXIgPSBbQnVmZmVyLmNvbmNhdCh0aGlzLmJ1ZmZlciwgdGhpc1tCVUZGRVJMRU5HVEhdKV1cbiAgICB9XG5cbiAgICBjb25zdCByZXQgPSB0aGlzW1JFQURdKG4gfHwgbnVsbCwgdGhpcy5idWZmZXJbMF0pXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtSRUFEXSAobiwgY2h1bmspIHtcbiAgICBpZiAobiA9PT0gY2h1bmsubGVuZ3RoIHx8IG4gPT09IG51bGwpXG4gICAgICB0aGlzW0JVRkZFUlNISUZUXSgpXG4gICAgZWxzZSB7XG4gICAgICB0aGlzLmJ1ZmZlclswXSA9IGNodW5rLnNsaWNlKG4pXG4gICAgICBjaHVuayA9IGNodW5rLnNsaWNlKDAsIG4pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gblxuICAgIH1cblxuICAgIHRoaXMuZW1pdCgnZGF0YScsIGNodW5rKVxuXG4gICAgaWYgKCF0aGlzLmJ1ZmZlci5sZW5ndGggJiYgIXRoaXNbRU9GXSlcbiAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuXG4gICAgcmV0dXJuIGNodW5rXG4gIH1cblxuICBlbmQgKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKVxuICAgICAgY2IgPSBjaHVuaywgY2h1bmsgPSBudWxsXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgIGNiID0gZW5jb2RpbmcsIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgaWYgKGNodW5rKVxuICAgICAgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgaWYgKGNiKVxuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBjYilcbiAgICB0aGlzW0VPRl0gPSB0cnVlXG4gICAgdGhpcy53cml0YWJsZSA9IGZhbHNlXG5cbiAgICAvLyBpZiB3ZSBoYXZlbid0IHdyaXR0ZW4gYW55dGhpbmcsIHRoZW4gZ28gYWhlYWQgYW5kIGVtaXQsXG4gICAgLy8gZXZlbiBpZiB3ZSdyZSBub3QgcmVhZGluZy5cbiAgICAvLyB3ZSdsbCByZS1lbWl0IGlmIGEgbmV3ICdlbmQnIGxpc3RlbmVyIGlzIGFkZGVkIGFueXdheS5cbiAgICAvLyBUaGlzIG1ha2VzIE1QIG1vcmUgc3VpdGFibGUgdG8gd3JpdGUtb25seSB1c2UgY2FzZXMuXG4gICAgaWYgKHRoaXMuZmxvd2luZyB8fCAhdGhpc1tQQVVTRURdKVxuICAgICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICAvLyBkb24ndCBsZXQgdGhlIGludGVybmFsIHJlc3VtZSBiZSBvdmVyd3JpdHRlblxuICBbUkVTVU1FXSAoKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSlcbiAgICAgIHJldHVyblxuXG4gICAgdGhpc1tQQVVTRURdID0gZmFsc2VcbiAgICB0aGlzW0ZMT1dJTkddID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgncmVzdW1lJylcbiAgICBpZiAodGhpcy5idWZmZXIubGVuZ3RoKVxuICAgICAgdGhpc1tGTFVTSF0oKVxuICAgIGVsc2UgaWYgKHRoaXNbRU9GXSlcbiAgICAgIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICBlbHNlXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIHJlc3VtZSAoKSB7XG4gICAgcmV0dXJuIHRoaXNbUkVTVU1FXSgpXG4gIH1cblxuICBwYXVzZSAoKSB7XG4gICAgdGhpc1tGTE9XSU5HXSA9IGZhbHNlXG4gICAgdGhpc1tQQVVTRURdID0gdHJ1ZVxuICB9XG5cbiAgZ2V0IGRlc3Ryb3llZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbREVTVFJPWUVEXVxuICB9XG5cbiAgZ2V0IGZsb3dpbmcgKCkge1xuICAgIHJldHVybiB0aGlzW0ZMT1dJTkddXG4gIH1cblxuICBnZXQgcGF1c2VkICgpIHtcbiAgICByZXR1cm4gdGhpc1tQQVVTRURdXG4gIH1cblxuICBbQlVGRkVSUFVTSF0gKGNodW5rKSB7XG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gMVxuICAgIGVsc2VcbiAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSArPSBjaHVuay5sZW5ndGhcbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGNodW5rKVxuICB9XG5cbiAgW0JVRkZFUlNISUZUXSAoKSB7XG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCkge1xuICAgICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pXG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSAxXG4gICAgICBlbHNlXG4gICAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSB0aGlzLmJ1ZmZlclswXS5sZW5ndGhcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyLnNoaWZ0KClcbiAgfVxuXG4gIFtGTFVTSF0gKG5vRHJhaW4pIHtcbiAgICBkbyB7fSB3aGlsZSAodGhpc1tGTFVTSENIVU5LXSh0aGlzW0JVRkZFUlNISUZUXSgpKSlcblxuICAgIGlmICghbm9EcmFpbiAmJiAhdGhpcy5idWZmZXIubGVuZ3RoICYmICF0aGlzW0VPRl0pXG4gICAgICB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIFtGTFVTSENIVU5LXSAoY2h1bmspIHtcbiAgICByZXR1cm4gY2h1bmsgPyAodGhpcy5lbWl0KCdkYXRhJywgY2h1bmspLCB0aGlzLmZsb3dpbmcpIDogZmFsc2VcbiAgfVxuXG4gIHBpcGUgKGRlc3QsIG9wdHMpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG5cbiAgICBjb25zdCBlbmRlZCA9IHRoaXNbRU1JVFRFRF9FTkRdXG4gICAgb3B0cyA9IG9wdHMgfHwge31cbiAgICBpZiAoZGVzdCA9PT0gcHJvYy5zdGRvdXQgfHwgZGVzdCA9PT0gcHJvYy5zdGRlcnIpXG4gICAgICBvcHRzLmVuZCA9IGZhbHNlXG4gICAgZWxzZVxuICAgICAgb3B0cy5lbmQgPSBvcHRzLmVuZCAhPT0gZmFsc2VcbiAgICBvcHRzLnByb3h5RXJyb3JzID0gISFvcHRzLnByb3h5RXJyb3JzXG5cbiAgICAvLyBwaXBpbmcgYW4gZW5kZWQgc3RyZWFtIGVuZHMgaW1tZWRpYXRlbHlcbiAgICBpZiAoZW5kZWQpIHtcbiAgICAgIGlmIChvcHRzLmVuZClcbiAgICAgICAgZGVzdC5lbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnBpcGVzLnB1c2goIW9wdHMucHJveHlFcnJvcnMgPyBuZXcgUGlwZSh0aGlzLCBkZXN0LCBvcHRzKVxuICAgICAgICA6IG5ldyBQaXBlUHJveHlFcnJvcnModGhpcywgZGVzdCwgb3B0cykpXG4gICAgICBpZiAodGhpc1tBU1lOQ10pXG4gICAgICAgIGRlZmVyKCgpID0+IHRoaXNbUkVTVU1FXSgpKVxuICAgICAgZWxzZVxuICAgICAgICB0aGlzW1JFU1VNRV0oKVxuICAgIH1cblxuICAgIHJldHVybiBkZXN0XG4gIH1cblxuICB1bnBpcGUgKGRlc3QpIHtcbiAgICBjb25zdCBwID0gdGhpcy5waXBlcy5maW5kKHAgPT4gcC5kZXN0ID09PSBkZXN0KVxuICAgIGlmIChwKSB7XG4gICAgICB0aGlzLnBpcGVzLnNwbGljZSh0aGlzLnBpcGVzLmluZGV4T2YocCksIDEpXG4gICAgICBwLnVucGlwZSgpXG4gICAgfVxuICB9XG5cbiAgYWRkTGlzdGVuZXIgKGV2LCBmbikge1xuICAgIHJldHVybiB0aGlzLm9uKGV2LCBmbilcbiAgfVxuXG4gIG9uIChldiwgZm4pIHtcbiAgICBjb25zdCByZXQgPSBzdXBlci5vbihldiwgZm4pXG4gICAgaWYgKGV2ID09PSAnZGF0YScgJiYgIXRoaXMucGlwZXMubGVuZ3RoICYmICF0aGlzLmZsb3dpbmcpXG4gICAgICB0aGlzW1JFU1VNRV0oKVxuICAgIGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnICYmIHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMClcbiAgICAgIHN1cGVyLmVtaXQoJ3JlYWRhYmxlJylcbiAgICBlbHNlIGlmIChpc0VuZGlzaChldikgJiYgdGhpc1tFTUlUVEVEX0VORF0pIHtcbiAgICAgIHN1cGVyLmVtaXQoZXYpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhldilcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnZXJyb3InICYmIHRoaXNbRU1JVFRFRF9FUlJPUl0pIHtcbiAgICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgICAgZGVmZXIoKCkgPT4gZm4uY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKSlcbiAgICAgIGVsc2VcbiAgICAgICAgZm4uY2FsbCh0aGlzLCB0aGlzW0VNSVRURURfRVJST1JdKVxuICAgIH1cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBnZXQgZW1pdHRlZEVuZCAoKSB7XG4gICAgcmV0dXJuIHRoaXNbRU1JVFRFRF9FTkRdXG4gIH1cblxuICBbTUFZQkVfRU1JVF9FTkRdICgpIHtcbiAgICBpZiAoIXRoaXNbRU1JVFRJTkdfRU5EXSAmJlxuICAgICAgICAhdGhpc1tFTUlUVEVEX0VORF0gJiZcbiAgICAgICAgIXRoaXNbREVTVFJPWUVEXSAmJlxuICAgICAgICB0aGlzLmJ1ZmZlci5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgdGhpc1tFT0ZdKSB7XG4gICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSB0cnVlXG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpXG4gICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICBpZiAodGhpc1tDTE9TRURdKVxuICAgICAgICB0aGlzLmVtaXQoJ2Nsb3NlJylcbiAgICAgIHRoaXNbRU1JVFRJTkdfRU5EXSA9IGZhbHNlXG4gICAgfVxuICB9XG5cbiAgZW1pdCAoZXYsIGRhdGEsIC4uLmV4dHJhKSB7XG4gICAgLy8gZXJyb3IgYW5kIGNsb3NlIGFyZSBvbmx5IGV2ZW50cyBhbGxvd2VkIGFmdGVyIGNhbGxpbmcgZGVzdHJveSgpXG4gICAgaWYgKGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnY2xvc2UnICYmIGV2ICE9PSBERVNUUk9ZRUQgJiYgdGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG4gICAgZWxzZSBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgcmV0dXJuICFkYXRhID8gZmFsc2VcbiAgICAgICAgOiB0aGlzW0FTWU5DXSA/IGRlZmVyKCgpID0+IHRoaXNbRU1JVERBVEFdKGRhdGEpKVxuICAgICAgICA6IHRoaXNbRU1JVERBVEFdKGRhdGEpXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2VuZCcpIHtcbiAgICAgIHJldHVybiB0aGlzW0VNSVRFTkRdKClcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnY2xvc2UnKSB7XG4gICAgICB0aGlzW0NMT1NFRF0gPSB0cnVlXG4gICAgICAvLyBkb24ndCBlbWl0IGNsb3NlIGJlZm9yZSAnZW5kJyBhbmQgJ2ZpbmlzaCdcbiAgICAgIGlmICghdGhpc1tFTUlUVEVEX0VORF0gJiYgIXRoaXNbREVTVFJPWUVEXSlcbiAgICAgICAgcmV0dXJuXG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdjbG9zZScpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKVxuICAgICAgcmV0dXJuIHJldFxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdlcnJvcicpIHtcbiAgICAgIHRoaXNbRU1JVFRFRF9FUlJPUl0gPSBkYXRhXG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdlcnJvcicsIGRhdGEpXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ3Jlc3VtZScpIHtcbiAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ3Jlc3VtZScpXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2ZpbmlzaCcgfHwgZXYgPT09ICdwcmVmaW5pc2gnKSB7XG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KGV2KVxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgLy8gU29tZSBvdGhlciB1bmtub3duIGV2ZW50XG4gICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldiwgZGF0YSwgLi4uZXh0cmEpXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlUREFUQV0gKGRhdGEpIHtcbiAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5waXBlcykge1xuICAgICAgaWYgKHAuZGVzdC53cml0ZShkYXRhKSA9PT0gZmFsc2UpXG4gICAgICAgIHRoaXMucGF1c2UoKVxuICAgIH1cbiAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgW0VNSVRFTkRdICgpIHtcbiAgICBpZiAodGhpc1tFTUlUVEVEX0VORF0pXG4gICAgICByZXR1cm5cblxuICAgIHRoaXNbRU1JVFRFRF9FTkRdID0gdHJ1ZVxuICAgIHRoaXMucmVhZGFibGUgPSBmYWxzZVxuICAgIGlmICh0aGlzW0FTWU5DXSlcbiAgICAgIGRlZmVyKCgpID0+IHRoaXNbRU1JVEVORDJdKCkpXG4gICAgZWxzZVxuICAgICAgdGhpc1tFTUlURU5EMl0oKVxuICB9XG5cbiAgW0VNSVRFTkQyXSAoKSB7XG4gICAgaWYgKHRoaXNbREVDT0RFUl0pIHtcbiAgICAgIGNvbnN0IGRhdGEgPSB0aGlzW0RFQ09ERVJdLmVuZCgpXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBmb3IgKGNvbnN0IHAgb2YgdGhpcy5waXBlcykge1xuICAgICAgICAgIHAuZGVzdC53cml0ZShkYXRhKVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyLmVtaXQoJ2RhdGEnLCBkYXRhKVxuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzLnBpcGVzKSB7XG4gICAgICBwLmVuZCgpXG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ2VuZCcpXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLy8gY29uc3QgYWxsID0gYXdhaXQgc3RyZWFtLmNvbGxlY3QoKVxuICBjb2xsZWN0ICgpIHtcbiAgICBjb25zdCBidWYgPSBbXVxuICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgIGJ1Zi5kYXRhTGVuZ3RoID0gMFxuICAgIC8vIHNldCB0aGUgcHJvbWlzZSBmaXJzdCwgaW4gY2FzZSBhbiBlcnJvciBpcyByYWlzZWRcbiAgICAvLyBieSB0cmlnZ2VyaW5nIHRoZSBmbG93IGhlcmUuXG4gICAgY29uc3QgcCA9IHRoaXMucHJvbWlzZSgpXG4gICAgdGhpcy5vbignZGF0YScsIGMgPT4ge1xuICAgICAgYnVmLnB1c2goYylcbiAgICAgIGlmICghdGhpc1tPQkpFQ1RNT0RFXSlcbiAgICAgICAgYnVmLmRhdGFMZW5ndGggKz0gYy5sZW5ndGhcbiAgICB9KVxuICAgIHJldHVybiBwLnRoZW4oKCkgPT4gYnVmKVxuICB9XG5cbiAgLy8gY29uc3QgZGF0YSA9IGF3YWl0IHN0cmVhbS5jb25jYXQoKVxuICBjb25jYXQgKCkge1xuICAgIHJldHVybiB0aGlzW09CSkVDVE1PREVdXG4gICAgICA/IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJykpXG4gICAgICA6IHRoaXMuY29sbGVjdCgpLnRoZW4oYnVmID0+XG4gICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpKVxuICAgICAgICAgICAgOiB0aGlzW0VOQ09ESU5HXSA/IGJ1Zi5qb2luKCcnKSA6IEJ1ZmZlci5jb25jYXQoYnVmLCBidWYuZGF0YUxlbmd0aCkpXG4gIH1cblxuICAvLyBzdHJlYW0ucHJvbWlzZSgpLnRoZW4oKCkgPT4gZG9uZSwgZXIgPT4gZW1pdHRlZCBlcnJvcilcbiAgcHJvbWlzZSAoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMub24oREVTVFJPWUVELCAoKSA9PiByZWplY3QobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpKVxuICAgICAgdGhpcy5vbignZXJyb3InLCBlciA9PiByZWplY3QoZXIpKVxuICAgICAgdGhpcy5vbignZW5kJywgKCkgPT4gcmVzb2x2ZSgpKVxuICAgIH0pXG4gIH1cblxuICAvLyBmb3IgYXdhaXQgKGxldCBjaHVuayBvZiBzdHJlYW0pXG4gIFtBU1lOQ0lURVJBVE9SXSAoKSB7XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGNvbnN0IHJlcyA9IHRoaXMucmVhZCgpXG4gICAgICBpZiAocmVzICE9PSBudWxsKVxuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlOiByZXMgfSlcblxuICAgICAgaWYgKHRoaXNbRU9GXSlcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUgfSlcblxuICAgICAgbGV0IHJlc29sdmUgPSBudWxsXG4gICAgICBsZXQgcmVqZWN0ID0gbnVsbFxuICAgICAgY29uc3Qgb25lcnIgPSBlciA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICByZWplY3QoZXIpXG4gICAgICB9XG4gICAgICBjb25zdCBvbmRhdGEgPSB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLnBhdXNlKClcbiAgICAgICAgcmVzb2x2ZSh7IHZhbHVlOiB2YWx1ZSwgZG9uZTogISF0aGlzW0VPRl0gfSlcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKVxuICAgICAgICByZXNvbHZlKHsgZG9uZTogdHJ1ZSB9KVxuICAgICAgfVxuICAgICAgY29uc3Qgb25kZXN0cm95ID0gKCkgPT4gb25lcnIobmV3IEVycm9yKCdzdHJlYW0gZGVzdHJveWVkJykpXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICAgIHJlamVjdCA9IHJlalxuICAgICAgICByZXNvbHZlID0gcmVzXG4gICAgICAgIHRoaXMub25jZShERVNUUk9ZRUQsIG9uZGVzdHJveSlcbiAgICAgICAgdGhpcy5vbmNlKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLm9uY2UoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLm9uY2UoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICB9KVxuICAgIH1cblxuICAgIHJldHVybiB7IG5leHQgfVxuICB9XG5cbiAgLy8gZm9yIChsZXQgY2h1bmsgb2Ygc3RyZWFtKVxuICBbSVRFUkFUT1JdICgpIHtcbiAgICBjb25zdCBuZXh0ID0gKCkgPT4ge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlYWQoKVxuICAgICAgY29uc3QgZG9uZSA9IHZhbHVlID09PSBudWxsXG4gICAgICByZXR1cm4geyB2YWx1ZSwgZG9uZSB9XG4gICAgfVxuICAgIHJldHVybiB7IG5leHQgfVxuICB9XG5cbiAgZGVzdHJveSAoZXIpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSB7XG4gICAgICBpZiAoZXIpXG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIGVsc2VcbiAgICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcbiAgICAgIHJldHVybiB0aGlzXG4gICAgfVxuXG4gICAgdGhpc1tERVNUUk9ZRURdID0gdHJ1ZVxuXG4gICAgLy8gdGhyb3cgYXdheSBhbGwgYnVmZmVyZWQgZGF0YSwgaXQncyBuZXZlciBjb21pbmcgb3V0XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMFxuICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDBcblxuICAgIGlmICh0eXBlb2YgdGhpcy5jbG9zZSA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpc1tDTE9TRURdKVxuICAgICAgdGhpcy5jbG9zZSgpXG5cbiAgICBpZiAoZXIpXG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgZWxzZSAvLyBpZiBubyBlcnJvciB0byBlbWl0LCBzdGlsbCByZWplY3QgcGVuZGluZyBwcm9taXNlc1xuICAgICAgdGhpcy5lbWl0KERFU1RST1lFRClcblxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGF0aWMgaXNTdHJlYW0gKHMpIHtcbiAgICByZXR1cm4gISFzICYmIChzIGluc3RhbmNlb2YgTWluaXBhc3MgfHwgcyBpbnN0YW5jZW9mIFN0cmVhbSB8fFxuICAgICAgcyBpbnN0YW5jZW9mIEVFICYmIChcbiAgICAgICAgdHlwZW9mIHMucGlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCAvLyByZWFkYWJsZVxuICAgICAgICAodHlwZW9mIHMud3JpdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHMuZW5kID09PSAnZnVuY3Rpb24nKSAvLyB3cml0YWJsZVxuICAgICAgKSlcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/minizlib/node_modules/minipass/index.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/index.js":
/*!**************************************!*\
  !*** ./node_modules/mkdirp/index.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const optsArg = __webpack_require__(/*! ./lib/opts-arg.js */ \"./node_modules/mkdirp/lib/opts-arg.js\")\nconst pathArg = __webpack_require__(/*! ./lib/path-arg.js */ \"./node_modules/mkdirp/lib/path-arg.js\")\n\nconst {mkdirpNative, mkdirpNativeSync} = __webpack_require__(/*! ./lib/mkdirp-native.js */ \"./node_modules/mkdirp/lib/mkdirp-native.js\")\nconst {mkdirpManual, mkdirpManualSync} = __webpack_require__(/*! ./lib/mkdirp-manual.js */ \"./node_modules/mkdirp/lib/mkdirp-manual.js\")\nconst {useNative, useNativeSync} = __webpack_require__(/*! ./lib/use-native.js */ \"./node_modules/mkdirp/lib/use-native.js\")\n\n\nconst mkdirp = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNative(opts)\n    ? mkdirpNative(path, opts)\n    : mkdirpManual(path, opts)\n}\n\nconst mkdirpSync = (path, opts) => {\n  path = pathArg(path)\n  opts = optsArg(opts)\n  return useNativeSync(opts)\n    ? mkdirpNativeSync(path, opts)\n    : mkdirpManualSync(path, opts)\n}\n\nmkdirp.sync = mkdirpSync\nmkdirp.native = (path, opts) => mkdirpNative(pathArg(path), optsArg(opts))\nmkdirp.manual = (path, opts) => mkdirpManual(pathArg(path), optsArg(opts))\nmkdirp.nativeSync = (path, opts) => mkdirpNativeSync(pathArg(path), optsArg(opts))\nmkdirp.manualSync = (path, opts) => mkdirpManualSync(pathArg(path), optsArg(opts))\n\nmodule.exports = mkdirp\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBLGdCQUFnQixtQkFBTyxDQUFDLGdFQUFtQjtBQUMzQyxnQkFBZ0IsbUJBQU8sQ0FBQyxnRUFBbUI7O0FBRTNDLE9BQU8sZ0NBQWdDLEVBQUUsbUJBQU8sQ0FBQywwRUFBd0I7QUFDekUsT0FBTyxnQ0FBZ0MsRUFBRSxtQkFBTyxDQUFDLDBFQUF3QjtBQUN6RSxPQUFPLDBCQUEwQixFQUFFLG1CQUFPLENBQUMsb0VBQXFCOzs7QUFHaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvbWtkaXJwL2luZGV4LmpzP2U2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qgb3B0c0FyZyA9IHJlcXVpcmUoJy4vbGliL29wdHMtYXJnLmpzJylcbmNvbnN0IHBhdGhBcmcgPSByZXF1aXJlKCcuL2xpYi9wYXRoLWFyZy5qcycpXG5cbmNvbnN0IHtta2RpcnBOYXRpdmUsIG1rZGlycE5hdGl2ZVN5bmN9ID0gcmVxdWlyZSgnLi9saWIvbWtkaXJwLW5hdGl2ZS5qcycpXG5jb25zdCB7bWtkaXJwTWFudWFsLCBta2RpcnBNYW51YWxTeW5jfSA9IHJlcXVpcmUoJy4vbGliL21rZGlycC1tYW51YWwuanMnKVxuY29uc3Qge3VzZU5hdGl2ZSwgdXNlTmF0aXZlU3luY30gPSByZXF1aXJlKCcuL2xpYi91c2UtbmF0aXZlLmpzJylcblxuXG5jb25zdCBta2RpcnAgPSAocGF0aCwgb3B0cykgPT4ge1xuICBwYXRoID0gcGF0aEFyZyhwYXRoKVxuICBvcHRzID0gb3B0c0FyZyhvcHRzKVxuICByZXR1cm4gdXNlTmF0aXZlKG9wdHMpXG4gICAgPyBta2RpcnBOYXRpdmUocGF0aCwgb3B0cylcbiAgICA6IG1rZGlycE1hbnVhbChwYXRoLCBvcHRzKVxufVxuXG5jb25zdCBta2RpcnBTeW5jID0gKHBhdGgsIG9wdHMpID0+IHtcbiAgcGF0aCA9IHBhdGhBcmcocGF0aClcbiAgb3B0cyA9IG9wdHNBcmcob3B0cylcbiAgcmV0dXJuIHVzZU5hdGl2ZVN5bmMob3B0cylcbiAgICA/IG1rZGlycE5hdGl2ZVN5bmMocGF0aCwgb3B0cylcbiAgICA6IG1rZGlycE1hbnVhbFN5bmMocGF0aCwgb3B0cylcbn1cblxubWtkaXJwLnN5bmMgPSBta2RpcnBTeW5jXG5ta2RpcnAubmF0aXZlID0gKHBhdGgsIG9wdHMpID0+IG1rZGlycE5hdGl2ZShwYXRoQXJnKHBhdGgpLCBvcHRzQXJnKG9wdHMpKVxubWtkaXJwLm1hbnVhbCA9IChwYXRoLCBvcHRzKSA9PiBta2RpcnBNYW51YWwocGF0aEFyZyhwYXRoKSwgb3B0c0FyZyhvcHRzKSlcbm1rZGlycC5uYXRpdmVTeW5jID0gKHBhdGgsIG9wdHMpID0+IG1rZGlycE5hdGl2ZVN5bmMocGF0aEFyZyhwYXRoKSwgb3B0c0FyZyhvcHRzKSlcbm1rZGlycC5tYW51YWxTeW5jID0gKHBhdGgsIG9wdHMpID0+IG1rZGlycE1hbnVhbFN5bmMocGF0aEFyZyhwYXRoKSwgb3B0c0FyZyhvcHRzKSlcblxubW9kdWxlLmV4cG9ydHMgPSBta2RpcnBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/index.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/find-made.js":
/*!**********************************************!*\
  !*** ./node_modules/mkdirp/lib/find-made.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(/*! path */ \"path\")\n\nconst findMade = (opts, parent, path = undefined) => {\n  // we never want the 'made' return value to be a root directory\n  if (path === parent)\n    return Promise.resolve()\n\n  return opts.statAsync(parent).then(\n    st => st.isDirectory() ? path : undefined, // will fail later\n    er => er.code === 'ENOENT'\n      ? findMade(opts, dirname(parent), parent)\n      : undefined\n  )\n}\n\nconst findMadeSync = (opts, parent, path = undefined) => {\n  if (path === parent)\n    return undefined\n\n  try {\n    return opts.statSync(parent).isDirectory() ? path : undefined\n  } catch (er) {\n    return er.code === 'ENOENT'\n      ? findMadeSync(opts, dirname(parent), parent)\n      : undefined\n  }\n}\n\nmodule.exports = {findMade, findMadeSync}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9maW5kLW1hZGUuanMiLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxrQkFBTTs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL21rZGlycC9saWIvZmluZC1tYWRlLmpzPzM3YjAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge2Rpcm5hbWV9ID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IGZpbmRNYWRlID0gKG9wdHMsIHBhcmVudCwgcGF0aCA9IHVuZGVmaW5lZCkgPT4ge1xuICAvLyB3ZSBuZXZlciB3YW50IHRoZSAnbWFkZScgcmV0dXJuIHZhbHVlIHRvIGJlIGEgcm9vdCBkaXJlY3RvcnlcbiAgaWYgKHBhdGggPT09IHBhcmVudClcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKClcblxuICByZXR1cm4gb3B0cy5zdGF0QXN5bmMocGFyZW50KS50aGVuKFxuICAgIHN0ID0+IHN0LmlzRGlyZWN0b3J5KCkgPyBwYXRoIDogdW5kZWZpbmVkLCAvLyB3aWxsIGZhaWwgbGF0ZXJcbiAgICBlciA9PiBlci5jb2RlID09PSAnRU5PRU5UJ1xuICAgICAgPyBmaW5kTWFkZShvcHRzLCBkaXJuYW1lKHBhcmVudCksIHBhcmVudClcbiAgICAgIDogdW5kZWZpbmVkXG4gIClcbn1cblxuY29uc3QgZmluZE1hZGVTeW5jID0gKG9wdHMsIHBhcmVudCwgcGF0aCA9IHVuZGVmaW5lZCkgPT4ge1xuICBpZiAocGF0aCA9PT0gcGFyZW50KVxuICAgIHJldHVybiB1bmRlZmluZWRcblxuICB0cnkge1xuICAgIHJldHVybiBvcHRzLnN0YXRTeW5jKHBhcmVudCkuaXNEaXJlY3RvcnkoKSA/IHBhdGggOiB1bmRlZmluZWRcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gZXIuY29kZSA9PT0gJ0VOT0VOVCdcbiAgICAgID8gZmluZE1hZGVTeW5jKG9wdHMsIGRpcm5hbWUocGFyZW50KSwgcGFyZW50KVxuICAgICAgOiB1bmRlZmluZWRcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtmaW5kTWFkZSwgZmluZE1hZGVTeW5jfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/find-made.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/mkdirp-manual.js":
/*!**************************************************!*\
  !*** ./node_modules/mkdirp/lib/mkdirp-manual.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(/*! path */ \"path\")\n\nconst mkdirpManual = (path, opts, made) => {\n  opts.recursive = false\n  const parent = dirname(path)\n  if (parent === path) {\n    return opts.mkdirAsync(path, opts).catch(er => {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n    })\n  }\n\n  return opts.mkdirAsync(path, opts).then(() => made || path, er => {\n    if (er.code === 'ENOENT')\n      return mkdirpManual(parent, opts)\n        .then(made => mkdirpManual(path, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    return opts.statAsync(path).then(st => {\n      if (st.isDirectory())\n        return made\n      else\n        throw er\n    }, () => { throw er })\n  })\n}\n\nconst mkdirpManualSync = (path, opts, made) => {\n  const parent = dirname(path)\n  opts.recursive = false\n\n  if (parent === path) {\n    try {\n      return opts.mkdirSync(path, opts)\n    } catch (er) {\n      // swallowed by recursive implementation on posix systems\n      // any other error is a failure\n      if (er.code !== 'EISDIR')\n        throw er\n      else\n        return\n    }\n  }\n\n  try {\n    opts.mkdirSync(path, opts)\n    return made || path\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts, mkdirpManualSync(parent, opts, made))\n    if (er.code !== 'EEXIST' && er.code !== 'EROFS')\n      throw er\n    try {\n      if (!opts.statSync(path).isDirectory())\n        throw er\n    } catch (_) {\n      throw er\n    }\n  }\n}\n\nmodule.exports = {mkdirpManual, mkdirpManualSync}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9ta2RpcnAtbWFudWFsLmpzIiwibWFwcGluZ3MiOiJBQUFBLE9BQU8sU0FBUyxFQUFFLG1CQUFPLENBQUMsa0JBQU07O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxVQUFVLFVBQVU7QUFDekIsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy9ta2RpcnAvbGliL21rZGlycC1tYW51YWwuanM/MTEzZCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7ZGlybmFtZX0gPSByZXF1aXJlKCdwYXRoJylcblxuY29uc3QgbWtkaXJwTWFudWFsID0gKHBhdGgsIG9wdHMsIG1hZGUpID0+IHtcbiAgb3B0cy5yZWN1cnNpdmUgPSBmYWxzZVxuICBjb25zdCBwYXJlbnQgPSBkaXJuYW1lKHBhdGgpXG4gIGlmIChwYXJlbnQgPT09IHBhdGgpIHtcbiAgICByZXR1cm4gb3B0cy5ta2RpckFzeW5jKHBhdGgsIG9wdHMpLmNhdGNoKGVyID0+IHtcbiAgICAgIC8vIHN3YWxsb3dlZCBieSByZWN1cnNpdmUgaW1wbGVtZW50YXRpb24gb24gcG9zaXggc3lzdGVtc1xuICAgICAgLy8gYW55IG90aGVyIGVycm9yIGlzIGEgZmFpbHVyZVxuICAgICAgaWYgKGVyLmNvZGUgIT09ICdFSVNESVInKVxuICAgICAgICB0aHJvdyBlclxuICAgIH0pXG4gIH1cblxuICByZXR1cm4gb3B0cy5ta2RpckFzeW5jKHBhdGgsIG9wdHMpLnRoZW4oKCkgPT4gbWFkZSB8fCBwYXRoLCBlciA9PiB7XG4gICAgaWYgKGVyLmNvZGUgPT09ICdFTk9FTlQnKVxuICAgICAgcmV0dXJuIG1rZGlycE1hbnVhbChwYXJlbnQsIG9wdHMpXG4gICAgICAgIC50aGVuKG1hZGUgPT4gbWtkaXJwTWFudWFsKHBhdGgsIG9wdHMsIG1hZGUpKVxuICAgIGlmIChlci5jb2RlICE9PSAnRUVYSVNUJyAmJiBlci5jb2RlICE9PSAnRVJPRlMnKVxuICAgICAgdGhyb3cgZXJcbiAgICByZXR1cm4gb3B0cy5zdGF0QXN5bmMocGF0aCkudGhlbihzdCA9PiB7XG4gICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgcmV0dXJuIG1hZGVcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgZXJcbiAgICB9LCAoKSA9PiB7IHRocm93IGVyIH0pXG4gIH0pXG59XG5cbmNvbnN0IG1rZGlycE1hbnVhbFN5bmMgPSAocGF0aCwgb3B0cywgbWFkZSkgPT4ge1xuICBjb25zdCBwYXJlbnQgPSBkaXJuYW1lKHBhdGgpXG4gIG9wdHMucmVjdXJzaXZlID0gZmFsc2VcblxuICBpZiAocGFyZW50ID09PSBwYXRoKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBvcHRzLm1rZGlyU3luYyhwYXRoLCBvcHRzKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAvLyBzd2FsbG93ZWQgYnkgcmVjdXJzaXZlIGltcGxlbWVudGF0aW9uIG9uIHBvc2l4IHN5c3RlbXNcbiAgICAgIC8vIGFueSBvdGhlciBlcnJvciBpcyBhIGZhaWx1cmVcbiAgICAgIGlmIChlci5jb2RlICE9PSAnRUlTRElSJylcbiAgICAgICAgdGhyb3cgZXJcbiAgICAgIGVsc2VcbiAgICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBvcHRzLm1rZGlyU3luYyhwYXRoLCBvcHRzKVxuICAgIHJldHVybiBtYWRlIHx8IHBhdGhcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpXG4gICAgICByZXR1cm4gbWtkaXJwTWFudWFsU3luYyhwYXRoLCBvcHRzLCBta2RpcnBNYW51YWxTeW5jKHBhcmVudCwgb3B0cywgbWFkZSkpXG4gICAgaWYgKGVyLmNvZGUgIT09ICdFRVhJU1QnICYmIGVyLmNvZGUgIT09ICdFUk9GUycpXG4gICAgICB0aHJvdyBlclxuICAgIHRyeSB7XG4gICAgICBpZiAoIW9wdHMuc3RhdFN5bmMocGF0aCkuaXNEaXJlY3RvcnkoKSlcbiAgICAgICAgdGhyb3cgZXJcbiAgICB9IGNhdGNoIChfKSB7XG4gICAgICB0aHJvdyBlclxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtta2RpcnBNYW51YWwsIG1rZGlycE1hbnVhbFN5bmN9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/mkdirp-manual.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/mkdirp-native.js":
/*!**************************************************!*\
  !*** ./node_modules/mkdirp/lib/mkdirp-native.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const {dirname} = __webpack_require__(/*! path */ \"path\")\nconst {findMade, findMadeSync} = __webpack_require__(/*! ./find-made.js */ \"./node_modules/mkdirp/lib/find-made.js\")\nconst {mkdirpManual, mkdirpManualSync} = __webpack_require__(/*! ./mkdirp-manual.js */ \"./node_modules/mkdirp/lib/mkdirp-manual.js\")\n\nconst mkdirpNative = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirAsync(path, opts)\n\n  return findMade(opts, path).then(made =>\n    opts.mkdirAsync(path, opts).then(() => made)\n    .catch(er => {\n      if (er.code === 'ENOENT')\n        return mkdirpManual(path, opts)\n      else\n        throw er\n    }))\n}\n\nconst mkdirpNativeSync = (path, opts) => {\n  opts.recursive = true\n  const parent = dirname(path)\n  if (parent === path)\n    return opts.mkdirSync(path, opts)\n\n  const made = findMadeSync(opts, path)\n  try {\n    opts.mkdirSync(path, opts)\n    return made\n  } catch (er) {\n    if (er.code === 'ENOENT')\n      return mkdirpManualSync(path, opts)\n    else\n      throw er\n  }\n}\n\nmodule.exports = {mkdirpNative, mkdirpNativeSync}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9ta2RpcnAtbmF0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFBLE9BQU8sU0FBUyxFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDaEMsT0FBTyx3QkFBd0IsRUFBRSxtQkFBTyxDQUFDLDhEQUFnQjtBQUN6RCxPQUFPLGdDQUFnQyxFQUFFLG1CQUFPLENBQUMsc0VBQW9COztBQUVyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9ta2RpcnAtbmF0aXZlLmpzP2FiYTgiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3Qge2Rpcm5hbWV9ID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCB7ZmluZE1hZGUsIGZpbmRNYWRlU3luY30gPSByZXF1aXJlKCcuL2ZpbmQtbWFkZS5qcycpXG5jb25zdCB7bWtkaXJwTWFudWFsLCBta2RpcnBNYW51YWxTeW5jfSA9IHJlcXVpcmUoJy4vbWtkaXJwLW1hbnVhbC5qcycpXG5cbmNvbnN0IG1rZGlycE5hdGl2ZSA9IChwYXRoLCBvcHRzKSA9PiB7XG4gIG9wdHMucmVjdXJzaXZlID0gdHJ1ZVxuICBjb25zdCBwYXJlbnQgPSBkaXJuYW1lKHBhdGgpXG4gIGlmIChwYXJlbnQgPT09IHBhdGgpXG4gICAgcmV0dXJuIG9wdHMubWtkaXJBc3luYyhwYXRoLCBvcHRzKVxuXG4gIHJldHVybiBmaW5kTWFkZShvcHRzLCBwYXRoKS50aGVuKG1hZGUgPT5cbiAgICBvcHRzLm1rZGlyQXN5bmMocGF0aCwgb3B0cykudGhlbigoKSA9PiBtYWRlKVxuICAgIC5jYXRjaChlciA9PiB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpXG4gICAgICAgIHJldHVybiBta2RpcnBNYW51YWwocGF0aCwgb3B0cylcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgZXJcbiAgICB9KSlcbn1cblxuY29uc3QgbWtkaXJwTmF0aXZlU3luYyA9IChwYXRoLCBvcHRzKSA9PiB7XG4gIG9wdHMucmVjdXJzaXZlID0gdHJ1ZVxuICBjb25zdCBwYXJlbnQgPSBkaXJuYW1lKHBhdGgpXG4gIGlmIChwYXJlbnQgPT09IHBhdGgpXG4gICAgcmV0dXJuIG9wdHMubWtkaXJTeW5jKHBhdGgsIG9wdHMpXG5cbiAgY29uc3QgbWFkZSA9IGZpbmRNYWRlU3luYyhvcHRzLCBwYXRoKVxuICB0cnkge1xuICAgIG9wdHMubWtkaXJTeW5jKHBhdGgsIG9wdHMpXG4gICAgcmV0dXJuIG1hZGVcbiAgfSBjYXRjaCAoZXIpIHtcbiAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpXG4gICAgICByZXR1cm4gbWtkaXJwTWFudWFsU3luYyhwYXRoLCBvcHRzKVxuICAgIGVsc2VcbiAgICAgIHRocm93IGVyXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7bWtkaXJwTmF0aXZlLCBta2RpcnBOYXRpdmVTeW5jfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/mkdirp-native.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/opts-arg.js":
/*!*********************************************!*\
  !*** ./node_modules/mkdirp/lib/opts-arg.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const { promisify } = __webpack_require__(/*! util */ \"util\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst optsArg = opts => {\n  if (!opts)\n    opts = { mode: 0o777, fs }\n  else if (typeof opts === 'object')\n    opts = { mode: 0o777, fs, ...opts }\n  else if (typeof opts === 'number')\n    opts = { mode: opts, fs }\n  else if (typeof opts === 'string')\n    opts = { mode: parseInt(opts, 8), fs }\n  else\n    throw new TypeError('invalid options argument')\n\n  opts.mkdir = opts.mkdir || opts.fs.mkdir || fs.mkdir\n  opts.mkdirAsync = promisify(opts.mkdir)\n  opts.stat = opts.stat || opts.fs.stat || fs.stat\n  opts.statAsync = promisify(opts.stat)\n  opts.statSync = opts.statSync || opts.fs.statSync || fs.statSync\n  opts.mkdirSync = opts.mkdirSync || opts.fs.mkdirSync || fs.mkdirSync\n  return opts\n}\nmodule.exports = optsArg\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9vcHRzLWFyZy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxRQUFRLFlBQVksRUFBRSxtQkFBTyxDQUFDLGtCQUFNO0FBQ3BDLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQSxhQUFhO0FBQ2I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL21rZGlycC9saWIvb3B0cy1hcmcuanM/NTNlNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCB7IHByb21pc2lmeSB9ID0gcmVxdWlyZSgndXRpbCcpXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IG9wdHNBcmcgPSBvcHRzID0+IHtcbiAgaWYgKCFvcHRzKVxuICAgIG9wdHMgPSB7IG1vZGU6IDBvNzc3LCBmcyB9XG4gIGVsc2UgaWYgKHR5cGVvZiBvcHRzID09PSAnb2JqZWN0JylcbiAgICBvcHRzID0geyBtb2RlOiAwbzc3NywgZnMsIC4uLm9wdHMgfVxuICBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ251bWJlcicpXG4gICAgb3B0cyA9IHsgbW9kZTogb3B0cywgZnMgfVxuICBlbHNlIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ3N0cmluZycpXG4gICAgb3B0cyA9IHsgbW9kZTogcGFyc2VJbnQob3B0cywgOCksIGZzIH1cbiAgZWxzZVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgb3B0aW9ucyBhcmd1bWVudCcpXG5cbiAgb3B0cy5ta2RpciA9IG9wdHMubWtkaXIgfHwgb3B0cy5mcy5ta2RpciB8fCBmcy5ta2RpclxuICBvcHRzLm1rZGlyQXN5bmMgPSBwcm9taXNpZnkob3B0cy5ta2RpcilcbiAgb3B0cy5zdGF0ID0gb3B0cy5zdGF0IHx8IG9wdHMuZnMuc3RhdCB8fCBmcy5zdGF0XG4gIG9wdHMuc3RhdEFzeW5jID0gcHJvbWlzaWZ5KG9wdHMuc3RhdClcbiAgb3B0cy5zdGF0U3luYyA9IG9wdHMuc3RhdFN5bmMgfHwgb3B0cy5mcy5zdGF0U3luYyB8fCBmcy5zdGF0U3luY1xuICBvcHRzLm1rZGlyU3luYyA9IG9wdHMubWtkaXJTeW5jIHx8IG9wdHMuZnMubWtkaXJTeW5jIHx8IGZzLm1rZGlyU3luY1xuICByZXR1cm4gb3B0c1xufVxubW9kdWxlLmV4cG9ydHMgPSBvcHRzQXJnXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/opts-arg.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/path-arg.js":
/*!*********************************************!*\
  !*** ./node_modules/mkdirp/lib/path-arg.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const platform = {}.__TESTING_MKDIRP_PLATFORM__ || process.platform\nconst { resolve, parse } = __webpack_require__(/*! path */ \"path\")\nconst pathArg = path => {\n  if (/\\0/.test(path)) {\n    // simulate same failure that node raises\n    throw Object.assign(\n      new TypeError('path must be a string without null bytes'),\n      {\n        path,\n        code: 'ERR_INVALID_ARG_VALUE',\n      }\n    )\n  }\n\n  path = resolve(path)\n  if (platform === 'win32') {\n    const badWinChars = /[*|\"<>?:]/\n    const {root} = parse(path)\n    if (badWinChars.test(path.substr(root.length))) {\n      throw Object.assign(new Error('Illegal characters in path.'), {\n        path,\n        code: 'EINVAL',\n      })\n    }\n  }\n\n  return path\n}\nmodule.exports = pathArg\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi9wYXRoLWFyZy5qcyIsIm1hcHBpbmdzIjoiQUFBQSxpQkFBaUIsRUFBVztBQUM1QixRQUFRLGlCQUFpQixFQUFFLG1CQUFPLENBQUMsa0JBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL21rZGlycC9saWIvcGF0aC1hcmcuanM/NWRmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52Ll9fVEVTVElOR19NS0RJUlBfUExBVEZPUk1fXyB8fCBwcm9jZXNzLnBsYXRmb3JtXG5jb25zdCB7IHJlc29sdmUsIHBhcnNlIH0gPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHBhdGhBcmcgPSBwYXRoID0+IHtcbiAgaWYgKC9cXDAvLnRlc3QocGF0aCkpIHtcbiAgICAvLyBzaW11bGF0ZSBzYW1lIGZhaWx1cmUgdGhhdCBub2RlIHJhaXNlc1xuICAgIHRocm93IE9iamVjdC5hc3NpZ24oXG4gICAgICBuZXcgVHlwZUVycm9yKCdwYXRoIG11c3QgYmUgYSBzdHJpbmcgd2l0aG91dCBudWxsIGJ5dGVzJyksXG4gICAgICB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIGNvZGU6ICdFUlJfSU5WQUxJRF9BUkdfVkFMVUUnLFxuICAgICAgfVxuICAgIClcbiAgfVxuXG4gIHBhdGggPSByZXNvbHZlKHBhdGgpXG4gIGlmIChwbGF0Zm9ybSA9PT0gJ3dpbjMyJykge1xuICAgIGNvbnN0IGJhZFdpbkNoYXJzID0gL1sqfFwiPD4/Ol0vXG4gICAgY29uc3Qge3Jvb3R9ID0gcGFyc2UocGF0aClcbiAgICBpZiAoYmFkV2luQ2hhcnMudGVzdChwYXRoLnN1YnN0cihyb290Lmxlbmd0aCkpKSB7XG4gICAgICB0aHJvdyBPYmplY3QuYXNzaWduKG5ldyBFcnJvcignSWxsZWdhbCBjaGFyYWN0ZXJzIGluIHBhdGguJyksIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgY29kZTogJ0VJTlZBTCcsXG4gICAgICB9KVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYXRoXG59XG5tb2R1bGUuZXhwb3J0cyA9IHBhdGhBcmdcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/path-arg.js\n");

/***/ }),

/***/ "./node_modules/mkdirp/lib/use-native.js":
/*!***********************************************!*\
  !*** ./node_modules/mkdirp/lib/use-native.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("const fs = __webpack_require__(/*! fs */ \"fs\")\n\nconst version = {}.__TESTING_MKDIRP_NODE_VERSION__ || process.version\nconst versArr = version.replace(/^v/, '').split('.')\nconst hasNative = +versArr[0] > 10 || +versArr[0] === 10 && +versArr[1] >= 12\n\nconst useNative = !hasNative ? () => false : opts => opts.mkdir === fs.mkdir\nconst useNativeSync = !hasNative ? () => false : opts => opts.mkdirSync === fs.mkdirSync\n\nmodule.exports = {useNative, useNativeSync}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbWtkaXJwL2xpYi91c2UtbmF0aXZlLmpzIiwibWFwcGluZ3MiOiJBQUFBLFdBQVcsbUJBQU8sQ0FBQyxjQUFJOztBQUV2QixnQkFBZ0IsRUFBVztBQUMzQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy9ta2RpcnAvbGliL3VzZS1uYXRpdmUuanM/ZWViNiJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcblxuY29uc3QgdmVyc2lvbiA9IHByb2Nlc3MuZW52Ll9fVEVTVElOR19NS0RJUlBfTk9ERV9WRVJTSU9OX18gfHwgcHJvY2Vzcy52ZXJzaW9uXG5jb25zdCB2ZXJzQXJyID0gdmVyc2lvbi5yZXBsYWNlKC9edi8sICcnKS5zcGxpdCgnLicpXG5jb25zdCBoYXNOYXRpdmUgPSArdmVyc0FyclswXSA+IDEwIHx8ICt2ZXJzQXJyWzBdID09PSAxMCAmJiArdmVyc0FyclsxXSA+PSAxMlxuXG5jb25zdCB1c2VOYXRpdmUgPSAhaGFzTmF0aXZlID8gKCkgPT4gZmFsc2UgOiBvcHRzID0+IG9wdHMubWtkaXIgPT09IGZzLm1rZGlyXG5jb25zdCB1c2VOYXRpdmVTeW5jID0gIWhhc05hdGl2ZSA/ICgpID0+IGZhbHNlIDogb3B0cyA9PiBvcHRzLm1rZGlyU3luYyA9PT0gZnMubWtkaXJTeW5jXG5cbm1vZHVsZS5leHBvcnRzID0ge3VzZU5hdGl2ZSwgdXNlTmF0aXZlU3luY31cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/mkdirp/lib/use-native.js\n");

/***/ }),

/***/ "./node_modules/tar/index.js":
/*!***********************************!*\
  !*** ./node_modules/tar/index.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\n\n// high-level commands\nexports.c = exports.create = __webpack_require__(/*! ./lib/create.js */ \"./node_modules/tar/lib/create.js\")\nexports.r = exports.replace = __webpack_require__(/*! ./lib/replace.js */ \"./node_modules/tar/lib/replace.js\")\nexports.t = exports.list = __webpack_require__(/*! ./lib/list.js */ \"./node_modules/tar/lib/list.js\")\nexports.u = exports.update = __webpack_require__(/*! ./lib/update.js */ \"./node_modules/tar/lib/update.js\")\nexports.x = exports.extract = __webpack_require__(/*! ./lib/extract.js */ \"./node_modules/tar/lib/extract.js\")\n\n// classes\nexports.Pack = __webpack_require__(/*! ./lib/pack.js */ \"./node_modules/tar/lib/pack.js\")\nexports.Unpack = __webpack_require__(/*! ./lib/unpack.js */ \"./node_modules/tar/lib/unpack.js\")\nexports.Parse = __webpack_require__(/*! ./lib/parse.js */ \"./node_modules/tar/lib/parse.js\")\nexports.ReadEntry = __webpack_require__(/*! ./lib/read-entry.js */ \"./node_modules/tar/lib/read-entry.js\")\nexports.WriteEntry = __webpack_require__(/*! ./lib/write-entry.js */ \"./node_modules/tar/lib/write-entry.js\")\nexports.Header = __webpack_require__(/*! ./lib/header.js */ \"./node_modules/tar/lib/header.js\")\nexports.Pax = __webpack_require__(/*! ./lib/pax.js */ \"./node_modules/tar/lib/pax.js\")\nexports.types = __webpack_require__(/*! ./lib/types.js */ \"./node_modules/tar/lib/types.js\")\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsU0FBUyxHQUFHLCtGQUEyQztBQUN2RCxTQUFTLEdBQUcsa0dBQTZDO0FBQ3pELFNBQVMsR0FBRyx5RkFBdUM7QUFDbkQsU0FBUyxHQUFHLCtGQUEyQztBQUN2RCxTQUFTLEdBQUcsa0dBQTZDOztBQUV6RDtBQUNBLHlGQUF1QztBQUN2QywrRkFBMkM7QUFDM0MsNEZBQXlDO0FBQ3pDLDBHQUFrRDtBQUNsRCw2R0FBb0Q7QUFDcEQsK0ZBQTJDO0FBQzNDLHNGQUFxQztBQUNyQyw0RkFBeUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3Rhci9pbmRleC5qcz84ZWY4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBoaWdoLWxldmVsIGNvbW1hbmRzXG5leHBvcnRzLmMgPSBleHBvcnRzLmNyZWF0ZSA9IHJlcXVpcmUoJy4vbGliL2NyZWF0ZS5qcycpXG5leHBvcnRzLnIgPSBleHBvcnRzLnJlcGxhY2UgPSByZXF1aXJlKCcuL2xpYi9yZXBsYWNlLmpzJylcbmV4cG9ydHMudCA9IGV4cG9ydHMubGlzdCA9IHJlcXVpcmUoJy4vbGliL2xpc3QuanMnKVxuZXhwb3J0cy51ID0gZXhwb3J0cy51cGRhdGUgPSByZXF1aXJlKCcuL2xpYi91cGRhdGUuanMnKVxuZXhwb3J0cy54ID0gZXhwb3J0cy5leHRyYWN0ID0gcmVxdWlyZSgnLi9saWIvZXh0cmFjdC5qcycpXG5cbi8vIGNsYXNzZXNcbmV4cG9ydHMuUGFjayA9IHJlcXVpcmUoJy4vbGliL3BhY2suanMnKVxuZXhwb3J0cy5VbnBhY2sgPSByZXF1aXJlKCcuL2xpYi91bnBhY2suanMnKVxuZXhwb3J0cy5QYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlLmpzJylcbmV4cG9ydHMuUmVhZEVudHJ5ID0gcmVxdWlyZSgnLi9saWIvcmVhZC1lbnRyeS5qcycpXG5leHBvcnRzLldyaXRlRW50cnkgPSByZXF1aXJlKCcuL2xpYi93cml0ZS1lbnRyeS5qcycpXG5leHBvcnRzLkhlYWRlciA9IHJlcXVpcmUoJy4vbGliL2hlYWRlci5qcycpXG5leHBvcnRzLlBheCA9IHJlcXVpcmUoJy4vbGliL3BheC5qcycpXG5leHBvcnRzLnR5cGVzID0gcmVxdWlyZSgnLi9saWIvdHlwZXMuanMnKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/index.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/create.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/create.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -c\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\n\nconst Pack = __webpack_require__(/*! ./pack.js */ \"./node_modules/tar/lib/pack.js\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst t = __webpack_require__(/*! ./list.js */ \"./node_modules/tar/lib/list.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof files === 'function') {\n    cb = files\n  }\n\n  if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  return opt.file && opt.sync ? createFileSync(opt, files)\n    : opt.file ? createFile(opt, files, cb)\n    : opt.sync ? createSync(opt, files)\n    : create(opt, files)\n}\n\nconst createFileSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst createFile = (opt, files, cb) => {\n  const p = new Pack(opt)\n  const stream = new fsm.WriteStream(opt.file, {\n    mode: opt.mode || 0o666,\n  })\n  p.pipe(stream)\n\n  const promise = new Promise((res, rej) => {\n    stream.on('error', rej)\n    stream.on('close', res)\n    p.on('error', rej)\n  })\n\n  addFilesAsync(p, files)\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n\nconst createSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n  addFilesSync(p, files)\n  return p\n}\n\nconst create = (opt, files) => {\n  const p = new Pack(opt)\n  addFilesAsync(p, files)\n  return p\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9jcmVhdGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQSxZQUFZLG1CQUFPLENBQUMscUVBQXFCOztBQUV6QyxhQUFhLG1CQUFPLENBQUMsaURBQVc7QUFDaEMsWUFBWSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2pDLFVBQVUsbUJBQU8sQ0FBQyxpREFBVztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvY3JlYXRlLmpzPzc4NTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHRhciAtY1xuY29uc3QgaGxvID0gcmVxdWlyZSgnLi9oaWdoLWxldmVsLW9wdC5qcycpXG5cbmNvbnN0IFBhY2sgPSByZXF1aXJlKCcuL3BhY2suanMnKVxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnMtbWluaXBhc3MnKVxuY29uc3QgdCA9IHJlcXVpcmUoJy4vbGlzdC5qcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbm1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBpZiAodHlwZW9mIGZpbGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBmaWxlc1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob3B0XykpIHtcbiAgICBmaWxlcyA9IG9wdF8sIG9wdF8gPSB7fVxuICB9XG5cbiAgaWYgKCFmaWxlcyB8fCAhQXJyYXkuaXNBcnJheShmaWxlcykgfHwgIWZpbGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGZpbGVzIG9yIGRpcmVjdG9yaWVzIHNwZWNpZmllZCcpXG4gIH1cblxuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG5cbiAgY29uc3Qgb3B0ID0gaGxvKG9wdF8pXG5cbiAgaWYgKG9wdC5zeW5jICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG5vdCBzdXBwb3J0ZWQgZm9yIHN5bmMgdGFyIGZ1bmN0aW9ucycpXG4gIH1cblxuICBpZiAoIW9wdC5maWxlICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG9ubHkgc3VwcG9ydGVkIHdpdGggZmlsZSBvcHRpb24nKVxuICB9XG5cbiAgcmV0dXJuIG9wdC5maWxlICYmIG9wdC5zeW5jID8gY3JlYXRlRmlsZVN5bmMob3B0LCBmaWxlcylcbiAgICA6IG9wdC5maWxlID8gY3JlYXRlRmlsZShvcHQsIGZpbGVzLCBjYilcbiAgICA6IG9wdC5zeW5jID8gY3JlYXRlU3luYyhvcHQsIGZpbGVzKVxuICAgIDogY3JlYXRlKG9wdCwgZmlsZXMpXG59XG5cbmNvbnN0IGNyZWF0ZUZpbGVTeW5jID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBQYWNrLlN5bmMob3B0KVxuICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLldyaXRlU3RyZWFtU3luYyhvcHQuZmlsZSwge1xuICAgIG1vZGU6IG9wdC5tb2RlIHx8IDBvNjY2LFxuICB9KVxuICBwLnBpcGUoc3RyZWFtKVxuICBhZGRGaWxlc1N5bmMocCwgZmlsZXMpXG59XG5cbmNvbnN0IGNyZWF0ZUZpbGUgPSAob3B0LCBmaWxlcywgY2IpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBQYWNrKG9wdClcbiAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5Xcml0ZVN0cmVhbShvcHQuZmlsZSwge1xuICAgIG1vZGU6IG9wdC5tb2RlIHx8IDBvNjY2LFxuICB9KVxuICBwLnBpcGUoc3RyZWFtKVxuXG4gIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqKVxuICAgIHN0cmVhbS5vbignY2xvc2UnLCByZXMpXG4gICAgcC5vbignZXJyb3InLCByZWopXG4gIH0pXG5cbiAgYWRkRmlsZXNBc3luYyhwLCBmaWxlcylcblxuICByZXR1cm4gY2IgPyBwcm9taXNlLnRoZW4oY2IsIGNiKSA6IHByb21pc2Vcbn1cblxuY29uc3QgYWRkRmlsZXNTeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIGZpbGVzLmZvckVhY2goZmlsZSA9PiB7XG4gICAgaWYgKGZpbGUuY2hhckF0KDApID09PSAnQCcpIHtcbiAgICAgIHQoe1xuICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc2xpY2UoMSkpLFxuICAgICAgICBzeW5jOiB0cnVlLFxuICAgICAgICBub1Jlc3VtZTogdHJ1ZSxcbiAgICAgICAgb25lbnRyeTogZW50cnkgPT4gcC5hZGQoZW50cnkpLFxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgcC5hZGQoZmlsZSlcbiAgICB9XG4gIH0pXG4gIHAuZW5kKClcbn1cblxuY29uc3QgYWRkRmlsZXNBc3luYyA9IChwLCBmaWxlcykgPT4ge1xuICB3aGlsZSAoZmlsZXMubGVuZ3RoKSB7XG4gICAgY29uc3QgZmlsZSA9IGZpbGVzLnNoaWZ0KClcbiAgICBpZiAoZmlsZS5jaGFyQXQoMCkgPT09ICdAJykge1xuICAgICAgcmV0dXJuIHQoe1xuICAgICAgICBmaWxlOiBwYXRoLnJlc29sdmUocC5jd2QsIGZpbGUuc2xpY2UoMSkpLFxuICAgICAgICBub1Jlc3VtZTogdHJ1ZSxcbiAgICAgICAgb25lbnRyeTogZW50cnkgPT4gcC5hZGQoZW50cnkpLFxuICAgICAgfSkudGhlbihfID0+IGFkZEZpbGVzQXN5bmMocCwgZmlsZXMpKVxuICAgIH0gZWxzZSB7XG4gICAgICBwLmFkZChmaWxlKVxuICAgIH1cbiAgfVxuICBwLmVuZCgpXG59XG5cbmNvbnN0IGNyZWF0ZVN5bmMgPSAob3B0LCBmaWxlcykgPT4ge1xuICBjb25zdCBwID0gbmV3IFBhY2suU3luYyhvcHQpXG4gIGFkZEZpbGVzU3luYyhwLCBmaWxlcylcbiAgcmV0dXJuIHBcbn1cblxuY29uc3QgY3JlYXRlID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgY29uc3QgcCA9IG5ldyBQYWNrKG9wdClcbiAgYWRkRmlsZXNBc3luYyhwLCBmaWxlcylcbiAgcmV0dXJuIHBcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/create.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/extract.js":
/*!*****************************************!*\
  !*** ./node_modules/tar/lib/extract.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -x\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst Unpack = __webpack_require__(/*! ./unpack.js */ \"./node_modules/tar/lib/unpack.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/lib/strip-trailing-slashes.js\")\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  return opt.file && opt.sync ? extractFileSync(opt)\n    : opt.file ? extractFile(opt, cb)\n    : opt.sync ? extractSync(opt)\n    : extract(opt)\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst extractFileSync = opt => {\n  const u = new Unpack.Sync(opt)\n\n  const file = opt.file\n  const stat = fs.statSync(file)\n  // This trades a zero-byte read() syscall for a stat\n  // However, it will usually result in less memory allocation\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n  const stream = new fsm.ReadStreamSync(file, {\n    readSize: readSize,\n    size: stat.size,\n  })\n  stream.pipe(u)\n}\n\nconst extractFile = (opt, cb) => {\n  const u = new Unpack(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    u.on('error', reject)\n    u.on('close', resolve)\n\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(u)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst extractSync = opt => new Unpack.Sync(opt)\n\nconst extract = opt => new Unpack(opt)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9leHRyYWN0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHFFQUFxQjtBQUN6QyxlQUFlLG1CQUFPLENBQUMscURBQWE7QUFDcEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBNkI7O0FBRXhEO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvZXh0cmFjdC5qcz9lNjM4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyB0YXIgLXhcbmNvbnN0IGhsbyA9IHJlcXVpcmUoJy4vaGlnaC1sZXZlbC1vcHQuanMnKVxuY29uc3QgVW5wYWNrID0gcmVxdWlyZSgnLi91bnBhY2suanMnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBmc20gPSByZXF1aXJlKCdmcy1taW5pcGFzcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBzdHJpcFNsYXNoID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSAob3B0XywgZmlsZXMsIGNiKSA9PiB7XG4gIGlmICh0eXBlb2Ygb3B0XyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gb3B0XywgZmlsZXMgPSBudWxsLCBvcHRfID0ge31cbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9wdF8pKSB7XG4gICAgZmlsZXMgPSBvcHRfLCBvcHRfID0ge31cbiAgfVxuXG4gIGlmICh0eXBlb2YgZmlsZXMgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGZpbGVzLCBmaWxlcyA9IG51bGxcbiAgfVxuXG4gIGlmICghZmlsZXMpIHtcbiAgICBmaWxlcyA9IFtdXG4gIH0gZWxzZSB7XG4gICAgZmlsZXMgPSBBcnJheS5mcm9tKGZpbGVzKVxuICB9XG5cbiAgY29uc3Qgb3B0ID0gaGxvKG9wdF8pXG5cbiAgaWYgKG9wdC5zeW5jICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG5vdCBzdXBwb3J0ZWQgZm9yIHN5bmMgdGFyIGZ1bmN0aW9ucycpXG4gIH1cblxuICBpZiAoIW9wdC5maWxlICYmIHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhbGxiYWNrIG9ubHkgc3VwcG9ydGVkIHdpdGggZmlsZSBvcHRpb24nKVxuICB9XG5cbiAgaWYgKGZpbGVzLmxlbmd0aCkge1xuICAgIGZpbGVzRmlsdGVyKG9wdCwgZmlsZXMpXG4gIH1cblxuICByZXR1cm4gb3B0LmZpbGUgJiYgb3B0LnN5bmMgPyBleHRyYWN0RmlsZVN5bmMob3B0KVxuICAgIDogb3B0LmZpbGUgPyBleHRyYWN0RmlsZShvcHQsIGNiKVxuICAgIDogb3B0LnN5bmMgPyBleHRyYWN0U3luYyhvcHQpXG4gICAgOiBleHRyYWN0KG9wdClcbn1cblxuLy8gY29uc3RydWN0IGEgZmlsdGVyIHRoYXQgbGltaXRzIHRoZSBmaWxlIGVudHJpZXMgbGlzdGVkXG4vLyBpbmNsdWRlIGNoaWxkIGVudHJpZXMgaWYgYSBkaXIgaXMgaW5jbHVkZWRcbmNvbnN0IGZpbGVzRmlsdGVyID0gKG9wdCwgZmlsZXMpID0+IHtcbiAgY29uc3QgbWFwID0gbmV3IE1hcChmaWxlcy5tYXAoZiA9PiBbc3RyaXBTbGFzaChmKSwgdHJ1ZV0pKVxuICBjb25zdCBmaWx0ZXIgPSBvcHQuZmlsdGVyXG5cbiAgY29uc3QgbWFwSGFzID0gKGZpbGUsIHIpID0+IHtcbiAgICBjb25zdCByb290ID0gciB8fCBwYXRoLnBhcnNlKGZpbGUpLnJvb3QgfHwgJy4nXG4gICAgY29uc3QgcmV0ID0gZmlsZSA9PT0gcm9vdCA/IGZhbHNlXG4gICAgICA6IG1hcC5oYXMoZmlsZSkgPyBtYXAuZ2V0KGZpbGUpXG4gICAgICA6IG1hcEhhcyhwYXRoLmRpcm5hbWUoZmlsZSksIHJvb3QpXG5cbiAgICBtYXAuc2V0KGZpbGUsIHJldClcbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBvcHQuZmlsdGVyID0gZmlsdGVyXG4gICAgPyAoZmlsZSwgZW50cnkpID0+IGZpbHRlcihmaWxlLCBlbnRyeSkgJiYgbWFwSGFzKHN0cmlwU2xhc2goZmlsZSkpXG4gICAgOiBmaWxlID0+IG1hcEhhcyhzdHJpcFNsYXNoKGZpbGUpKVxufVxuXG5jb25zdCBleHRyYWN0RmlsZVN5bmMgPSBvcHQgPT4ge1xuICBjb25zdCB1ID0gbmV3IFVucGFjay5TeW5jKG9wdClcblxuICBjb25zdCBmaWxlID0gb3B0LmZpbGVcbiAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKGZpbGUpXG4gIC8vIFRoaXMgdHJhZGVzIGEgemVyby1ieXRlIHJlYWQoKSBzeXNjYWxsIGZvciBhIHN0YXRcbiAgLy8gSG93ZXZlciwgaXQgd2lsbCB1c3VhbGx5IHJlc3VsdCBpbiBsZXNzIG1lbW9yeSBhbGxvY2F0aW9uXG4gIGNvbnN0IHJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IDE2ICogMTAyNCAqIDEwMjRcbiAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5SZWFkU3RyZWFtU3luYyhmaWxlLCB7XG4gICAgcmVhZFNpemU6IHJlYWRTaXplLFxuICAgIHNpemU6IHN0YXQuc2l6ZSxcbiAgfSlcbiAgc3RyZWFtLnBpcGUodSlcbn1cblxuY29uc3QgZXh0cmFjdEZpbGUgPSAob3B0LCBjYikgPT4ge1xuICBjb25zdCB1ID0gbmV3IFVucGFjayhvcHQpXG4gIGNvbnN0IHJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IDE2ICogMTAyNCAqIDEwMjRcblxuICBjb25zdCBmaWxlID0gb3B0LmZpbGVcbiAgY29uc3QgcCA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICB1Lm9uKCdlcnJvcicsIHJlamVjdClcbiAgICB1Lm9uKCdjbG9zZScsIHJlc29sdmUpXG5cbiAgICAvLyBUaGlzIHRyYWRlcyBhIHplcm8tYnl0ZSByZWFkKCkgc3lzY2FsbCBmb3IgYSBzdGF0XG4gICAgLy8gSG93ZXZlciwgaXQgd2lsbCB1c3VhbGx5IHJlc3VsdCBpbiBsZXNzIG1lbW9yeSBhbGxvY2F0aW9uXG4gICAgZnMuc3RhdChmaWxlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICByZWplY3QoZXIpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLlJlYWRTdHJlYW0oZmlsZSwge1xuICAgICAgICAgIHJlYWRTaXplOiByZWFkU2l6ZSxcbiAgICAgICAgICBzaXplOiBzdGF0LnNpemUsXG4gICAgICAgIH0pXG4gICAgICAgIHN0cmVhbS5vbignZXJyb3InLCByZWplY3QpXG4gICAgICAgIHN0cmVhbS5waXBlKHUpXG4gICAgICB9XG4gICAgfSlcbiAgfSlcbiAgcmV0dXJuIGNiID8gcC50aGVuKGNiLCBjYikgOiBwXG59XG5cbmNvbnN0IGV4dHJhY3RTeW5jID0gb3B0ID0+IG5ldyBVbnBhY2suU3luYyhvcHQpXG5cbmNvbnN0IGV4dHJhY3QgPSBvcHQgPT4gbmV3IFVucGFjayhvcHQpXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/extract.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/get-write-flag.js":
/*!************************************************!*\
  !*** ./node_modules/tar/lib/get-write-flag.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\n// Only supported in Node v12.9.0 and above.\nconst platform = {}.__FAKE_PLATFORM__ || process.platform\nconst isWindows = platform === 'win32'\nconst fs = global.__FAKE_TESTING_FS__ || __webpack_require__(/*! fs */ \"fs\")\n\n/* istanbul ignore next */\nconst { O_CREAT, O_TRUNC, O_WRONLY, UV_FS_O_FILEMAP = 0 } = fs.constants\n\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP\nconst fMapLimit = 512 * 1024\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY\nmodule.exports = !fMapEnabled ? () => 'w'\n  : size => size < fMapLimit ? fMapFlag : 'w'\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9nZXQtd3JpdGUtZmxhZy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLEVBQVc7QUFDNUI7QUFDQSx5Q0FBeUMsbUJBQU8sQ0FBQyxjQUFJOztBQUVyRDtBQUNBLFFBQVEsa0RBQWtEOztBQUUxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL2dldC13cml0ZS1mbGFnLmpzPzI1YjUiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gR2V0IHRoZSBhcHByb3ByaWF0ZSBmbGFnIHRvIHVzZSBmb3IgY3JlYXRpbmcgZmlsZXNcbi8vIFdlIHVzZSBmbWFwIG9uIFdpbmRvd3MgcGxhdGZvcm1zIGZvciBmaWxlcyBsZXNzIHRoYW5cbi8vIDUxMmtiLiAgVGhpcyBpcyBhIGZhaXJseSBsb3cgbGltaXQsIGJ1dCBhdm9pZHMgbWFraW5nXG4vLyB0aGluZ3Mgc2xvd2VyIGluIHNvbWUgY2FzZXMuICBTaW5jZSBtb3N0IG9mIHdoYXQgdGhpc1xuLy8gbGlicmFyeSBpcyB1c2VkIGZvciBpcyBleHRyYWN0aW5nIHRhcmJhbGxzIG9mIG1hbnlcbi8vIHJlbGF0aXZlbHkgc21hbGwgZmlsZXMgaW4gbnBtIHBhY2thZ2VzIGFuZCB0aGUgbGlrZSxcbi8vIGl0IGNhbiBiZSBhIGJpZyBib29zdCBvbiBXaW5kb3dzIHBsYXRmb3Jtcy5cbi8vIE9ubHkgc3VwcG9ydGVkIGluIE5vZGUgdjEyLjkuMCBhbmQgYWJvdmUuXG5jb25zdCBwbGF0Zm9ybSA9IHByb2Nlc3MuZW52Ll9fRkFLRV9QTEFURk9STV9fIHx8IHByb2Nlc3MucGxhdGZvcm1cbmNvbnN0IGlzV2luZG93cyA9IHBsYXRmb3JtID09PSAnd2luMzInXG5jb25zdCBmcyA9IGdsb2JhbC5fX0ZBS0VfVEVTVElOR19GU19fIHx8IHJlcXVpcmUoJ2ZzJylcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHsgT19DUkVBVCwgT19UUlVOQywgT19XUk9OTFksIFVWX0ZTX09fRklMRU1BUCA9IDAgfSA9IGZzLmNvbnN0YW50c1xuXG5jb25zdCBmTWFwRW5hYmxlZCA9IGlzV2luZG93cyAmJiAhIVVWX0ZTX09fRklMRU1BUFxuY29uc3QgZk1hcExpbWl0ID0gNTEyICogMTAyNFxuY29uc3QgZk1hcEZsYWcgPSBVVl9GU19PX0ZJTEVNQVAgfCBPX1RSVU5DIHwgT19DUkVBVCB8IE9fV1JPTkxZXG5tb2R1bGUuZXhwb3J0cyA9ICFmTWFwRW5hYmxlZCA/ICgpID0+ICd3J1xuICA6IHNpemUgPT4gc2l6ZSA8IGZNYXBMaW1pdCA/IGZNYXBGbGFnIDogJ3cnXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/get-write-flag.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/header.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/header.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\n\nconst types = __webpack_require__(/*! ./types.js */ \"./node_modules/tar/lib/types.js\")\nconst pathModule = (__webpack_require__(/*! path */ \"path\").posix)\nconst large = __webpack_require__(/*! ./large-numbers.js */ \"./node_modules/tar/lib/large-numbers.js\")\n\nconst SLURP = Symbol('slurp')\nconst TYPE = Symbol('type')\n\nclass Header {\n  constructor (data, off, ex, gex) {\n    this.cksumValid = false\n    this.needPax = false\n    this.nullBlock = false\n\n    this.block = null\n    this.path = null\n    this.mode = null\n    this.uid = null\n    this.gid = null\n    this.size = null\n    this.mtime = null\n    this.cksum = null\n    this[TYPE] = '0'\n    this.linkpath = null\n    this.uname = null\n    this.gname = null\n    this.devmaj = 0\n    this.devmin = 0\n    this.atime = null\n    this.ctime = null\n\n    if (Buffer.isBuffer(data)) {\n      this.decode(data, off || 0, ex, gex)\n    } else if (data) {\n      this.set(data)\n    }\n  }\n\n  decode (buf, off, ex, gex) {\n    if (!off) {\n      off = 0\n    }\n\n    if (!buf || !(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    this.path = decString(buf, off, 100)\n    this.mode = decNumber(buf, off + 100, 8)\n    this.uid = decNumber(buf, off + 108, 8)\n    this.gid = decNumber(buf, off + 116, 8)\n    this.size = decNumber(buf, off + 124, 12)\n    this.mtime = decDate(buf, off + 136, 12)\n    this.cksum = decNumber(buf, off + 148, 12)\n\n    // if we have extended or global extended headers, apply them now\n    // See https://github.com/npm/node-tar/pull/187\n    this[SLURP](ex)\n    this[SLURP](gex, true)\n\n    // old tar versions marked dirs as a file with a trailing /\n    this[TYPE] = decString(buf, off + 156, 1)\n    if (this[TYPE] === '') {\n      this[TYPE] = '0'\n    }\n    if (this[TYPE] === '0' && this.path.slice(-1) === '/') {\n      this[TYPE] = '5'\n    }\n\n    // tar implementations sometimes incorrectly put the stat(dir).size\n    // as the size in the tarball, even though Directory entries are\n    // not able to have any body at all.  In the very rare chance that\n    // it actually DOES have a body, we weren't going to do anything with\n    // it anyway, and it'll just be a warning about an invalid header.\n    if (this[TYPE] === '5') {\n      this.size = 0\n    }\n\n    this.linkpath = decString(buf, off + 157, 100)\n    if (buf.slice(off + 257, off + 265).toString() === 'ustar\\u000000') {\n      this.uname = decString(buf, off + 265, 32)\n      this.gname = decString(buf, off + 297, 32)\n      this.devmaj = decNumber(buf, off + 329, 8)\n      this.devmin = decNumber(buf, off + 337, 8)\n      if (buf[off + 475] !== 0) {\n        // definitely a prefix, definitely >130 chars.\n        const prefix = decString(buf, off + 345, 155)\n        this.path = prefix + '/' + this.path\n      } else {\n        const prefix = decString(buf, off + 345, 130)\n        if (prefix) {\n          this.path = prefix + '/' + this.path\n        }\n        this.atime = decDate(buf, off + 476, 12)\n        this.ctime = decDate(buf, off + 488, 12)\n      }\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n\n    this.cksumValid = sum === this.cksum\n    if (this.cksum === null && sum === 8 * 0x20) {\n      this.nullBlock = true\n    }\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = ex[k]\n      }\n    }\n  }\n\n  encode (buf, off) {\n    if (!buf) {\n      buf = this.block = Buffer.alloc(512)\n      off = 0\n    }\n\n    if (!off) {\n      off = 0\n    }\n\n    if (!(buf.length >= off + 512)) {\n      throw new Error('need 512 bytes for header')\n    }\n\n    const prefixSize = this.ctime || this.atime ? 130 : 155\n    const split = splitPrefix(this.path || '', prefixSize)\n    const path = split[0]\n    const prefix = split[1]\n    this.needPax = split[2]\n\n    this.needPax = encString(buf, off, 100, path) || this.needPax\n    this.needPax = encNumber(buf, off + 100, 8, this.mode) || this.needPax\n    this.needPax = encNumber(buf, off + 108, 8, this.uid) || this.needPax\n    this.needPax = encNumber(buf, off + 116, 8, this.gid) || this.needPax\n    this.needPax = encNumber(buf, off + 124, 12, this.size) || this.needPax\n    this.needPax = encDate(buf, off + 136, 12, this.mtime) || this.needPax\n    buf[off + 156] = this[TYPE].charCodeAt(0)\n    this.needPax = encString(buf, off + 157, 100, this.linkpath) || this.needPax\n    buf.write('ustar\\u000000', off + 257, 8)\n    this.needPax = encString(buf, off + 265, 32, this.uname) || this.needPax\n    this.needPax = encString(buf, off + 297, 32, this.gname) || this.needPax\n    this.needPax = encNumber(buf, off + 329, 8, this.devmaj) || this.needPax\n    this.needPax = encNumber(buf, off + 337, 8, this.devmin) || this.needPax\n    this.needPax = encString(buf, off + 345, prefixSize, prefix) || this.needPax\n    if (buf[off + 475] !== 0) {\n      this.needPax = encString(buf, off + 345, 155, prefix) || this.needPax\n    } else {\n      this.needPax = encString(buf, off + 345, 130, prefix) || this.needPax\n      this.needPax = encDate(buf, off + 476, 12, this.atime) || this.needPax\n      this.needPax = encDate(buf, off + 488, 12, this.ctime) || this.needPax\n    }\n\n    let sum = 8 * 0x20\n    for (let i = off; i < off + 148; i++) {\n      sum += buf[i]\n    }\n\n    for (let i = off + 156; i < off + 512; i++) {\n      sum += buf[i]\n    }\n\n    this.cksum = sum\n    encNumber(buf, off + 148, 8, this.cksum)\n    this.cksumValid = true\n\n    return this.needPax\n  }\n\n  set (data) {\n    for (const i in data) {\n      if (data[i] !== null && data[i] !== undefined) {\n        this[i] = data[i]\n      }\n    }\n  }\n\n  get type () {\n    return types.name.get(this[TYPE]) || this[TYPE]\n  }\n\n  get typeKey () {\n    return this[TYPE]\n  }\n\n  set type (type) {\n    if (types.code.has(type)) {\n      this[TYPE] = types.code.get(type)\n    } else {\n      this[TYPE] = type\n    }\n  }\n}\n\nconst splitPrefix = (p, prefixSize) => {\n  const pathSize = 100\n  let pp = p\n  let prefix = ''\n  let ret\n  const root = pathModule.parse(p).root || '.'\n\n  if (Buffer.byteLength(pp) < pathSize) {\n    ret = [pp, prefix, false]\n  } else {\n    // first set prefix to the dir, and path to the base\n    prefix = pathModule.dirname(pp)\n    pp = pathModule.basename(pp)\n\n    do {\n      if (Buffer.byteLength(pp) <= pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize) {\n        // both fit!\n        ret = [pp, prefix, false]\n      } else if (Buffer.byteLength(pp) > pathSize &&\n          Buffer.byteLength(prefix) <= prefixSize) {\n        // prefix fits in prefix, but path doesn't fit in path\n        ret = [pp.slice(0, pathSize - 1), prefix, true]\n      } else {\n        // make path take a bit from prefix\n        pp = pathModule.join(pathModule.basename(prefix), pp)\n        prefix = pathModule.dirname(prefix)\n      }\n    } while (prefix !== root && !ret)\n\n    // at this point, found no resolution, just truncate\n    if (!ret) {\n      ret = [p.slice(0, pathSize - 1), '', true]\n    }\n  }\n  return ret\n}\n\nconst decString = (buf, off, size) =>\n  buf.slice(off, off + size).toString('utf8').replace(/\\0.*/, '')\n\nconst decDate = (buf, off, size) =>\n  numToDate(decNumber(buf, off, size))\n\nconst numToDate = num => num === null ? null : new Date(num * 1000)\n\nconst decNumber = (buf, off, size) =>\n  buf[off] & 0x80 ? large.parse(buf.slice(off, off + size))\n  : decSmallNumber(buf, off, size)\n\nconst nanNull = value => isNaN(value) ? null : value\n\nconst decSmallNumber = (buf, off, size) =>\n  nanNull(parseInt(\n    buf.slice(off, off + size)\n      .toString('utf8').replace(/\\0.*$/, '').trim(), 8))\n\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n  12: 0o77777777777,\n  8: 0o7777777,\n}\n\nconst encNumber = (buf, off, size, number) =>\n  number === null ? false :\n  number > MAXNUM[size] || number < 0\n    ? (large.encode(number, buf.slice(off, off + size)), true)\n    : (encSmallNumber(buf, off, size, number), false)\n\nconst encSmallNumber = (buf, off, size, number) =>\n  buf.write(octalString(number, size), off, size, 'ascii')\n\nconst octalString = (number, size) =>\n  padOctal(Math.floor(number).toString(8), size)\n\nconst padOctal = (string, size) =>\n  (string.length === size - 1 ? string\n  : new Array(size - string.length - 1).join('0') + string + ' ') + '\\0'\n\nconst encDate = (buf, off, size, date) =>\n  date === null ? false :\n  encNumber(buf, off, size, date.getTime() / 1000)\n\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0')\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, string) =>\n  string === null ? false :\n  (buf.write(string + NULLS, off, size, 'utf8'),\n  string.length !== Buffer.byteLength(string) || string.length > size)\n\nmodule.exports = Header\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9oZWFkZXIuanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxjQUFjLG1CQUFPLENBQUMsbURBQVk7QUFDbEMsbUJBQW1CLCtDQUFxQjtBQUN4QyxjQUFjLG1CQUFPLENBQUMsbUVBQW9COztBQUUxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0JBQXNCLGVBQWU7QUFDckM7QUFDQTs7QUFFQSw0QkFBNEIsZUFBZTtBQUMzQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsZUFBZTtBQUNyQztBQUNBOztBQUVBLDRCQUE0QixlQUFlO0FBQzNDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9oZWFkZXIuanM/ZGY3NyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIHBhcnNlIGEgNTEyLWJ5dGUgaGVhZGVyIGJsb2NrIHRvIGEgZGF0YSBvYmplY3QsIG9yIHZpY2UtdmVyc2Fcbi8vIGVuY29kZSByZXR1cm5zIGB0cnVlYCBpZiBhIHBheCBleHRlbmRlZCBoZWFkZXIgaXMgbmVlZGVkLCBiZWNhdXNlXG4vLyB0aGUgZGF0YSBjb3VsZCBub3QgYmUgZmFpdGhmdWxseSBlbmNvZGVkIGluIGEgc2ltcGxlIGhlYWRlci5cbi8vIChBbHNvLCBjaGVjayBoZWFkZXIubmVlZFBheCB0byBzZWUgaWYgaXQgbmVlZHMgYSBwYXggaGVhZGVyLilcblxuY29uc3QgdHlwZXMgPSByZXF1aXJlKCcuL3R5cGVzLmpzJylcbmNvbnN0IHBhdGhNb2R1bGUgPSByZXF1aXJlKCdwYXRoJykucG9zaXhcbmNvbnN0IGxhcmdlID0gcmVxdWlyZSgnLi9sYXJnZS1udW1iZXJzLmpzJylcblxuY29uc3QgU0xVUlAgPSBTeW1ib2woJ3NsdXJwJylcbmNvbnN0IFRZUEUgPSBTeW1ib2woJ3R5cGUnKVxuXG5jbGFzcyBIZWFkZXIge1xuICBjb25zdHJ1Y3RvciAoZGF0YSwgb2ZmLCBleCwgZ2V4KSB7XG4gICAgdGhpcy5ja3N1bVZhbGlkID0gZmFsc2VcbiAgICB0aGlzLm5lZWRQYXggPSBmYWxzZVxuICAgIHRoaXMubnVsbEJsb2NrID0gZmFsc2VcblxuICAgIHRoaXMuYmxvY2sgPSBudWxsXG4gICAgdGhpcy5wYXRoID0gbnVsbFxuICAgIHRoaXMubW9kZSA9IG51bGxcbiAgICB0aGlzLnVpZCA9IG51bGxcbiAgICB0aGlzLmdpZCA9IG51bGxcbiAgICB0aGlzLnNpemUgPSBudWxsXG4gICAgdGhpcy5tdGltZSA9IG51bGxcbiAgICB0aGlzLmNrc3VtID0gbnVsbFxuICAgIHRoaXNbVFlQRV0gPSAnMCdcbiAgICB0aGlzLmxpbmtwYXRoID0gbnVsbFxuICAgIHRoaXMudW5hbWUgPSBudWxsXG4gICAgdGhpcy5nbmFtZSA9IG51bGxcbiAgICB0aGlzLmRldm1haiA9IDBcbiAgICB0aGlzLmRldm1pbiA9IDBcbiAgICB0aGlzLmF0aW1lID0gbnVsbFxuICAgIHRoaXMuY3RpbWUgPSBudWxsXG5cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICB0aGlzLmRlY29kZShkYXRhLCBvZmYgfHwgMCwgZXgsIGdleClcbiAgICB9IGVsc2UgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuc2V0KGRhdGEpXG4gICAgfVxuICB9XG5cbiAgZGVjb2RlIChidWYsIG9mZiwgZXgsIGdleCkge1xuICAgIGlmICghb2ZmKSB7XG4gICAgICBvZmYgPSAwXG4gICAgfVxuXG4gICAgaWYgKCFidWYgfHwgIShidWYubGVuZ3RoID49IG9mZiArIDUxMikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignbmVlZCA1MTIgYnl0ZXMgZm9yIGhlYWRlcicpXG4gICAgfVxuXG4gICAgdGhpcy5wYXRoID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmLCAxMDApXG4gICAgdGhpcy5tb2RlID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTAwLCA4KVxuICAgIHRoaXMudWlkID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTA4LCA4KVxuICAgIHRoaXMuZ2lkID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMTE2LCA4KVxuICAgIHRoaXMuc2l6ZSA9IGRlY051bWJlcihidWYsIG9mZiArIDEyNCwgMTIpXG4gICAgdGhpcy5tdGltZSA9IGRlY0RhdGUoYnVmLCBvZmYgKyAxMzYsIDEyKVxuICAgIHRoaXMuY2tzdW0gPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAxNDgsIDEyKVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBleHRlbmRlZCBvciBnbG9iYWwgZXh0ZW5kZWQgaGVhZGVycywgYXBwbHkgdGhlbSBub3dcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL25wbS9ub2RlLXRhci9wdWxsLzE4N1xuICAgIHRoaXNbU0xVUlBdKGV4KVxuICAgIHRoaXNbU0xVUlBdKGdleCwgdHJ1ZSlcblxuICAgIC8vIG9sZCB0YXIgdmVyc2lvbnMgbWFya2VkIGRpcnMgYXMgYSBmaWxlIHdpdGggYSB0cmFpbGluZyAvXG4gICAgdGhpc1tUWVBFXSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDE1NiwgMSlcbiAgICBpZiAodGhpc1tUWVBFXSA9PT0gJycpIHtcbiAgICAgIHRoaXNbVFlQRV0gPSAnMCdcbiAgICB9XG4gICAgaWYgKHRoaXNbVFlQRV0gPT09ICcwJyAmJiB0aGlzLnBhdGguc2xpY2UoLTEpID09PSAnLycpIHtcbiAgICAgIHRoaXNbVFlQRV0gPSAnNSdcbiAgICB9XG5cbiAgICAvLyB0YXIgaW1wbGVtZW50YXRpb25zIHNvbWV0aW1lcyBpbmNvcnJlY3RseSBwdXQgdGhlIHN0YXQoZGlyKS5zaXplXG4gICAgLy8gYXMgdGhlIHNpemUgaW4gdGhlIHRhcmJhbGwsIGV2ZW4gdGhvdWdoIERpcmVjdG9yeSBlbnRyaWVzIGFyZVxuICAgIC8vIG5vdCBhYmxlIHRvIGhhdmUgYW55IGJvZHkgYXQgYWxsLiAgSW4gdGhlIHZlcnkgcmFyZSBjaGFuY2UgdGhhdFxuICAgIC8vIGl0IGFjdHVhbGx5IERPRVMgaGF2ZSBhIGJvZHksIHdlIHdlcmVuJ3QgZ29pbmcgdG8gZG8gYW55dGhpbmcgd2l0aFxuICAgIC8vIGl0IGFueXdheSwgYW5kIGl0J2xsIGp1c3QgYmUgYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgaGVhZGVyLlxuICAgIGlmICh0aGlzW1RZUEVdID09PSAnNScpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDBcbiAgICB9XG5cbiAgICB0aGlzLmxpbmtwYXRoID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMTU3LCAxMDApXG4gICAgaWYgKGJ1Zi5zbGljZShvZmYgKyAyNTcsIG9mZiArIDI2NSkudG9TdHJpbmcoKSA9PT0gJ3VzdGFyXFx1MDAwMDAwJykge1xuICAgICAgdGhpcy51bmFtZSA9IGRlY1N0cmluZyhidWYsIG9mZiArIDI2NSwgMzIpXG4gICAgICB0aGlzLmduYW1lID0gZGVjU3RyaW5nKGJ1Ziwgb2ZmICsgMjk3LCAzMilcbiAgICAgIHRoaXMuZGV2bWFqID0gZGVjTnVtYmVyKGJ1Ziwgb2ZmICsgMzI5LCA4KVxuICAgICAgdGhpcy5kZXZtaW4gPSBkZWNOdW1iZXIoYnVmLCBvZmYgKyAzMzcsIDgpXG4gICAgICBpZiAoYnVmW29mZiArIDQ3NV0gIT09IDApIHtcbiAgICAgICAgLy8gZGVmaW5pdGVseSBhIHByZWZpeCwgZGVmaW5pdGVseSA+MTMwIGNoYXJzLlxuICAgICAgICBjb25zdCBwcmVmaXggPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDE1NSlcbiAgICAgICAgdGhpcy5wYXRoID0gcHJlZml4ICsgJy8nICsgdGhpcy5wYXRoXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBwcmVmaXggPSBkZWNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDEzMClcbiAgICAgICAgaWYgKHByZWZpeCkge1xuICAgICAgICAgIHRoaXMucGF0aCA9IHByZWZpeCArICcvJyArIHRoaXMucGF0aFxuICAgICAgICB9XG4gICAgICAgIHRoaXMuYXRpbWUgPSBkZWNEYXRlKGJ1Ziwgb2ZmICsgNDc2LCAxMilcbiAgICAgICAgdGhpcy5jdGltZSA9IGRlY0RhdGUoYnVmLCBvZmYgKyA0ODgsIDEyKVxuICAgICAgfVxuICAgIH1cblxuICAgIGxldCBzdW0gPSA4ICogMHgyMFxuICAgIGZvciAobGV0IGkgPSBvZmY7IGkgPCBvZmYgKyAxNDg7IGkrKykge1xuICAgICAgc3VtICs9IGJ1ZltpXVxuICAgIH1cblxuICAgIGZvciAobGV0IGkgPSBvZmYgKyAxNTY7IGkgPCBvZmYgKyA1MTI7IGkrKykge1xuICAgICAgc3VtICs9IGJ1ZltpXVxuICAgIH1cblxuICAgIHRoaXMuY2tzdW1WYWxpZCA9IHN1bSA9PT0gdGhpcy5ja3N1bVxuICAgIGlmICh0aGlzLmNrc3VtID09PSBudWxsICYmIHN1bSA9PT0gOCAqIDB4MjApIHtcbiAgICAgIHRoaXMubnVsbEJsb2NrID0gdHJ1ZVxuICAgIH1cbiAgfVxuXG4gIFtTTFVSUF0gKGV4LCBnbG9iYWwpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gZXgpIHtcbiAgICAgIC8vIHdlIHNsdXJwIGluIGV2ZXJ5dGhpbmcgZXhjZXB0IGZvciB0aGUgcGF0aCBhdHRyaWJ1dGUgaW5cbiAgICAgIC8vIGEgZ2xvYmFsIGV4dGVuZGVkIGhlYWRlciwgYmVjYXVzZSB0aGF0J3Mgd2VpcmQuXG4gICAgICBpZiAoZXhba10gIT09IG51bGwgJiYgZXhba10gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICEoZ2xvYmFsICYmIGsgPT09ICdwYXRoJykpIHtcbiAgICAgICAgdGhpc1trXSA9IGV4W2tdXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZW5jb2RlIChidWYsIG9mZikge1xuICAgIGlmICghYnVmKSB7XG4gICAgICBidWYgPSB0aGlzLmJsb2NrID0gQnVmZmVyLmFsbG9jKDUxMilcbiAgICAgIG9mZiA9IDBcbiAgICB9XG5cbiAgICBpZiAoIW9mZikge1xuICAgICAgb2ZmID0gMFxuICAgIH1cblxuICAgIGlmICghKGJ1Zi5sZW5ndGggPj0gb2ZmICsgNTEyKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCduZWVkIDUxMiBieXRlcyBmb3IgaGVhZGVyJylcbiAgICB9XG5cbiAgICBjb25zdCBwcmVmaXhTaXplID0gdGhpcy5jdGltZSB8fCB0aGlzLmF0aW1lID8gMTMwIDogMTU1XG4gICAgY29uc3Qgc3BsaXQgPSBzcGxpdFByZWZpeCh0aGlzLnBhdGggfHwgJycsIHByZWZpeFNpemUpXG4gICAgY29uc3QgcGF0aCA9IHNwbGl0WzBdXG4gICAgY29uc3QgcHJlZml4ID0gc3BsaXRbMV1cbiAgICB0aGlzLm5lZWRQYXggPSBzcGxpdFsyXVxuXG4gICAgdGhpcy5uZWVkUGF4ID0gZW5jU3RyaW5nKGJ1Ziwgb2ZmLCAxMDAsIHBhdGgpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY051bWJlcihidWYsIG9mZiArIDEwMCwgOCwgdGhpcy5tb2RlKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMDgsIDgsIHRoaXMudWlkKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMTYsIDgsIHRoaXMuZ2lkKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB0aGlzLm5lZWRQYXggPSBlbmNOdW1iZXIoYnVmLCBvZmYgKyAxMjQsIDEyLCB0aGlzLnNpemUpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY0RhdGUoYnVmLCBvZmYgKyAxMzYsIDEyLCB0aGlzLm10aW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICBidWZbb2ZmICsgMTU2XSA9IHRoaXNbVFlQRV0uY2hhckNvZGVBdCgwKVxuICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDE1NywgMTAwLCB0aGlzLmxpbmtwYXRoKSB8fCB0aGlzLm5lZWRQYXhcbiAgICBidWYud3JpdGUoJ3VzdGFyXFx1MDAwMDAwJywgb2ZmICsgMjU3LCA4KVxuICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDI2NSwgMzIsIHRoaXMudW5hbWUpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDI5NywgMzIsIHRoaXMuZ25hbWUpIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY051bWJlcihidWYsIG9mZiArIDMyOSwgOCwgdGhpcy5kZXZtYWopIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY051bWJlcihidWYsIG9mZiArIDMzNywgOCwgdGhpcy5kZXZtaW4pIHx8IHRoaXMubmVlZFBheFxuICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDM0NSwgcHJlZml4U2l6ZSwgcHJlZml4KSB8fCB0aGlzLm5lZWRQYXhcbiAgICBpZiAoYnVmW29mZiArIDQ3NV0gIT09IDApIHtcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY1N0cmluZyhidWYsIG9mZiArIDM0NSwgMTU1LCBwcmVmaXgpIHx8IHRoaXMubmVlZFBheFxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm5lZWRQYXggPSBlbmNTdHJpbmcoYnVmLCBvZmYgKyAzNDUsIDEzMCwgcHJlZml4KSB8fCB0aGlzLm5lZWRQYXhcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY0RhdGUoYnVmLCBvZmYgKyA0NzYsIDEyLCB0aGlzLmF0aW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICAgIHRoaXMubmVlZFBheCA9IGVuY0RhdGUoYnVmLCBvZmYgKyA0ODgsIDEyLCB0aGlzLmN0aW1lKSB8fCB0aGlzLm5lZWRQYXhcbiAgICB9XG5cbiAgICBsZXQgc3VtID0gOCAqIDB4MjBcbiAgICBmb3IgKGxldCBpID0gb2ZmOyBpIDwgb2ZmICsgMTQ4OyBpKyspIHtcbiAgICAgIHN1bSArPSBidWZbaV1cbiAgICB9XG5cbiAgICBmb3IgKGxldCBpID0gb2ZmICsgMTU2OyBpIDwgb2ZmICsgNTEyOyBpKyspIHtcbiAgICAgIHN1bSArPSBidWZbaV1cbiAgICB9XG5cbiAgICB0aGlzLmNrc3VtID0gc3VtXG4gICAgZW5jTnVtYmVyKGJ1Ziwgb2ZmICsgMTQ4LCA4LCB0aGlzLmNrc3VtKVxuICAgIHRoaXMuY2tzdW1WYWxpZCA9IHRydWVcblxuICAgIHJldHVybiB0aGlzLm5lZWRQYXhcbiAgfVxuXG4gIHNldCAoZGF0YSkge1xuICAgIGZvciAoY29uc3QgaSBpbiBkYXRhKSB7XG4gICAgICBpZiAoZGF0YVtpXSAhPT0gbnVsbCAmJiBkYXRhW2ldICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpc1tpXSA9IGRhdGFbaV1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBnZXQgdHlwZSAoKSB7XG4gICAgcmV0dXJuIHR5cGVzLm5hbWUuZ2V0KHRoaXNbVFlQRV0pIHx8IHRoaXNbVFlQRV1cbiAgfVxuXG4gIGdldCB0eXBlS2V5ICgpIHtcbiAgICByZXR1cm4gdGhpc1tUWVBFXVxuICB9XG5cbiAgc2V0IHR5cGUgKHR5cGUpIHtcbiAgICBpZiAodHlwZXMuY29kZS5oYXModHlwZSkpIHtcbiAgICAgIHRoaXNbVFlQRV0gPSB0eXBlcy5jb2RlLmdldCh0eXBlKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW1RZUEVdID0gdHlwZVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBzcGxpdFByZWZpeCA9IChwLCBwcmVmaXhTaXplKSA9PiB7XG4gIGNvbnN0IHBhdGhTaXplID0gMTAwXG4gIGxldCBwcCA9IHBcbiAgbGV0IHByZWZpeCA9ICcnXG4gIGxldCByZXRcbiAgY29uc3Qgcm9vdCA9IHBhdGhNb2R1bGUucGFyc2UocCkucm9vdCB8fCAnLidcblxuICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgocHApIDwgcGF0aFNpemUpIHtcbiAgICByZXQgPSBbcHAsIHByZWZpeCwgZmFsc2VdXG4gIH0gZWxzZSB7XG4gICAgLy8gZmlyc3Qgc2V0IHByZWZpeCB0byB0aGUgZGlyLCBhbmQgcGF0aCB0byB0aGUgYmFzZVxuICAgIHByZWZpeCA9IHBhdGhNb2R1bGUuZGlybmFtZShwcClcbiAgICBwcCA9IHBhdGhNb2R1bGUuYmFzZW5hbWUocHApXG5cbiAgICBkbyB7XG4gICAgICBpZiAoQnVmZmVyLmJ5dGVMZW5ndGgocHApIDw9IHBhdGhTaXplICYmXG4gICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgocHJlZml4KSA8PSBwcmVmaXhTaXplKSB7XG4gICAgICAgIC8vIGJvdGggZml0IVxuICAgICAgICByZXQgPSBbcHAsIHByZWZpeCwgZmFsc2VdXG4gICAgICB9IGVsc2UgaWYgKEJ1ZmZlci5ieXRlTGVuZ3RoKHBwKSA+IHBhdGhTaXplICYmXG4gICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgocHJlZml4KSA8PSBwcmVmaXhTaXplKSB7XG4gICAgICAgIC8vIHByZWZpeCBmaXRzIGluIHByZWZpeCwgYnV0IHBhdGggZG9lc24ndCBmaXQgaW4gcGF0aFxuICAgICAgICByZXQgPSBbcHAuc2xpY2UoMCwgcGF0aFNpemUgLSAxKSwgcHJlZml4LCB0cnVlXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gbWFrZSBwYXRoIHRha2UgYSBiaXQgZnJvbSBwcmVmaXhcbiAgICAgICAgcHAgPSBwYXRoTW9kdWxlLmpvaW4ocGF0aE1vZHVsZS5iYXNlbmFtZShwcmVmaXgpLCBwcClcbiAgICAgICAgcHJlZml4ID0gcGF0aE1vZHVsZS5kaXJuYW1lKHByZWZpeClcbiAgICAgIH1cbiAgICB9IHdoaWxlIChwcmVmaXggIT09IHJvb3QgJiYgIXJldClcblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGZvdW5kIG5vIHJlc29sdXRpb24sIGp1c3QgdHJ1bmNhdGVcbiAgICBpZiAoIXJldCkge1xuICAgICAgcmV0ID0gW3Auc2xpY2UoMCwgcGF0aFNpemUgLSAxKSwgJycsIHRydWVdXG4gICAgfVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuY29uc3QgZGVjU3RyaW5nID0gKGJ1Ziwgb2ZmLCBzaXplKSA9PlxuICBidWYuc2xpY2Uob2ZmLCBvZmYgKyBzaXplKS50b1N0cmluZygndXRmOCcpLnJlcGxhY2UoL1xcMC4qLywgJycpXG5cbmNvbnN0IGRlY0RhdGUgPSAoYnVmLCBvZmYsIHNpemUpID0+XG4gIG51bVRvRGF0ZShkZWNOdW1iZXIoYnVmLCBvZmYsIHNpemUpKVxuXG5jb25zdCBudW1Ub0RhdGUgPSBudW0gPT4gbnVtID09PSBudWxsID8gbnVsbCA6IG5ldyBEYXRlKG51bSAqIDEwMDApXG5cbmNvbnN0IGRlY051bWJlciA9IChidWYsIG9mZiwgc2l6ZSkgPT5cbiAgYnVmW29mZl0gJiAweDgwID8gbGFyZ2UucGFyc2UoYnVmLnNsaWNlKG9mZiwgb2ZmICsgc2l6ZSkpXG4gIDogZGVjU21hbGxOdW1iZXIoYnVmLCBvZmYsIHNpemUpXG5cbmNvbnN0IG5hbk51bGwgPSB2YWx1ZSA9PiBpc05hTih2YWx1ZSkgPyBudWxsIDogdmFsdWVcblxuY29uc3QgZGVjU21hbGxOdW1iZXIgPSAoYnVmLCBvZmYsIHNpemUpID0+XG4gIG5hbk51bGwocGFyc2VJbnQoXG4gICAgYnVmLnNsaWNlKG9mZiwgb2ZmICsgc2l6ZSlcbiAgICAgIC50b1N0cmluZygndXRmOCcpLnJlcGxhY2UoL1xcMC4qJC8sICcnKS50cmltKCksIDgpKVxuXG4vLyB0aGUgbWF4aW11bSBlbmNvZGFibGUgYXMgYSBudWxsLXRlcm1pbmF0ZWQgb2N0YWwsIGJ5IGZpZWxkIHNpemVcbmNvbnN0IE1BWE5VTSA9IHtcbiAgMTI6IDBvNzc3Nzc3Nzc3NzcsXG4gIDg6IDBvNzc3Nzc3Nyxcbn1cblxuY29uc3QgZW5jTnVtYmVyID0gKGJ1Ziwgb2ZmLCBzaXplLCBudW1iZXIpID0+XG4gIG51bWJlciA9PT0gbnVsbCA/IGZhbHNlIDpcbiAgbnVtYmVyID4gTUFYTlVNW3NpemVdIHx8IG51bWJlciA8IDBcbiAgICA/IChsYXJnZS5lbmNvZGUobnVtYmVyLCBidWYuc2xpY2Uob2ZmLCBvZmYgKyBzaXplKSksIHRydWUpXG4gICAgOiAoZW5jU21hbGxOdW1iZXIoYnVmLCBvZmYsIHNpemUsIG51bWJlciksIGZhbHNlKVxuXG5jb25zdCBlbmNTbWFsbE51bWJlciA9IChidWYsIG9mZiwgc2l6ZSwgbnVtYmVyKSA9PlxuICBidWYud3JpdGUob2N0YWxTdHJpbmcobnVtYmVyLCBzaXplKSwgb2ZmLCBzaXplLCAnYXNjaWknKVxuXG5jb25zdCBvY3RhbFN0cmluZyA9IChudW1iZXIsIHNpemUpID0+XG4gIHBhZE9jdGFsKE1hdGguZmxvb3IobnVtYmVyKS50b1N0cmluZyg4KSwgc2l6ZSlcblxuY29uc3QgcGFkT2N0YWwgPSAoc3RyaW5nLCBzaXplKSA9PlxuICAoc3RyaW5nLmxlbmd0aCA9PT0gc2l6ZSAtIDEgPyBzdHJpbmdcbiAgOiBuZXcgQXJyYXkoc2l6ZSAtIHN0cmluZy5sZW5ndGggLSAxKS5qb2luKCcwJykgKyBzdHJpbmcgKyAnICcpICsgJ1xcMCdcblxuY29uc3QgZW5jRGF0ZSA9IChidWYsIG9mZiwgc2l6ZSwgZGF0ZSkgPT5cbiAgZGF0ZSA9PT0gbnVsbCA/IGZhbHNlIDpcbiAgZW5jTnVtYmVyKGJ1Ziwgb2ZmLCBzaXplLCBkYXRlLmdldFRpbWUoKSAvIDEwMDApXG5cbi8vIGVub3VnaCB0byBmaWxsIHRoZSBsb25nZXN0IHN0cmluZyB3ZSd2ZSBnb3RcbmNvbnN0IE5VTExTID0gbmV3IEFycmF5KDE1Nikuam9pbignXFwwJylcbi8vIHBhZCB3aXRoIG51bGxzLCByZXR1cm4gdHJ1ZSBpZiBpdCdzIGxvbmdlciBvciBub24tYXNjaWlcbmNvbnN0IGVuY1N0cmluZyA9IChidWYsIG9mZiwgc2l6ZSwgc3RyaW5nKSA9PlxuICBzdHJpbmcgPT09IG51bGwgPyBmYWxzZSA6XG4gIChidWYud3JpdGUoc3RyaW5nICsgTlVMTFMsIG9mZiwgc2l6ZSwgJ3V0ZjgnKSxcbiAgc3RyaW5nLmxlbmd0aCAhPT0gQnVmZmVyLmJ5dGVMZW5ndGgoc3RyaW5nKSB8fCBzdHJpbmcubGVuZ3RoID4gc2l6ZSlcblxubW9kdWxlLmV4cG9ydHMgPSBIZWFkZXJcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/header.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/high-level-opt.js":
/*!************************************************!*\
  !*** ./node_modules/tar/lib/high-level-opt.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\n\nconst argmap = new Map([\n  ['C', 'cwd'],\n  ['f', 'file'],\n  ['z', 'gzip'],\n  ['P', 'preservePaths'],\n  ['U', 'unlink'],\n  ['strip-components', 'strip'],\n  ['stripComponents', 'strip'],\n  ['keep-newer', 'newer'],\n  ['keepNewer', 'newer'],\n  ['keep-newer-files', 'newer'],\n  ['keepNewerFiles', 'newer'],\n  ['k', 'keep'],\n  ['keep-existing', 'keep'],\n  ['keepExisting', 'keep'],\n  ['m', 'noMtime'],\n  ['no-mtime', 'noMtime'],\n  ['p', 'preserveOwner'],\n  ['L', 'follow'],\n  ['h', 'follow'],\n])\n\nmodule.exports = opt => opt ? Object.keys(opt).map(k => [\n  argmap.has(k) ? argmap.get(k) : k, opt[k],\n]).reduce((set, kv) => (set[kv[0]] = kv[1], set), Object.create(null)) : {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9oaWdoLWxldmVsLW9wdC5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL2hpZ2gtbGV2ZWwtb3B0LmpzPzgzMTMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHR1cm4gdGFyKDEpIHN0eWxlIGFyZ3MgbGlrZSBgQ2AgaW50byB0aGUgbW9yZSB2ZXJib3NlIHRoaW5ncyBsaWtlIGBjd2RgXG5cbmNvbnN0IGFyZ21hcCA9IG5ldyBNYXAoW1xuICBbJ0MnLCAnY3dkJ10sXG4gIFsnZicsICdmaWxlJ10sXG4gIFsneicsICdnemlwJ10sXG4gIFsnUCcsICdwcmVzZXJ2ZVBhdGhzJ10sXG4gIFsnVScsICd1bmxpbmsnXSxcbiAgWydzdHJpcC1jb21wb25lbnRzJywgJ3N0cmlwJ10sXG4gIFsnc3RyaXBDb21wb25lbnRzJywgJ3N0cmlwJ10sXG4gIFsna2VlcC1uZXdlcicsICduZXdlciddLFxuICBbJ2tlZXBOZXdlcicsICduZXdlciddLFxuICBbJ2tlZXAtbmV3ZXItZmlsZXMnLCAnbmV3ZXInXSxcbiAgWydrZWVwTmV3ZXJGaWxlcycsICduZXdlciddLFxuICBbJ2snLCAna2VlcCddLFxuICBbJ2tlZXAtZXhpc3RpbmcnLCAna2VlcCddLFxuICBbJ2tlZXBFeGlzdGluZycsICdrZWVwJ10sXG4gIFsnbScsICdub010aW1lJ10sXG4gIFsnbm8tbXRpbWUnLCAnbm9NdGltZSddLFxuICBbJ3AnLCAncHJlc2VydmVPd25lciddLFxuICBbJ0wnLCAnZm9sbG93J10sXG4gIFsnaCcsICdmb2xsb3cnXSxcbl0pXG5cbm1vZHVsZS5leHBvcnRzID0gb3B0ID0+IG9wdCA/IE9iamVjdC5rZXlzKG9wdCkubWFwKGsgPT4gW1xuICBhcmdtYXAuaGFzKGspID8gYXJnbWFwLmdldChrKSA6IGssIG9wdFtrXSxcbl0pLnJlZHVjZSgoc2V0LCBrdikgPT4gKHNldFtrdlswXV0gPSBrdlsxXSwgc2V0KSwgT2JqZWN0LmNyZWF0ZShudWxsKSkgOiB7fVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/high-level-opt.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/large-numbers.js":
/*!***********************************************!*\
  !*** ./node_modules/tar/lib/large-numbers.js ***!
  \***********************************************/
/***/ ((module) => {

"use strict";
eval("\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\n\nconst encode = (num, buf) => {\n  if (!Number.isSafeInteger(num)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('cannot encode number outside of javascript safe integer range')\n  } else if (num < 0) {\n    encodeNegative(num, buf)\n  } else {\n    encodePositive(num, buf)\n  }\n  return buf\n}\n\nconst encodePositive = (num, buf) => {\n  buf[0] = 0x80\n\n  for (var i = buf.length; i > 1; i--) {\n    buf[i - 1] = num & 0xff\n    num = Math.floor(num / 0x100)\n  }\n}\n\nconst encodeNegative = (num, buf) => {\n  buf[0] = 0xff\n  var flipped = false\n  num = num * -1\n  for (var i = buf.length; i > 1; i--) {\n    var byte = num & 0xff\n    num = Math.floor(num / 0x100)\n    if (flipped) {\n      buf[i - 1] = onesComp(byte)\n    } else if (byte === 0) {\n      buf[i - 1] = 0\n    } else {\n      flipped = true\n      buf[i - 1] = twosComp(byte)\n    }\n  }\n}\n\nconst parse = (buf) => {\n  const pre = buf[0]\n  const value = pre === 0x80 ? pos(buf.slice(1, buf.length))\n    : pre === 0xff ? twos(buf)\n    : null\n  if (value === null) {\n    throw Error('invalid base256 encoding')\n  }\n\n  if (!Number.isSafeInteger(value)) {\n  // The number is so large that javascript cannot represent it with integer\n  // precision.\n    throw Error('parsed number outside of javascript safe integer range')\n  }\n\n  return value\n}\n\nconst twos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  var flipped = false\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    var f\n    if (flipped) {\n      f = onesComp(byte)\n    } else if (byte === 0) {\n      f = byte\n    } else {\n      flipped = true\n      f = twosComp(byte)\n    }\n    if (f !== 0) {\n      sum -= f * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst pos = (buf) => {\n  var len = buf.length\n  var sum = 0\n  for (var i = len - 1; i > -1; i--) {\n    var byte = buf[i]\n    if (byte !== 0) {\n      sum += byte * Math.pow(256, len - i - 1)\n    }\n  }\n  return sum\n}\n\nconst onesComp = byte => (0xff ^ byte) & 0xff\n\nconst twosComp = byte => ((0xff ^ byte) + 1) & 0xff\n\nmodule.exports = {\n  encode,\n  parse,\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9sYXJnZS1udW1iZXJzLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkJBQTJCLE9BQU87QUFDbEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixRQUFRO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL2xhcmdlLW51bWJlcnMuanM/ODE2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbi8vIFRhciBjYW4gZW5jb2RlIGxhcmdlIGFuZCBuZWdhdGl2ZSBudW1iZXJzIHVzaW5nIGEgbGVhZGluZyBieXRlIG9mXG4vLyAweGZmIGZvciBuZWdhdGl2ZSwgYW5kIDB4ODAgZm9yIHBvc2l0aXZlLlxuXG5jb25zdCBlbmNvZGUgPSAobnVtLCBidWYpID0+IHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihudW0pKSB7XG4gIC8vIFRoZSBudW1iZXIgaXMgc28gbGFyZ2UgdGhhdCBqYXZhc2NyaXB0IGNhbm5vdCByZXByZXNlbnQgaXQgd2l0aCBpbnRlZ2VyXG4gIC8vIHByZWNpc2lvbi5cbiAgICB0aHJvdyBFcnJvcignY2Fubm90IGVuY29kZSBudW1iZXIgb3V0c2lkZSBvZiBqYXZhc2NyaXB0IHNhZmUgaW50ZWdlciByYW5nZScpXG4gIH0gZWxzZSBpZiAobnVtIDwgMCkge1xuICAgIGVuY29kZU5lZ2F0aXZlKG51bSwgYnVmKVxuICB9IGVsc2Uge1xuICAgIGVuY29kZVBvc2l0aXZlKG51bSwgYnVmKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuY29uc3QgZW5jb2RlUG9zaXRpdmUgPSAobnVtLCBidWYpID0+IHtcbiAgYnVmWzBdID0gMHg4MFxuXG4gIGZvciAodmFyIGkgPSBidWYubGVuZ3RoOyBpID4gMTsgaS0tKSB7XG4gICAgYnVmW2kgLSAxXSA9IG51bSAmIDB4ZmZcbiAgICBudW0gPSBNYXRoLmZsb29yKG51bSAvIDB4MTAwKVxuICB9XG59XG5cbmNvbnN0IGVuY29kZU5lZ2F0aXZlID0gKG51bSwgYnVmKSA9PiB7XG4gIGJ1ZlswXSA9IDB4ZmZcbiAgdmFyIGZsaXBwZWQgPSBmYWxzZVxuICBudW0gPSBudW0gKiAtMVxuICBmb3IgKHZhciBpID0gYnVmLmxlbmd0aDsgaSA+IDE7IGktLSkge1xuICAgIHZhciBieXRlID0gbnVtICYgMHhmZlxuICAgIG51bSA9IE1hdGguZmxvb3IobnVtIC8gMHgxMDApXG4gICAgaWYgKGZsaXBwZWQpIHtcbiAgICAgIGJ1ZltpIC0gMV0gPSBvbmVzQ29tcChieXRlKVxuICAgIH0gZWxzZSBpZiAoYnl0ZSA9PT0gMCkge1xuICAgICAgYnVmW2kgLSAxXSA9IDBcbiAgICB9IGVsc2Uge1xuICAgICAgZmxpcHBlZCA9IHRydWVcbiAgICAgIGJ1ZltpIC0gMV0gPSB0d29zQ29tcChieXRlKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBwYXJzZSA9IChidWYpID0+IHtcbiAgY29uc3QgcHJlID0gYnVmWzBdXG4gIGNvbnN0IHZhbHVlID0gcHJlID09PSAweDgwID8gcG9zKGJ1Zi5zbGljZSgxLCBidWYubGVuZ3RoKSlcbiAgICA6IHByZSA9PT0gMHhmZiA/IHR3b3MoYnVmKVxuICAgIDogbnVsbFxuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICB0aHJvdyBFcnJvcignaW52YWxpZCBiYXNlMjU2IGVuY29kaW5nJylcbiAgfVxuXG4gIGlmICghTnVtYmVyLmlzU2FmZUludGVnZXIodmFsdWUpKSB7XG4gIC8vIFRoZSBudW1iZXIgaXMgc28gbGFyZ2UgdGhhdCBqYXZhc2NyaXB0IGNhbm5vdCByZXByZXNlbnQgaXQgd2l0aCBpbnRlZ2VyXG4gIC8vIHByZWNpc2lvbi5cbiAgICB0aHJvdyBFcnJvcigncGFyc2VkIG51bWJlciBvdXRzaWRlIG9mIGphdmFzY3JpcHQgc2FmZSBpbnRlZ2VyIHJhbmdlJylcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuXG5jb25zdCB0d29zID0gKGJ1ZikgPT4ge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICB2YXIgc3VtID0gMFxuICB2YXIgZmxpcHBlZCA9IGZhbHNlXG4gIGZvciAodmFyIGkgPSBsZW4gLSAxOyBpID4gLTE7IGktLSkge1xuICAgIHZhciBieXRlID0gYnVmW2ldXG4gICAgdmFyIGZcbiAgICBpZiAoZmxpcHBlZCkge1xuICAgICAgZiA9IG9uZXNDb21wKGJ5dGUpXG4gICAgfSBlbHNlIGlmIChieXRlID09PSAwKSB7XG4gICAgICBmID0gYnl0ZVxuICAgIH0gZWxzZSB7XG4gICAgICBmbGlwcGVkID0gdHJ1ZVxuICAgICAgZiA9IHR3b3NDb21wKGJ5dGUpXG4gICAgfVxuICAgIGlmIChmICE9PSAwKSB7XG4gICAgICBzdW0gLT0gZiAqIE1hdGgucG93KDI1NiwgbGVuIC0gaSAtIDEpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdW1cbn1cblxuY29uc3QgcG9zID0gKGJ1ZikgPT4ge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuICB2YXIgc3VtID0gMFxuICBmb3IgKHZhciBpID0gbGVuIC0gMTsgaSA+IC0xOyBpLS0pIHtcbiAgICB2YXIgYnl0ZSA9IGJ1ZltpXVxuICAgIGlmIChieXRlICE9PSAwKSB7XG4gICAgICBzdW0gKz0gYnl0ZSAqIE1hdGgucG93KDI1NiwgbGVuIC0gaSAtIDEpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdW1cbn1cblxuY29uc3Qgb25lc0NvbXAgPSBieXRlID0+ICgweGZmIF4gYnl0ZSkgJiAweGZmXG5cbmNvbnN0IHR3b3NDb21wID0gYnl0ZSA9PiAoKDB4ZmYgXiBieXRlKSArIDEpICYgMHhmZlxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2RlLFxuICBwYXJzZSxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/large-numbers.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/list.js":
/*!**************************************!*\
  !*** ./node_modules/tar/lib/list.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// XXX: This shares a lot in common with extract.js\n// maybe some DRY opportunity here?\n\n// tar -t\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst Parser = __webpack_require__(/*! ./parse.js */ \"./node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/lib/strip-trailing-slashes.js\")\n\nmodule.exports = (opt_, files, cb) => {\n  if (typeof opt_ === 'function') {\n    cb = opt_, files = null, opt_ = {}\n  } else if (Array.isArray(opt_)) {\n    files = opt_, opt_ = {}\n  }\n\n  if (typeof files === 'function') {\n    cb = files, files = null\n  }\n\n  if (!files) {\n    files = []\n  } else {\n    files = Array.from(files)\n  }\n\n  const opt = hlo(opt_)\n\n  if (opt.sync && typeof cb === 'function') {\n    throw new TypeError('callback not supported for sync tar functions')\n  }\n\n  if (!opt.file && typeof cb === 'function') {\n    throw new TypeError('callback only supported with file option')\n  }\n\n  if (files.length) {\n    filesFilter(opt, files)\n  }\n\n  if (!opt.noResume) {\n    onentryFunction(opt)\n  }\n\n  return opt.file && opt.sync ? listFileSync(opt)\n    : opt.file ? listFile(opt, cb)\n    : list(opt)\n}\n\nconst onentryFunction = opt => {\n  const onentry = opt.onentry\n  opt.onentry = onentry ? e => {\n    onentry(e)\n    e.resume()\n  } : e => e.resume()\n}\n\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n  const map = new Map(files.map(f => [stripSlash(f), true]))\n  const filter = opt.filter\n\n  const mapHas = (file, r) => {\n    const root = r || path.parse(file).root || '.'\n    const ret = file === root ? false\n      : map.has(file) ? map.get(file)\n      : mapHas(path.dirname(file), root)\n\n    map.set(file, ret)\n    return ret\n  }\n\n  opt.filter = filter\n    ? (file, entry) => filter(file, entry) && mapHas(stripSlash(file))\n    : file => mapHas(stripSlash(file))\n}\n\nconst listFileSync = opt => {\n  const p = list(opt)\n  const file = opt.file\n  let threw = true\n  let fd\n  try {\n    const stat = fs.statSync(file)\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024\n    if (stat.size < readSize) {\n      p.end(fs.readFileSync(file))\n    } else {\n      let pos = 0\n      const buf = Buffer.allocUnsafe(readSize)\n      fd = fs.openSync(file, 'r')\n      while (pos < stat.size) {\n        const bytesRead = fs.readSync(fd, buf, 0, readSize, pos)\n        pos += bytesRead\n        p.write(buf.slice(0, bytesRead))\n      }\n      p.end()\n    }\n    threw = false\n  } finally {\n    if (threw && fd) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst listFile = (opt, cb) => {\n  const parse = new Parser(opt)\n  const readSize = opt.maxReadSize || 16 * 1024 * 1024\n\n  const file = opt.file\n  const p = new Promise((resolve, reject) => {\n    parse.on('error', reject)\n    parse.on('end', resolve)\n\n    fs.stat(file, (er, stat) => {\n      if (er) {\n        reject(er)\n      } else {\n        const stream = new fsm.ReadStream(file, {\n          readSize: readSize,\n          size: stat.size,\n        })\n        stream.on('error', reject)\n        stream.pipe(parse)\n      }\n    })\n  })\n  return cb ? p.then(cb, cb) : p\n}\n\nconst list = opt => new Parser(opt)\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9saXN0LmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLG1CQUFPLENBQUMscUVBQXFCO0FBQ3pDLGVBQWUsbUJBQU8sQ0FBQyxtREFBWTtBQUNuQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixZQUFZLG1CQUFPLENBQUMsd0RBQWE7QUFDakMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLG1CQUFtQixtQkFBTyxDQUFDLHFGQUE2Qjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbGlzdC5qcz81ZGUzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBYWFg6IFRoaXMgc2hhcmVzIGEgbG90IGluIGNvbW1vbiB3aXRoIGV4dHJhY3QuanNcbi8vIG1heWJlIHNvbWUgRFJZIG9wcG9ydHVuaXR5IGhlcmU/XG5cbi8vIHRhciAtdFxuY29uc3QgaGxvID0gcmVxdWlyZSgnLi9oaWdoLWxldmVsLW9wdC5qcycpXG5jb25zdCBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlLmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnMtbWluaXBhc3MnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3Qgc3RyaXBTbGFzaCA9IHJlcXVpcmUoJy4vc3RyaXAtdHJhaWxpbmctc2xhc2hlcy5qcycpXG5cbm1vZHVsZS5leHBvcnRzID0gKG9wdF8sIGZpbGVzLCBjYikgPT4ge1xuICBpZiAodHlwZW9mIG9wdF8gPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IG9wdF8sIGZpbGVzID0gbnVsbCwgb3B0XyA9IHt9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvcHRfKSkge1xuICAgIGZpbGVzID0gb3B0Xywgb3B0XyA9IHt9XG4gIH1cblxuICBpZiAodHlwZW9mIGZpbGVzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBmaWxlcywgZmlsZXMgPSBudWxsXG4gIH1cblxuICBpZiAoIWZpbGVzKSB7XG4gICAgZmlsZXMgPSBbXVxuICB9IGVsc2Uge1xuICAgIGZpbGVzID0gQXJyYXkuZnJvbShmaWxlcylcbiAgfVxuXG4gIGNvbnN0IG9wdCA9IGhsbyhvcHRfKVxuXG4gIGlmIChvcHQuc3luYyAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBub3Qgc3VwcG9ydGVkIGZvciBzeW5jIHRhciBmdW5jdGlvbnMnKVxuICB9XG5cbiAgaWYgKCFvcHQuZmlsZSAmJiB0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYWxsYmFjayBvbmx5IHN1cHBvcnRlZCB3aXRoIGZpbGUgb3B0aW9uJylcbiAgfVxuXG4gIGlmIChmaWxlcy5sZW5ndGgpIHtcbiAgICBmaWxlc0ZpbHRlcihvcHQsIGZpbGVzKVxuICB9XG5cbiAgaWYgKCFvcHQubm9SZXN1bWUpIHtcbiAgICBvbmVudHJ5RnVuY3Rpb24ob3B0KVxuICB9XG5cbiAgcmV0dXJuIG9wdC5maWxlICYmIG9wdC5zeW5jID8gbGlzdEZpbGVTeW5jKG9wdClcbiAgICA6IG9wdC5maWxlID8gbGlzdEZpbGUob3B0LCBjYilcbiAgICA6IGxpc3Qob3B0KVxufVxuXG5jb25zdCBvbmVudHJ5RnVuY3Rpb24gPSBvcHQgPT4ge1xuICBjb25zdCBvbmVudHJ5ID0gb3B0Lm9uZW50cnlcbiAgb3B0Lm9uZW50cnkgPSBvbmVudHJ5ID8gZSA9PiB7XG4gICAgb25lbnRyeShlKVxuICAgIGUucmVzdW1lKClcbiAgfSA6IGUgPT4gZS5yZXN1bWUoKVxufVxuXG4vLyBjb25zdHJ1Y3QgYSBmaWx0ZXIgdGhhdCBsaW1pdHMgdGhlIGZpbGUgZW50cmllcyBsaXN0ZWRcbi8vIGluY2x1ZGUgY2hpbGQgZW50cmllcyBpZiBhIGRpciBpcyBpbmNsdWRlZFxuY29uc3QgZmlsZXNGaWx0ZXIgPSAob3B0LCBmaWxlcykgPT4ge1xuICBjb25zdCBtYXAgPSBuZXcgTWFwKGZpbGVzLm1hcChmID0+IFtzdHJpcFNsYXNoKGYpLCB0cnVlXSkpXG4gIGNvbnN0IGZpbHRlciA9IG9wdC5maWx0ZXJcblxuICBjb25zdCBtYXBIYXMgPSAoZmlsZSwgcikgPT4ge1xuICAgIGNvbnN0IHJvb3QgPSByIHx8IHBhdGgucGFyc2UoZmlsZSkucm9vdCB8fCAnLidcbiAgICBjb25zdCByZXQgPSBmaWxlID09PSByb290ID8gZmFsc2VcbiAgICAgIDogbWFwLmhhcyhmaWxlKSA/IG1hcC5nZXQoZmlsZSlcbiAgICAgIDogbWFwSGFzKHBhdGguZGlybmFtZShmaWxlKSwgcm9vdClcblxuICAgIG1hcC5zZXQoZmlsZSwgcmV0KVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIG9wdC5maWx0ZXIgPSBmaWx0ZXJcbiAgICA/IChmaWxlLCBlbnRyeSkgPT4gZmlsdGVyKGZpbGUsIGVudHJ5KSAmJiBtYXBIYXMoc3RyaXBTbGFzaChmaWxlKSlcbiAgICA6IGZpbGUgPT4gbWFwSGFzKHN0cmlwU2xhc2goZmlsZSkpXG59XG5cbmNvbnN0IGxpc3RGaWxlU3luYyA9IG9wdCA9PiB7XG4gIGNvbnN0IHAgPSBsaXN0KG9wdClcbiAgY29uc3QgZmlsZSA9IG9wdC5maWxlXG4gIGxldCB0aHJldyA9IHRydWVcbiAgbGV0IGZkXG4gIHRyeSB7XG4gICAgY29uc3Qgc3RhdCA9IGZzLnN0YXRTeW5jKGZpbGUpXG4gICAgY29uc3QgcmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemUgfHwgMTYgKiAxMDI0ICogMTAyNFxuICAgIGlmIChzdGF0LnNpemUgPCByZWFkU2l6ZSkge1xuICAgICAgcC5lbmQoZnMucmVhZEZpbGVTeW5jKGZpbGUpKVxuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgcG9zID0gMFxuICAgICAgY29uc3QgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKHJlYWRTaXplKVxuICAgICAgZmQgPSBmcy5vcGVuU3luYyhmaWxlLCAncicpXG4gICAgICB3aGlsZSAocG9zIDwgc3RhdC5zaXplKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzUmVhZCA9IGZzLnJlYWRTeW5jKGZkLCBidWYsIDAsIHJlYWRTaXplLCBwb3MpXG4gICAgICAgIHBvcyArPSBieXRlc1JlYWRcbiAgICAgICAgcC53cml0ZShidWYuc2xpY2UoMCwgYnl0ZXNSZWFkKSlcbiAgICAgIH1cbiAgICAgIHAuZW5kKClcbiAgICB9XG4gICAgdGhyZXcgPSBmYWxzZVxuICB9IGZpbmFsbHkge1xuICAgIGlmICh0aHJldyAmJiBmZCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IGxpc3RGaWxlID0gKG9wdCwgY2IpID0+IHtcbiAgY29uc3QgcGFyc2UgPSBuZXcgUGFyc2VyKG9wdClcbiAgY29uc3QgcmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemUgfHwgMTYgKiAxMDI0ICogMTAyNFxuXG4gIGNvbnN0IGZpbGUgPSBvcHQuZmlsZVxuICBjb25zdCBwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHBhcnNlLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICBwYXJzZS5vbignZW5kJywgcmVzb2x2ZSlcblxuICAgIGZzLnN0YXQoZmlsZSwgKGVyLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgcmVqZWN0KGVyKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3Qgc3RyZWFtID0gbmV3IGZzbS5SZWFkU3RyZWFtKGZpbGUsIHtcbiAgICAgICAgICByZWFkU2l6ZTogcmVhZFNpemUsXG4gICAgICAgICAgc2l6ZTogc3RhdC5zaXplLFxuICAgICAgICB9KVxuICAgICAgICBzdHJlYW0ub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgICAgICBzdHJlYW0ucGlwZShwYXJzZSlcbiAgICAgIH1cbiAgICB9KVxuICB9KVxuICByZXR1cm4gY2IgPyBwLnRoZW4oY2IsIGNiKSA6IHBcbn1cblxuY29uc3QgbGlzdCA9IG9wdCA9PiBuZXcgUGFyc2VyKG9wdClcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/list.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/mkdir.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/mkdir.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n// wrapper around mkdirp for tar's needs.\n\n// TODO: This should probably be a class, not functionally\n// passing around state in a gazillion args.\n\nconst mkdirp = __webpack_require__(/*! mkdirp */ \"./node_modules/mkdirp/index.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst chownr = __webpack_require__(/*! chownr */ \"./node_modules/chownr/chownr.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/lib/normalize-windows-path.js\")\n\nclass SymlinkError extends Error {\n  constructor (symlink, path) {\n    super('Cannot extract through symbolic link')\n    this.path = path\n    this.symlink = symlink\n  }\n\n  get name () {\n    return 'SylinkError'\n  }\n}\n\nclass CwdError extends Error {\n  constructor (path, code) {\n    super(code + ': Cannot cd into \\'' + path + '\\'')\n    this.path = path\n    this.code = code\n  }\n\n  get name () {\n    return 'CwdError'\n  }\n}\n\nconst cGet = (cache, key) => cache.get(normPath(key))\nconst cSet = (cache, key, val) => cache.set(normPath(key), val)\n\nconst checkCwd = (dir, cb) => {\n  fs.stat(dir, (er, st) => {\n    if (er || !st.isDirectory()) {\n      er = new CwdError(dir, er && er.code || 'ENOTDIR')\n    }\n    cb(er)\n  })\n}\n\nmodule.exports = (dir, opt, cb) => {\n  dir = normPath(dir)\n\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (er, created) => {\n    if (er) {\n      cb(er)\n    } else {\n      cSet(cache, dir, true)\n      if (created && doChown) {\n        chownr(created, uid, gid, er => done(er))\n      } else if (needChmod) {\n        fs.chmod(dir, mode, cb)\n      } else {\n        cb()\n      }\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true) {\n    return done()\n  }\n\n  if (dir === cwd) {\n    return checkCwd(dir, done)\n  }\n\n  if (preserve) {\n    return mkdirp(dir, { mode }).then(made => done(null, made), done)\n  }\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  mkdir_(cwd, parts, mode, cache, unlink, cwd, null, done)\n}\n\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n  if (!parts.length) {\n    return cb(null, created)\n  }\n  const p = parts.shift()\n  const part = normPath(path.resolve(base + '/' + p))\n  if (cGet(cache, part)) {\n    return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n  fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n}\n\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => er => {\n  if (er) {\n    fs.lstat(part, (statEr, st) => {\n      if (statEr) {\n        statEr.path = statEr.path && normPath(statEr.path)\n        cb(statEr)\n      } else if (st.isDirectory()) {\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n      } else if (unlink) {\n        fs.unlink(part, er => {\n          if (er) {\n            return cb(er)\n          }\n          fs.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb))\n        })\n      } else if (st.isSymbolicLink()) {\n        return cb(new SymlinkError(part, part + '/' + parts.join('/')))\n      } else {\n        cb(er)\n      }\n    })\n  } else {\n    created = created || part\n    mkdir_(part, parts, mode, cache, unlink, cwd, created, cb)\n  }\n}\n\nconst checkCwdSync = dir => {\n  let ok = false\n  let code = 'ENOTDIR'\n  try {\n    ok = fs.statSync(dir).isDirectory()\n  } catch (er) {\n    code = er.code\n  } finally {\n    if (!ok) {\n      throw new CwdError(dir, code)\n    }\n  }\n}\n\nmodule.exports.sync = (dir, opt) => {\n  dir = normPath(dir)\n  // if there's any overlap between mask and mode,\n  // then we'll need an explicit chmod\n  const umask = opt.umask\n  const mode = opt.mode | 0o0700\n  const needChmod = (mode & umask) !== 0\n\n  const uid = opt.uid\n  const gid = opt.gid\n  const doChown = typeof uid === 'number' &&\n    typeof gid === 'number' &&\n    (uid !== opt.processUid || gid !== opt.processGid)\n\n  const preserve = opt.preserve\n  const unlink = opt.unlink\n  const cache = opt.cache\n  const cwd = normPath(opt.cwd)\n\n  const done = (created) => {\n    cSet(cache, dir, true)\n    if (created && doChown) {\n      chownr.sync(created, uid, gid)\n    }\n    if (needChmod) {\n      fs.chmodSync(dir, mode)\n    }\n  }\n\n  if (cache && cGet(cache, dir) === true) {\n    return done()\n  }\n\n  if (dir === cwd) {\n    checkCwdSync(cwd)\n    return done()\n  }\n\n  if (preserve) {\n    return done(mkdirp.sync(dir, mode))\n  }\n\n  const sub = normPath(path.relative(cwd, dir))\n  const parts = sub.split('/')\n  let created = null\n  for (let p = parts.shift(), part = cwd;\n    p && (part += '/' + p);\n    p = parts.shift()) {\n    part = normPath(path.resolve(part))\n    if (cGet(cache, part)) {\n      continue\n    }\n\n    try {\n      fs.mkdirSync(part, mode)\n      created = created || part\n      cSet(cache, part, true)\n    } catch (er) {\n      const st = fs.lstatSync(part)\n      if (st.isDirectory()) {\n        cSet(cache, part, true)\n        continue\n      } else if (unlink) {\n        fs.unlinkSync(part)\n        fs.mkdirSync(part, mode)\n        created = created || part\n        cSet(cache, part, true)\n        continue\n      } else if (st.isSymbolicLink()) {\n        return new SymlinkError(part, part + '/' + parts.join('/'))\n      }\n    }\n  }\n\n  return done(created)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9ta2Rpci5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaOztBQUVBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLDhDQUFRO0FBQy9CLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLGFBQWEsbUJBQU8sQ0FBQyxrQkFBTTtBQUMzQixlQUFlLG1CQUFPLENBQUMsK0NBQVE7QUFDL0IsaUJBQWlCLG1CQUFPLENBQUMscUZBQTZCOztBQUV0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9COztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL21rZGlyLmpzPzE0YTEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyB3cmFwcGVyIGFyb3VuZCBta2RpcnAgZm9yIHRhcidzIG5lZWRzLlxuXG4vLyBUT0RPOiBUaGlzIHNob3VsZCBwcm9iYWJseSBiZSBhIGNsYXNzLCBub3QgZnVuY3Rpb25hbGx5XG4vLyBwYXNzaW5nIGFyb3VuZCBzdGF0ZSBpbiBhIGdhemlsbGlvbiBhcmdzLlxuXG5jb25zdCBta2RpcnAgPSByZXF1aXJlKCdta2RpcnAnKVxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBjaG93bnIgPSByZXF1aXJlKCdjaG93bnInKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuXG5jbGFzcyBTeW1saW5rRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yIChzeW1saW5rLCBwYXRoKSB7XG4gICAgc3VwZXIoJ0Nhbm5vdCBleHRyYWN0IHRocm91Z2ggc3ltYm9saWMgbGluaycpXG4gICAgdGhpcy5wYXRoID0gcGF0aFxuICAgIHRoaXMuc3ltbGluayA9IHN5bWxpbmtcbiAgfVxuXG4gIGdldCBuYW1lICgpIHtcbiAgICByZXR1cm4gJ1N5bGlua0Vycm9yJ1xuICB9XG59XG5cbmNsYXNzIEN3ZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvciAocGF0aCwgY29kZSkge1xuICAgIHN1cGVyKGNvZGUgKyAnOiBDYW5ub3QgY2QgaW50byBcXCcnICsgcGF0aCArICdcXCcnKVxuICAgIHRoaXMucGF0aCA9IHBhdGhcbiAgICB0aGlzLmNvZGUgPSBjb2RlXG4gIH1cblxuICBnZXQgbmFtZSAoKSB7XG4gICAgcmV0dXJuICdDd2RFcnJvcidcbiAgfVxufVxuXG5jb25zdCBjR2V0ID0gKGNhY2hlLCBrZXkpID0+IGNhY2hlLmdldChub3JtUGF0aChrZXkpKVxuY29uc3QgY1NldCA9IChjYWNoZSwga2V5LCB2YWwpID0+IGNhY2hlLnNldChub3JtUGF0aChrZXkpLCB2YWwpXG5cbmNvbnN0IGNoZWNrQ3dkID0gKGRpciwgY2IpID0+IHtcbiAgZnMuc3RhdChkaXIsIChlciwgc3QpID0+IHtcbiAgICBpZiAoZXIgfHwgIXN0LmlzRGlyZWN0b3J5KCkpIHtcbiAgICAgIGVyID0gbmV3IEN3ZEVycm9yKGRpciwgZXIgJiYgZXIuY29kZSB8fCAnRU5PVERJUicpXG4gICAgfVxuICAgIGNiKGVyKVxuICB9KVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IChkaXIsIG9wdCwgY2IpID0+IHtcbiAgZGlyID0gbm9ybVBhdGgoZGlyKVxuXG4gIC8vIGlmIHRoZXJlJ3MgYW55IG92ZXJsYXAgYmV0d2VlbiBtYXNrIGFuZCBtb2RlLFxuICAvLyB0aGVuIHdlJ2xsIG5lZWQgYW4gZXhwbGljaXQgY2htb2RcbiAgY29uc3QgdW1hc2sgPSBvcHQudW1hc2tcbiAgY29uc3QgbW9kZSA9IG9wdC5tb2RlIHwgMG8wNzAwXG4gIGNvbnN0IG5lZWRDaG1vZCA9IChtb2RlICYgdW1hc2spICE9PSAwXG5cbiAgY29uc3QgdWlkID0gb3B0LnVpZFxuICBjb25zdCBnaWQgPSBvcHQuZ2lkXG4gIGNvbnN0IGRvQ2hvd24gPSB0eXBlb2YgdWlkID09PSAnbnVtYmVyJyAmJlxuICAgIHR5cGVvZiBnaWQgPT09ICdudW1iZXInICYmXG4gICAgKHVpZCAhPT0gb3B0LnByb2Nlc3NVaWQgfHwgZ2lkICE9PSBvcHQucHJvY2Vzc0dpZClcblxuICBjb25zdCBwcmVzZXJ2ZSA9IG9wdC5wcmVzZXJ2ZVxuICBjb25zdCB1bmxpbmsgPSBvcHQudW5saW5rXG4gIGNvbnN0IGNhY2hlID0gb3B0LmNhY2hlXG4gIGNvbnN0IGN3ZCA9IG5vcm1QYXRoKG9wdC5jd2QpXG5cbiAgY29uc3QgZG9uZSA9IChlciwgY3JlYXRlZCkgPT4ge1xuICAgIGlmIChlcikge1xuICAgICAgY2IoZXIpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNTZXQoY2FjaGUsIGRpciwgdHJ1ZSlcbiAgICAgIGlmIChjcmVhdGVkICYmIGRvQ2hvd24pIHtcbiAgICAgICAgY2hvd25yKGNyZWF0ZWQsIHVpZCwgZ2lkLCBlciA9PiBkb25lKGVyKSlcbiAgICAgIH0gZWxzZSBpZiAobmVlZENobW9kKSB7XG4gICAgICAgIGZzLmNobW9kKGRpciwgbW9kZSwgY2IpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYigpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKGNhY2hlICYmIGNHZXQoY2FjaGUsIGRpcikgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZG9uZSgpXG4gIH1cblxuICBpZiAoZGlyID09PSBjd2QpIHtcbiAgICByZXR1cm4gY2hlY2tDd2QoZGlyLCBkb25lKVxuICB9XG5cbiAgaWYgKHByZXNlcnZlKSB7XG4gICAgcmV0dXJuIG1rZGlycChkaXIsIHsgbW9kZSB9KS50aGVuKG1hZGUgPT4gZG9uZShudWxsLCBtYWRlKSwgZG9uZSlcbiAgfVxuXG4gIGNvbnN0IHN1YiA9IG5vcm1QYXRoKHBhdGgucmVsYXRpdmUoY3dkLCBkaXIpKVxuICBjb25zdCBwYXJ0cyA9IHN1Yi5zcGxpdCgnLycpXG4gIG1rZGlyXyhjd2QsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIG51bGwsIGRvbmUpXG59XG5cbmNvbnN0IG1rZGlyXyA9IChiYXNlLCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYikgPT4ge1xuICBpZiAoIXBhcnRzLmxlbmd0aCkge1xuICAgIHJldHVybiBjYihudWxsLCBjcmVhdGVkKVxuICB9XG4gIGNvbnN0IHAgPSBwYXJ0cy5zaGlmdCgpXG4gIGNvbnN0IHBhcnQgPSBub3JtUGF0aChwYXRoLnJlc29sdmUoYmFzZSArICcvJyArIHApKVxuICBpZiAoY0dldChjYWNoZSwgcGFydCkpIHtcbiAgICByZXR1cm4gbWtkaXJfKHBhcnQsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKVxuICB9XG4gIGZzLm1rZGlyKHBhcnQsIG1vZGUsIG9ubWtkaXIocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpKVxufVxuXG5jb25zdCBvbm1rZGlyID0gKHBhcnQsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKSA9PiBlciA9PiB7XG4gIGlmIChlcikge1xuICAgIGZzLmxzdGF0KHBhcnQsIChzdGF0RXIsIHN0KSA9PiB7XG4gICAgICBpZiAoc3RhdEVyKSB7XG4gICAgICAgIHN0YXRFci5wYXRoID0gc3RhdEVyLnBhdGggJiYgbm9ybVBhdGgoc3RhdEVyLnBhdGgpXG4gICAgICAgIGNiKHN0YXRFcilcbiAgICAgIH0gZWxzZSBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBta2Rpcl8ocGFydCwgcGFydHMsIG1vZGUsIGNhY2hlLCB1bmxpbmssIGN3ZCwgY3JlYXRlZCwgY2IpXG4gICAgICB9IGVsc2UgaWYgKHVubGluaykge1xuICAgICAgICBmcy51bmxpbmsocGFydCwgZXIgPT4ge1xuICAgICAgICAgIGlmIChlcikge1xuICAgICAgICAgICAgcmV0dXJuIGNiKGVyKVxuICAgICAgICAgIH1cbiAgICAgICAgICBmcy5ta2RpcihwYXJ0LCBtb2RlLCBvbm1rZGlyKHBhcnQsIHBhcnRzLCBtb2RlLCBjYWNoZSwgdW5saW5rLCBjd2QsIGNyZWF0ZWQsIGNiKSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSBpZiAoc3QuaXNTeW1ib2xpY0xpbmsoKSkge1xuICAgICAgICByZXR1cm4gY2IobmV3IFN5bWxpbmtFcnJvcihwYXJ0LCBwYXJ0ICsgJy8nICsgcGFydHMuam9pbignLycpKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNiKGVyKVxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgcGFydFxuICAgIG1rZGlyXyhwYXJ0LCBwYXJ0cywgbW9kZSwgY2FjaGUsIHVubGluaywgY3dkLCBjcmVhdGVkLCBjYilcbiAgfVxufVxuXG5jb25zdCBjaGVja0N3ZFN5bmMgPSBkaXIgPT4ge1xuICBsZXQgb2sgPSBmYWxzZVxuICBsZXQgY29kZSA9ICdFTk9URElSJ1xuICB0cnkge1xuICAgIG9rID0gZnMuc3RhdFN5bmMoZGlyKS5pc0RpcmVjdG9yeSgpXG4gIH0gY2F0Y2ggKGVyKSB7XG4gICAgY29kZSA9IGVyLmNvZGVcbiAgfSBmaW5hbGx5IHtcbiAgICBpZiAoIW9rKSB7XG4gICAgICB0aHJvdyBuZXcgQ3dkRXJyb3IoZGlyLCBjb2RlKVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5zeW5jID0gKGRpciwgb3B0KSA9PiB7XG4gIGRpciA9IG5vcm1QYXRoKGRpcilcbiAgLy8gaWYgdGhlcmUncyBhbnkgb3ZlcmxhcCBiZXR3ZWVuIG1hc2sgYW5kIG1vZGUsXG4gIC8vIHRoZW4gd2UnbGwgbmVlZCBhbiBleHBsaWNpdCBjaG1vZFxuICBjb25zdCB1bWFzayA9IG9wdC51bWFza1xuICBjb25zdCBtb2RlID0gb3B0Lm1vZGUgfCAwbzA3MDBcbiAgY29uc3QgbmVlZENobW9kID0gKG1vZGUgJiB1bWFzaykgIT09IDBcblxuICBjb25zdCB1aWQgPSBvcHQudWlkXG4gIGNvbnN0IGdpZCA9IG9wdC5naWRcbiAgY29uc3QgZG9DaG93biA9IHR5cGVvZiB1aWQgPT09ICdudW1iZXInICYmXG4gICAgdHlwZW9mIGdpZCA9PT0gJ251bWJlcicgJiZcbiAgICAodWlkICE9PSBvcHQucHJvY2Vzc1VpZCB8fCBnaWQgIT09IG9wdC5wcm9jZXNzR2lkKVxuXG4gIGNvbnN0IHByZXNlcnZlID0gb3B0LnByZXNlcnZlXG4gIGNvbnN0IHVubGluayA9IG9wdC51bmxpbmtcbiAgY29uc3QgY2FjaGUgPSBvcHQuY2FjaGVcbiAgY29uc3QgY3dkID0gbm9ybVBhdGgob3B0LmN3ZClcblxuICBjb25zdCBkb25lID0gKGNyZWF0ZWQpID0+IHtcbiAgICBjU2V0KGNhY2hlLCBkaXIsIHRydWUpXG4gICAgaWYgKGNyZWF0ZWQgJiYgZG9DaG93bikge1xuICAgICAgY2hvd25yLnN5bmMoY3JlYXRlZCwgdWlkLCBnaWQpXG4gICAgfVxuICAgIGlmIChuZWVkQ2htb2QpIHtcbiAgICAgIGZzLmNobW9kU3luYyhkaXIsIG1vZGUpXG4gICAgfVxuICB9XG5cbiAgaWYgKGNhY2hlICYmIGNHZXQoY2FjaGUsIGRpcikgPT09IHRydWUpIHtcbiAgICByZXR1cm4gZG9uZSgpXG4gIH1cblxuICBpZiAoZGlyID09PSBjd2QpIHtcbiAgICBjaGVja0N3ZFN5bmMoY3dkKVxuICAgIHJldHVybiBkb25lKClcbiAgfVxuXG4gIGlmIChwcmVzZXJ2ZSkge1xuICAgIHJldHVybiBkb25lKG1rZGlycC5zeW5jKGRpciwgbW9kZSkpXG4gIH1cblxuICBjb25zdCBzdWIgPSBub3JtUGF0aChwYXRoLnJlbGF0aXZlKGN3ZCwgZGlyKSlcbiAgY29uc3QgcGFydHMgPSBzdWIuc3BsaXQoJy8nKVxuICBsZXQgY3JlYXRlZCA9IG51bGxcbiAgZm9yIChsZXQgcCA9IHBhcnRzLnNoaWZ0KCksIHBhcnQgPSBjd2Q7XG4gICAgcCAmJiAocGFydCArPSAnLycgKyBwKTtcbiAgICBwID0gcGFydHMuc2hpZnQoKSkge1xuICAgIHBhcnQgPSBub3JtUGF0aChwYXRoLnJlc29sdmUocGFydCkpXG4gICAgaWYgKGNHZXQoY2FjaGUsIHBhcnQpKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBmcy5ta2RpclN5bmMocGFydCwgbW9kZSlcbiAgICAgIGNyZWF0ZWQgPSBjcmVhdGVkIHx8IHBhcnRcbiAgICAgIGNTZXQoY2FjaGUsIHBhcnQsIHRydWUpXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIGNvbnN0IHN0ID0gZnMubHN0YXRTeW5jKHBhcnQpXG4gICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmICh1bmxpbmspIHtcbiAgICAgICAgZnMudW5saW5rU3luYyhwYXJ0KVxuICAgICAgICBmcy5ta2RpclN5bmMocGFydCwgbW9kZSlcbiAgICAgICAgY3JlYXRlZCA9IGNyZWF0ZWQgfHwgcGFydFxuICAgICAgICBjU2V0KGNhY2hlLCBwYXJ0LCB0cnVlKVxuICAgICAgICBjb250aW51ZVxuICAgICAgfSBlbHNlIGlmIChzdC5pc1N5bWJvbGljTGluaygpKSB7XG4gICAgICAgIHJldHVybiBuZXcgU3ltbGlua0Vycm9yKHBhcnQsIHBhcnQgKyAnLycgKyBwYXJ0cy5qb2luKCcvJykpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGRvbmUoY3JlYXRlZClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/mkdir.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/mode-fix.js":
/*!******************************************!*\
  !*** ./node_modules/tar/lib/mode-fix.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = (mode, isDir, portable) => {\n  mode &= 0o7777\n\n  // in portable mode, use the minimum reasonable umask\n  // if this system creates files with 0o664 by default\n  // (as some linux distros do), then we'll write the\n  // archive with 0o644 instead.  Also, don't ever create\n  // a file that is not readable/writable by the owner.\n  if (portable) {\n    mode = (mode | 0o600) & ~0o22\n  }\n\n  // if dirs are readable, then they should be listable\n  if (isDir) {\n    if (mode & 0o400) {\n      mode |= 0o100\n    }\n    if (mode & 0o40) {\n      mode |= 0o10\n    }\n    if (mode & 0o4) {\n      mode |= 0o1\n    }\n  }\n  return mode\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9tb2RlLWZpeC5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL21vZGUtZml4LmpzP2JhOTYiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IChtb2RlLCBpc0RpciwgcG9ydGFibGUpID0+IHtcbiAgbW9kZSAmPSAwbzc3NzdcblxuICAvLyBpbiBwb3J0YWJsZSBtb2RlLCB1c2UgdGhlIG1pbmltdW0gcmVhc29uYWJsZSB1bWFza1xuICAvLyBpZiB0aGlzIHN5c3RlbSBjcmVhdGVzIGZpbGVzIHdpdGggMG82NjQgYnkgZGVmYXVsdFxuICAvLyAoYXMgc29tZSBsaW51eCBkaXN0cm9zIGRvKSwgdGhlbiB3ZSdsbCB3cml0ZSB0aGVcbiAgLy8gYXJjaGl2ZSB3aXRoIDBvNjQ0IGluc3RlYWQuICBBbHNvLCBkb24ndCBldmVyIGNyZWF0ZVxuICAvLyBhIGZpbGUgdGhhdCBpcyBub3QgcmVhZGFibGUvd3JpdGFibGUgYnkgdGhlIG93bmVyLlxuICBpZiAocG9ydGFibGUpIHtcbiAgICBtb2RlID0gKG1vZGUgfCAwbzYwMCkgJiB+MG8yMlxuICB9XG5cbiAgLy8gaWYgZGlycyBhcmUgcmVhZGFibGUsIHRoZW4gdGhleSBzaG91bGQgYmUgbGlzdGFibGVcbiAgaWYgKGlzRGlyKSB7XG4gICAgaWYgKG1vZGUgJiAwbzQwMCkge1xuICAgICAgbW9kZSB8PSAwbzEwMFxuICAgIH1cbiAgICBpZiAobW9kZSAmIDBvNDApIHtcbiAgICAgIG1vZGUgfD0gMG8xMFxuICAgIH1cbiAgICBpZiAobW9kZSAmIDBvNCkge1xuICAgICAgbW9kZSB8PSAwbzFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1vZGVcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/mode-fix.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/normalize-unicode.js":
/*!***************************************************!*\
  !*** ./node_modules/tar/lib/normalize-unicode.js ***!
  \***************************************************/
/***/ ((module) => {

eval("// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst normalizeCache = Object.create(null)\nconst { hasOwnProperty } = Object.prototype\nmodule.exports = s => {\n  if (!hasOwnProperty.call(normalizeCache, s)) {\n    normalizeCache[s] = s.normalize('NFD')\n  }\n  return normalizeCache[s]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9ub3JtYWxpemUtdW5pY29kZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpQkFBaUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL25vcm1hbGl6ZS11bmljb2RlLmpzP2NjZTgiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gd2FybmluZzogZXh0cmVtZWx5IGhvdCBjb2RlIHBhdGguXG4vLyBUaGlzIGhhcyBiZWVuIG1ldGljdWxvdXNseSBvcHRpbWl6ZWQgZm9yIHVzZVxuLy8gd2l0aGluIG5wbSBpbnN0YWxsIG9uIGxhcmdlIHBhY2thZ2UgdHJlZXMuXG4vLyBEbyBub3QgZWRpdCB3aXRob3V0IGNhcmVmdWwgYmVuY2htYXJraW5nLlxuY29uc3Qgbm9ybWFsaXplQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5jb25zdCB7IGhhc093blByb3BlcnR5IH0gPSBPYmplY3QucHJvdG90eXBlXG5tb2R1bGUuZXhwb3J0cyA9IHMgPT4ge1xuICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobm9ybWFsaXplQ2FjaGUsIHMpKSB7XG4gICAgbm9ybWFsaXplQ2FjaGVbc10gPSBzLm5vcm1hbGl6ZSgnTkZEJylcbiAgfVxuICByZXR1cm4gbm9ybWFsaXplQ2FjaGVbc11cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/normalize-unicode.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/normalize-windows-path.js":
/*!********************************************************!*\
  !*** ./node_modules/tar/lib/normalize-windows-path.js ***!
  \********************************************************/
/***/ ((module) => {

eval("// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\n\nconst platform = {}.TESTING_TAR_FAKE_PLATFORM || process.platform\nmodule.exports = platform !== 'win32' ? p => p\n  : p => p && p.replace(/\\\\/g, '/')\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlCQUFpQixFQUFXO0FBQzVCO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcz9iNGZhIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIG9uIHdpbmRvd3MsIGVpdGhlciBcXCBvciAvIGFyZSB2YWxpZCBkaXJlY3Rvcnkgc2VwYXJhdG9ycy5cbi8vIG9uIHVuaXgsIFxcIGlzIGEgdmFsaWQgY2hhcmFjdGVyIGluIGZpbGVuYW1lcy5cbi8vIHNvLCBvbiB3aW5kb3dzLCBhbmQgb25seSBvbiB3aW5kb3dzLCB3ZSByZXBsYWNlIGFsbCBcXCBjaGFycyB3aXRoIC8sXG4vLyBzbyB0aGF0IHdlIGNhbiB1c2UgLyBhcyBvdXIgb25lIGFuZCBvbmx5IGRpcmVjdG9yeSBzZXBhcmF0b3IgY2hhci5cblxuY29uc3QgcGxhdGZvcm0gPSBwcm9jZXNzLmVudi5URVNUSU5HX1RBUl9GQUtFX1BMQVRGT1JNIHx8IHByb2Nlc3MucGxhdGZvcm1cbm1vZHVsZS5leHBvcnRzID0gcGxhdGZvcm0gIT09ICd3aW4zMicgPyBwID0+IHBcbiAgOiBwID0+IHAgJiYgcC5yZXBsYWNlKC9cXFxcL2csICcvJylcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/normalize-windows-path.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/pack.js":
/*!**************************************!*\
  !*** ./node_modules/tar/lib/pack.js ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\n\nclass PackJob {\n  constructor (path, absolute) {\n    this.path = path || './'\n    this.absolute = absolute\n    this.entry = null\n    this.stat = null\n    this.readdir = null\n    this.pending = false\n    this.ignore = false\n    this.piped = false\n  }\n}\n\nconst { Minipass } = __webpack_require__(/*! minipass */ \"./node_modules/tar/node_modules/minipass/index.js\")\nconst zlib = __webpack_require__(/*! minizlib */ \"./node_modules/minizlib/index.js\")\nconst ReadEntry = __webpack_require__(/*! ./read-entry.js */ \"./node_modules/tar/lib/read-entry.js\")\nconst WriteEntry = __webpack_require__(/*! ./write-entry.js */ \"./node_modules/tar/lib/write-entry.js\")\nconst WriteEntrySync = WriteEntry.Sync\nconst WriteEntryTar = WriteEntry.Tar\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/yallist/yallist.js\")\nconst EOF = Buffer.alloc(1024)\nconst ONSTAT = Symbol('onStat')\nconst ENDED = Symbol('ended')\nconst QUEUE = Symbol('queue')\nconst CURRENT = Symbol('current')\nconst PROCESS = Symbol('process')\nconst PROCESSING = Symbol('processing')\nconst PROCESSJOB = Symbol('processJob')\nconst JOBS = Symbol('jobs')\nconst JOBDONE = Symbol('jobDone')\nconst ADDFSENTRY = Symbol('addFSEntry')\nconst ADDTARENTRY = Symbol('addTarEntry')\nconst STAT = Symbol('stat')\nconst READDIR = Symbol('readdir')\nconst ONREADDIR = Symbol('onreaddir')\nconst PIPE = Symbol('pipe')\nconst ENTRY = Symbol('entry')\nconst ENTRYOPT = Symbol('entryOpt')\nconst WRITEENTRYCLASS = Symbol('writeEntryClass')\nconst WRITE = Symbol('write')\nconst ONDRAIN = Symbol('ondrain')\n\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"./node_modules/tar/lib/warn-mixin.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/lib/normalize-windows-path.js\")\n\nconst Pack = warner(class Pack extends Minipass {\n  constructor (opt) {\n    super(opt)\n    opt = opt || Object.create(null)\n    this.opt = opt\n    this.file = opt.file || ''\n    this.cwd = opt.cwd || process.cwd()\n    this.maxReadSize = opt.maxReadSize\n    this.preservePaths = !!opt.preservePaths\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.prefix = normPath(opt.prefix || '')\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.readdirCache = opt.readdirCache || new Map()\n\n    this[WRITEENTRYCLASS] = WriteEntry\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    this.portable = !!opt.portable\n    this.zip = null\n\n    if (opt.gzip || opt.brotli) {\n      if (opt.gzip && opt.brotli) {\n        throw new TypeError('gzip and brotli are mutually exclusive')\n      }\n      if (opt.gzip) {\n        if (typeof opt.gzip !== 'object') {\n          opt.gzip = {}\n        }\n        if (this.portable) {\n          opt.gzip.portable = true\n        }\n        this.zip = new zlib.Gzip(opt.gzip)\n      }\n      if (opt.brotli) {\n        if (typeof opt.brotli !== 'object') {\n          opt.brotli = {}\n        }\n        this.zip = new zlib.BrotliCompress(opt.brotli)\n      }\n      this.zip.on('data', chunk => super.write(chunk))\n      this.zip.on('end', _ => super.end())\n      this.zip.on('drain', _ => this[ONDRAIN]())\n      this.on('resume', _ => this.zip.resume())\n    } else {\n      this.on('drain', this[ONDRAIN])\n    }\n\n    this.noDirRecurse = !!opt.noDirRecurse\n    this.follow = !!opt.follow\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n\n    this.filter = typeof opt.filter === 'function' ? opt.filter : _ => true\n\n    this[QUEUE] = new Yallist()\n    this[JOBS] = 0\n    this.jobs = +opt.jobs || 4\n    this[PROCESSING] = false\n    this[ENDED] = false\n  }\n\n  [WRITE] (chunk) {\n    return super.write(chunk)\n  }\n\n  add (path) {\n    this.write(path)\n    return this\n  }\n\n  end (path) {\n    if (path) {\n      this.write(path)\n    }\n    this[ENDED] = true\n    this[PROCESS]()\n    return this\n  }\n\n  write (path) {\n    if (this[ENDED]) {\n      throw new Error('write after end')\n    }\n\n    if (path instanceof ReadEntry) {\n      this[ADDTARENTRY](path)\n    } else {\n      this[ADDFSENTRY](path)\n    }\n    return this.flowing\n  }\n\n  [ADDTARENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p.path))\n    // in this case, we don't have to wait for the stat\n    if (!this.filter(p.path, p)) {\n      p.resume()\n    } else {\n      const job = new PackJob(p.path, absolute, false)\n      job.entry = new WriteEntryTar(p, this[ENTRYOPT](job))\n      job.entry.on('end', _ => this[JOBDONE](job))\n      this[JOBS] += 1\n      this[QUEUE].push(job)\n    }\n\n    this[PROCESS]()\n  }\n\n  [ADDFSENTRY] (p) {\n    const absolute = normPath(path.resolve(this.cwd, p))\n    this[QUEUE].push(new PackJob(p, absolute))\n    this[PROCESS]()\n  }\n\n  [STAT] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    const stat = this.follow ? 'stat' : 'lstat'\n    fs[stat](job.absolute, (er, stat) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        this.emit('error', er)\n      } else {\n        this[ONSTAT](job, stat)\n      }\n    })\n  }\n\n  [ONSTAT] (job, stat) {\n    this.statCache.set(job.absolute, stat)\n    job.stat = stat\n\n    // now we have the stat, we can filter it.\n    if (!this.filter(job.path, stat)) {\n      job.ignore = true\n    }\n\n    this[PROCESS]()\n  }\n\n  [READDIR] (job) {\n    job.pending = true\n    this[JOBS] += 1\n    fs.readdir(job.absolute, (er, entries) => {\n      job.pending = false\n      this[JOBS] -= 1\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADDIR](job, entries)\n    })\n  }\n\n  [ONREADDIR] (job, entries) {\n    this.readdirCache.set(job.absolute, entries)\n    job.readdir = entries\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    if (this[PROCESSING]) {\n      return\n    }\n\n    this[PROCESSING] = true\n    for (let w = this[QUEUE].head;\n      w !== null && this[JOBS] < this.jobs;\n      w = w.next) {\n      this[PROCESSJOB](w.value)\n      if (w.value.ignore) {\n        const p = w.next\n        this[QUEUE].removeNode(w)\n        w.next = p\n      }\n    }\n\n    this[PROCESSING] = false\n\n    if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n      if (this.zip) {\n        this.zip.end(EOF)\n      } else {\n        super.write(EOF)\n        super.end()\n      }\n    }\n  }\n\n  get [CURRENT] () {\n    return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value\n  }\n\n  [JOBDONE] (job) {\n    this[QUEUE].shift()\n    this[JOBS] -= 1\n    this[PROCESS]()\n  }\n\n  [PROCESSJOB] (job) {\n    if (job.pending) {\n      return\n    }\n\n    if (job.entry) {\n      if (job === this[CURRENT] && !job.piped) {\n        this[PIPE](job)\n      }\n      return\n    }\n\n    if (!job.stat) {\n      if (this.statCache.has(job.absolute)) {\n        this[ONSTAT](job, this.statCache.get(job.absolute))\n      } else {\n        this[STAT](job)\n      }\n    }\n    if (!job.stat) {\n      return\n    }\n\n    // filtered out!\n    if (job.ignore) {\n      return\n    }\n\n    if (!this.noDirRecurse && job.stat.isDirectory() && !job.readdir) {\n      if (this.readdirCache.has(job.absolute)) {\n        this[ONREADDIR](job, this.readdirCache.get(job.absolute))\n      } else {\n        this[READDIR](job)\n      }\n      if (!job.readdir) {\n        return\n      }\n    }\n\n    // we know it doesn't have an entry, because that got checked above\n    job.entry = this[ENTRY](job)\n    if (!job.entry) {\n      job.ignore = true\n      return\n    }\n\n    if (job === this[CURRENT] && !job.piped) {\n      this[PIPE](job)\n    }\n  }\n\n  [ENTRYOPT] (job) {\n    return {\n      onwarn: (code, msg, data) => this.warn(code, msg, data),\n      noPax: this.noPax,\n      cwd: this.cwd,\n      absolute: job.absolute,\n      preservePaths: this.preservePaths,\n      maxReadSize: this.maxReadSize,\n      strict: this.strict,\n      portable: this.portable,\n      linkCache: this.linkCache,\n      statCache: this.statCache,\n      noMtime: this.noMtime,\n      mtime: this.mtime,\n      prefix: this.prefix,\n    }\n  }\n\n  [ENTRY] (job) {\n    this[JOBS] += 1\n    try {\n      return new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job))\n        .on('end', () => this[JOBDONE](job))\n        .on('error', er => this.emit('error', er))\n    } catch (er) {\n      this.emit('error', er)\n    }\n  }\n\n  [ONDRAIN] () {\n    if (this[CURRENT] && this[CURRENT].entry) {\n      this[CURRENT].entry.resume()\n    }\n  }\n\n  // like .pipe() but using super, because our write() is special\n  [PIPE] (job) {\n    job.piped = true\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    const source = job.entry\n    const zip = this.zip\n\n    if (zip) {\n      source.on('data', chunk => {\n        if (!zip.write(chunk)) {\n          source.pause()\n        }\n      })\n    } else {\n      source.on('data', chunk => {\n        if (!super.write(chunk)) {\n          source.pause()\n        }\n      })\n    }\n  }\n\n  pause () {\n    if (this.zip) {\n      this.zip.pause()\n    }\n    return super.pause()\n  }\n})\n\nclass PackSync extends Pack {\n  constructor (opt) {\n    super(opt)\n    this[WRITEENTRYCLASS] = WriteEntrySync\n  }\n\n  // pause/resume are no-ops in sync streams.\n  pause () {}\n  resume () {}\n\n  [STAT] (job) {\n    const stat = this.follow ? 'statSync' : 'lstatSync'\n    this[ONSTAT](job, fs[stat](job.absolute))\n  }\n\n  [READDIR] (job, stat) {\n    this[ONREADDIR](job, fs.readdirSync(job.absolute))\n  }\n\n  // gotta get it all in this tick\n  [PIPE] (job) {\n    const source = job.entry\n    const zip = this.zip\n\n    if (job.readdir) {\n      job.readdir.forEach(entry => {\n        const p = job.path\n        const base = p === './' ? '' : p.replace(/\\/*$/, '/')\n        this[ADDFSENTRY](base + entry)\n      })\n    }\n\n    if (zip) {\n      source.on('data', chunk => {\n        zip.write(chunk)\n      })\n    } else {\n      source.on('data', chunk => {\n        super[WRITE](chunk)\n      })\n    }\n  }\n}\n\nPack.Sync = PackSync\n\nmodule.exports = Pack\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYWNrLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsbUVBQVU7QUFDdkMsYUFBYSxtQkFBTyxDQUFDLGtEQUFVO0FBQy9CLGtCQUFrQixtQkFBTyxDQUFDLDZEQUFpQjtBQUMzQyxtQkFBbUIsbUJBQU8sQ0FBQywrREFBa0I7QUFDN0M7QUFDQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLGtEQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsZUFBZSxtQkFBTyxDQUFDLDZEQUFpQjtBQUN4QyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBNkI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvcGFjay5qcz9mM2U0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBBIHJlYWRhYmxlIHRhciBzdHJlYW0gY3JlYXRvclxuLy8gVGVjaG5pY2FsbHksIHRoaXMgaXMgYSB0cmFuc2Zvcm0gc3RyZWFtIHRoYXQgeW91IHdyaXRlIHBhdGhzIGludG8sXG4vLyBhbmQgdGFyIGZvcm1hdCBjb21lcyBvdXQgb2YuXG4vLyBUaGUgYGFkZCgpYCBtZXRob2QgaXMgbGlrZSBgd3JpdGUoKWAgYnV0IHJldHVybnMgdGhpcyxcbi8vIGFuZCBlbmQoKSByZXR1cm4gYHRoaXNgIGFzIHdlbGwsIHNvIHlvdSBjYW5cbi8vIGRvIGBuZXcgUGFjayhvcHQpLmFkZCgnZmlsZXMnKS5hZGQoJ2RpcicpLmVuZCgpLnBpcGUob3V0cHV0KVxuLy8gWW91IGNvdWxkIGFsc28gZG8gc29tZXRoaW5nIGxpa2U6XG4vLyBzdHJlYW1PZlBhdGhzKCkucGlwZShuZXcgUGFjaygpKS5waXBlKG5ldyBmcy5Xcml0ZVN0cmVhbSgnb3V0LnRhcicpKVxuXG5jbGFzcyBQYWNrSm9iIHtcbiAgY29uc3RydWN0b3IgKHBhdGgsIGFic29sdXRlKSB7XG4gICAgdGhpcy5wYXRoID0gcGF0aCB8fCAnLi8nXG4gICAgdGhpcy5hYnNvbHV0ZSA9IGFic29sdXRlXG4gICAgdGhpcy5lbnRyeSA9IG51bGxcbiAgICB0aGlzLnN0YXQgPSBudWxsXG4gICAgdGhpcy5yZWFkZGlyID0gbnVsbFxuICAgIHRoaXMucGVuZGluZyA9IGZhbHNlXG4gICAgdGhpcy5pZ25vcmUgPSBmYWxzZVxuICAgIHRoaXMucGlwZWQgPSBmYWxzZVxuICB9XG59XG5cbmNvbnN0IHsgTWluaXBhc3MgfSA9IHJlcXVpcmUoJ21pbmlwYXNzJylcbmNvbnN0IHpsaWIgPSByZXF1aXJlKCdtaW5pemxpYicpXG5jb25zdCBSZWFkRW50cnkgPSByZXF1aXJlKCcuL3JlYWQtZW50cnkuanMnKVxuY29uc3QgV3JpdGVFbnRyeSA9IHJlcXVpcmUoJy4vd3JpdGUtZW50cnkuanMnKVxuY29uc3QgV3JpdGVFbnRyeVN5bmMgPSBXcml0ZUVudHJ5LlN5bmNcbmNvbnN0IFdyaXRlRW50cnlUYXIgPSBXcml0ZUVudHJ5LlRhclxuY29uc3QgWWFsbGlzdCA9IHJlcXVpcmUoJ3lhbGxpc3QnKVxuY29uc3QgRU9GID0gQnVmZmVyLmFsbG9jKDEwMjQpXG5jb25zdCBPTlNUQVQgPSBTeW1ib2woJ29uU3RhdCcpXG5jb25zdCBFTkRFRCA9IFN5bWJvbCgnZW5kZWQnKVxuY29uc3QgUVVFVUUgPSBTeW1ib2woJ3F1ZXVlJylcbmNvbnN0IENVUlJFTlQgPSBTeW1ib2woJ2N1cnJlbnQnKVxuY29uc3QgUFJPQ0VTUyA9IFN5bWJvbCgncHJvY2VzcycpXG5jb25zdCBQUk9DRVNTSU5HID0gU3ltYm9sKCdwcm9jZXNzaW5nJylcbmNvbnN0IFBST0NFU1NKT0IgPSBTeW1ib2woJ3Byb2Nlc3NKb2InKVxuY29uc3QgSk9CUyA9IFN5bWJvbCgnam9icycpXG5jb25zdCBKT0JET05FID0gU3ltYm9sKCdqb2JEb25lJylcbmNvbnN0IEFEREZTRU5UUlkgPSBTeW1ib2woJ2FkZEZTRW50cnknKVxuY29uc3QgQUREVEFSRU5UUlkgPSBTeW1ib2woJ2FkZFRhckVudHJ5JylcbmNvbnN0IFNUQVQgPSBTeW1ib2woJ3N0YXQnKVxuY29uc3QgUkVBRERJUiA9IFN5bWJvbCgncmVhZGRpcicpXG5jb25zdCBPTlJFQURESVIgPSBTeW1ib2woJ29ucmVhZGRpcicpXG5jb25zdCBQSVBFID0gU3ltYm9sKCdwaXBlJylcbmNvbnN0IEVOVFJZID0gU3ltYm9sKCdlbnRyeScpXG5jb25zdCBFTlRSWU9QVCA9IFN5bWJvbCgnZW50cnlPcHQnKVxuY29uc3QgV1JJVEVFTlRSWUNMQVNTID0gU3ltYm9sKCd3cml0ZUVudHJ5Q2xhc3MnKVxuY29uc3QgV1JJVEUgPSBTeW1ib2woJ3dyaXRlJylcbmNvbnN0IE9ORFJBSU4gPSBTeW1ib2woJ29uZHJhaW4nKVxuXG5jb25zdCBmcyA9IHJlcXVpcmUoJ2ZzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcbmNvbnN0IHdhcm5lciA9IHJlcXVpcmUoJy4vd2Fybi1taXhpbi5qcycpXG5jb25zdCBub3JtUGF0aCA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcycpXG5cbmNvbnN0IFBhY2sgPSB3YXJuZXIoY2xhc3MgUGFjayBleHRlbmRzIE1pbmlwYXNzIHtcbiAgY29uc3RydWN0b3IgKG9wdCkge1xuICAgIHN1cGVyKG9wdClcbiAgICBvcHQgPSBvcHQgfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgIHRoaXMub3B0ID0gb3B0XG4gICAgdGhpcy5maWxlID0gb3B0LmZpbGUgfHwgJydcbiAgICB0aGlzLmN3ZCA9IG9wdC5jd2QgfHwgcHJvY2Vzcy5jd2QoKVxuICAgIHRoaXMubWF4UmVhZFNpemUgPSBvcHQubWF4UmVhZFNpemVcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm5vUGF4ID0gISFvcHQubm9QYXhcbiAgICB0aGlzLnByZWZpeCA9IG5vcm1QYXRoKG9wdC5wcmVmaXggfHwgJycpXG4gICAgdGhpcy5saW5rQ2FjaGUgPSBvcHQubGlua0NhY2hlIHx8IG5ldyBNYXAoKVxuICAgIHRoaXMuc3RhdENhY2hlID0gb3B0LnN0YXRDYWNoZSB8fCBuZXcgTWFwKClcbiAgICB0aGlzLnJlYWRkaXJDYWNoZSA9IG9wdC5yZWFkZGlyQ2FjaGUgfHwgbmV3IE1hcCgpXG5cbiAgICB0aGlzW1dSSVRFRU5UUllDTEFTU10gPSBXcml0ZUVudHJ5XG4gICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2FybilcbiAgICB9XG5cbiAgICB0aGlzLnBvcnRhYmxlID0gISFvcHQucG9ydGFibGVcbiAgICB0aGlzLnppcCA9IG51bGxcblxuICAgIGlmIChvcHQuZ3ppcCB8fCBvcHQuYnJvdGxpKSB7XG4gICAgICBpZiAob3B0Lmd6aXAgJiYgb3B0LmJyb3RsaSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnemlwIGFuZCBicm90bGkgYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZScpXG4gICAgICB9XG4gICAgICBpZiAob3B0Lmd6aXApIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHQuZ3ppcCAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICBvcHQuZ3ppcCA9IHt9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucG9ydGFibGUpIHtcbiAgICAgICAgICBvcHQuZ3ppcC5wb3J0YWJsZSA9IHRydWVcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnppcCA9IG5ldyB6bGliLkd6aXAob3B0Lmd6aXApXG4gICAgICB9XG4gICAgICBpZiAob3B0LmJyb3RsaSkge1xuICAgICAgICBpZiAodHlwZW9mIG9wdC5icm90bGkgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgb3B0LmJyb3RsaSA9IHt9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy56aXAgPSBuZXcgemxpYi5Ccm90bGlDb21wcmVzcyhvcHQuYnJvdGxpKVxuICAgICAgfVxuICAgICAgdGhpcy56aXAub24oJ2RhdGEnLCBjaHVuayA9PiBzdXBlci53cml0ZShjaHVuaykpXG4gICAgICB0aGlzLnppcC5vbignZW5kJywgXyA9PiBzdXBlci5lbmQoKSlcbiAgICAgIHRoaXMuemlwLm9uKCdkcmFpbicsIF8gPT4gdGhpc1tPTkRSQUlOXSgpKVxuICAgICAgdGhpcy5vbigncmVzdW1lJywgXyA9PiB0aGlzLnppcC5yZXN1bWUoKSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbignZHJhaW4nLCB0aGlzW09ORFJBSU5dKVxuICAgIH1cblxuICAgIHRoaXMubm9EaXJSZWN1cnNlID0gISFvcHQubm9EaXJSZWN1cnNlXG4gICAgdGhpcy5mb2xsb3cgPSAhIW9wdC5mb2xsb3dcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG4gICAgdGhpcy5tdGltZSA9IG9wdC5tdGltZSB8fCBudWxsXG5cbiAgICB0aGlzLmZpbHRlciA9IHR5cGVvZiBvcHQuZmlsdGVyID09PSAnZnVuY3Rpb24nID8gb3B0LmZpbHRlciA6IF8gPT4gdHJ1ZVxuXG4gICAgdGhpc1tRVUVVRV0gPSBuZXcgWWFsbGlzdCgpXG4gICAgdGhpc1tKT0JTXSA9IDBcbiAgICB0aGlzLmpvYnMgPSArb3B0LmpvYnMgfHwgNFxuICAgIHRoaXNbUFJPQ0VTU0lOR10gPSBmYWxzZVxuICAgIHRoaXNbRU5ERURdID0gZmFsc2VcbiAgfVxuXG4gIFtXUklURV0gKGNodW5rKSB7XG4gICAgcmV0dXJuIHN1cGVyLndyaXRlKGNodW5rKVxuICB9XG5cbiAgYWRkIChwYXRoKSB7XG4gICAgdGhpcy53cml0ZShwYXRoKVxuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBlbmQgKHBhdGgpIHtcbiAgICBpZiAocGF0aCkge1xuICAgICAgdGhpcy53cml0ZShwYXRoKVxuICAgIH1cbiAgICB0aGlzW0VOREVEXSA9IHRydWVcbiAgICB0aGlzW1BST0NFU1NdKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgd3JpdGUgKHBhdGgpIHtcbiAgICBpZiAodGhpc1tFTkRFRF0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJylcbiAgICB9XG5cbiAgICBpZiAocGF0aCBpbnN0YW5jZW9mIFJlYWRFbnRyeSkge1xuICAgICAgdGhpc1tBRERUQVJFTlRSWV0ocGF0aClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tBRERGU0VOVFJZXShwYXRoKVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5mbG93aW5nXG4gIH1cblxuICBbQUREVEFSRU5UUlldIChwKSB7XG4gICAgY29uc3QgYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIHAucGF0aCkpXG4gICAgLy8gaW4gdGhpcyBjYXNlLCB3ZSBkb24ndCBoYXZlIHRvIHdhaXQgZm9yIHRoZSBzdGF0XG4gICAgaWYgKCF0aGlzLmZpbHRlcihwLnBhdGgsIHApKSB7XG4gICAgICBwLnJlc3VtZSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGpvYiA9IG5ldyBQYWNrSm9iKHAucGF0aCwgYWJzb2x1dGUsIGZhbHNlKVxuICAgICAgam9iLmVudHJ5ID0gbmV3IFdyaXRlRW50cnlUYXIocCwgdGhpc1tFTlRSWU9QVF0oam9iKSlcbiAgICAgIGpvYi5lbnRyeS5vbignZW5kJywgXyA9PiB0aGlzW0pPQkRPTkVdKGpvYikpXG4gICAgICB0aGlzW0pPQlNdICs9IDFcbiAgICAgIHRoaXNbUVVFVUVdLnB1c2goam9iKVxuICAgIH1cblxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW0FEREZTRU5UUlldIChwKSB7XG4gICAgY29uc3QgYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUodGhpcy5jd2QsIHApKVxuICAgIHRoaXNbUVVFVUVdLnB1c2gobmV3IFBhY2tKb2IocCwgYWJzb2x1dGUpKVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1NUQVRdIChqb2IpIHtcbiAgICBqb2IucGVuZGluZyA9IHRydWVcbiAgICB0aGlzW0pPQlNdICs9IDFcbiAgICBjb25zdCBzdGF0ID0gdGhpcy5mb2xsb3cgPyAnc3RhdCcgOiAnbHN0YXQnXG4gICAgZnNbc3RhdF0oam9iLmFic29sdXRlLCAoZXIsIHN0YXQpID0+IHtcbiAgICAgIGpvYi5wZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXNbSk9CU10gLT0gMVxuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbT05TVEFUXShqb2IsIHN0YXQpXG4gICAgICB9XG4gICAgfSlcbiAgfVxuXG4gIFtPTlNUQVRdIChqb2IsIHN0YXQpIHtcbiAgICB0aGlzLnN0YXRDYWNoZS5zZXQoam9iLmFic29sdXRlLCBzdGF0KVxuICAgIGpvYi5zdGF0ID0gc3RhdFxuXG4gICAgLy8gbm93IHdlIGhhdmUgdGhlIHN0YXQsIHdlIGNhbiBmaWx0ZXIgaXQuXG4gICAgaWYgKCF0aGlzLmZpbHRlcihqb2IucGF0aCwgc3RhdCkpIHtcbiAgICAgIGpvYi5pZ25vcmUgPSB0cnVlXG4gICAgfVxuXG4gICAgdGhpc1tQUk9DRVNTXSgpXG4gIH1cblxuICBbUkVBRERJUl0gKGpvYikge1xuICAgIGpvYi5wZW5kaW5nID0gdHJ1ZVxuICAgIHRoaXNbSk9CU10gKz0gMVxuICAgIGZzLnJlYWRkaXIoam9iLmFic29sdXRlLCAoZXIsIGVudHJpZXMpID0+IHtcbiAgICAgIGpvYi5wZW5kaW5nID0gZmFsc2VcbiAgICAgIHRoaXNbSk9CU10gLT0gMVxuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICB9XG4gICAgICB0aGlzW09OUkVBRERJUl0oam9iLCBlbnRyaWVzKVxuICAgIH0pXG4gIH1cblxuICBbT05SRUFERElSXSAoam9iLCBlbnRyaWVzKSB7XG4gICAgdGhpcy5yZWFkZGlyQ2FjaGUuc2V0KGpvYi5hYnNvbHV0ZSwgZW50cmllcylcbiAgICBqb2IucmVhZGRpciA9IGVudHJpZXNcbiAgICB0aGlzW1BST0NFU1NdKClcbiAgfVxuXG4gIFtQUk9DRVNTXSAoKSB7XG4gICAgaWYgKHRoaXNbUFJPQ0VTU0lOR10pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRoaXNbUFJPQ0VTU0lOR10gPSB0cnVlXG4gICAgZm9yIChsZXQgdyA9IHRoaXNbUVVFVUVdLmhlYWQ7XG4gICAgICB3ICE9PSBudWxsICYmIHRoaXNbSk9CU10gPCB0aGlzLmpvYnM7XG4gICAgICB3ID0gdy5uZXh0KSB7XG4gICAgICB0aGlzW1BST0NFU1NKT0JdKHcudmFsdWUpXG4gICAgICBpZiAody52YWx1ZS5pZ25vcmUpIHtcbiAgICAgICAgY29uc3QgcCA9IHcubmV4dFxuICAgICAgICB0aGlzW1FVRVVFXS5yZW1vdmVOb2RlKHcpXG4gICAgICAgIHcubmV4dCA9IHBcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzW1BST0NFU1NJTkddID0gZmFsc2VcblxuICAgIGlmICh0aGlzW0VOREVEXSAmJiAhdGhpc1tRVUVVRV0ubGVuZ3RoICYmIHRoaXNbSk9CU10gPT09IDApIHtcbiAgICAgIGlmICh0aGlzLnppcCkge1xuICAgICAgICB0aGlzLnppcC5lbmQoRU9GKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3VwZXIud3JpdGUoRU9GKVxuICAgICAgICBzdXBlci5lbmQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBbQ1VSUkVOVF0gKCkge1xuICAgIHJldHVybiB0aGlzW1FVRVVFXSAmJiB0aGlzW1FVRVVFXS5oZWFkICYmIHRoaXNbUVVFVUVdLmhlYWQudmFsdWVcbiAgfVxuXG4gIFtKT0JET05FXSAoam9iKSB7XG4gICAgdGhpc1tRVUVVRV0uc2hpZnQoKVxuICAgIHRoaXNbSk9CU10gLT0gMVxuICAgIHRoaXNbUFJPQ0VTU10oKVxuICB9XG5cbiAgW1BST0NFU1NKT0JdIChqb2IpIHtcbiAgICBpZiAoam9iLnBlbmRpbmcpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmIChqb2IuZW50cnkpIHtcbiAgICAgIGlmIChqb2IgPT09IHRoaXNbQ1VSUkVOVF0gJiYgIWpvYi5waXBlZCkge1xuICAgICAgICB0aGlzW1BJUEVdKGpvYilcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICgham9iLnN0YXQpIHtcbiAgICAgIGlmICh0aGlzLnN0YXRDYWNoZS5oYXMoam9iLmFic29sdXRlKSkge1xuICAgICAgICB0aGlzW09OU1RBVF0oam9iLCB0aGlzLnN0YXRDYWNoZS5nZXQoam9iLmFic29sdXRlKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbU1RBVF0oam9iKVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWpvYi5zdGF0KSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBmaWx0ZXJlZCBvdXQhXG4gICAgaWYgKGpvYi5pZ25vcmUpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIGlmICghdGhpcy5ub0RpclJlY3Vyc2UgJiYgam9iLnN0YXQuaXNEaXJlY3RvcnkoKSAmJiAham9iLnJlYWRkaXIpIHtcbiAgICAgIGlmICh0aGlzLnJlYWRkaXJDYWNoZS5oYXMoam9iLmFic29sdXRlKSkge1xuICAgICAgICB0aGlzW09OUkVBRERJUl0oam9iLCB0aGlzLnJlYWRkaXJDYWNoZS5nZXQoam9iLmFic29sdXRlKSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbUkVBRERJUl0oam9iKVxuICAgICAgfVxuICAgICAgaWYgKCFqb2IucmVhZGRpcikge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB3ZSBrbm93IGl0IGRvZXNuJ3QgaGF2ZSBhbiBlbnRyeSwgYmVjYXVzZSB0aGF0IGdvdCBjaGVja2VkIGFib3ZlXG4gICAgam9iLmVudHJ5ID0gdGhpc1tFTlRSWV0oam9iKVxuICAgIGlmICgham9iLmVudHJ5KSB7XG4gICAgICBqb2IuaWdub3JlID0gdHJ1ZVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgaWYgKGpvYiA9PT0gdGhpc1tDVVJSRU5UXSAmJiAham9iLnBpcGVkKSB7XG4gICAgICB0aGlzW1BJUEVdKGpvYilcbiAgICB9XG4gIH1cblxuICBbRU5UUllPUFRdIChqb2IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgb253YXJuOiAoY29kZSwgbXNnLCBkYXRhKSA9PiB0aGlzLndhcm4oY29kZSwgbXNnLCBkYXRhKSxcbiAgICAgIG5vUGF4OiB0aGlzLm5vUGF4LFxuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIGFic29sdXRlOiBqb2IuYWJzb2x1dGUsXG4gICAgICBwcmVzZXJ2ZVBhdGhzOiB0aGlzLnByZXNlcnZlUGF0aHMsXG4gICAgICBtYXhSZWFkU2l6ZTogdGhpcy5tYXhSZWFkU2l6ZSxcbiAgICAgIHN0cmljdDogdGhpcy5zdHJpY3QsXG4gICAgICBwb3J0YWJsZTogdGhpcy5wb3J0YWJsZSxcbiAgICAgIGxpbmtDYWNoZTogdGhpcy5saW5rQ2FjaGUsXG4gICAgICBzdGF0Q2FjaGU6IHRoaXMuc3RhdENhY2hlLFxuICAgICAgbm9NdGltZTogdGhpcy5ub010aW1lLFxuICAgICAgbXRpbWU6IHRoaXMubXRpbWUsXG4gICAgICBwcmVmaXg6IHRoaXMucHJlZml4LFxuICAgIH1cbiAgfVxuXG4gIFtFTlRSWV0gKGpvYikge1xuICAgIHRoaXNbSk9CU10gKz0gMVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbmV3IHRoaXNbV1JJVEVFTlRSWUNMQVNTXShqb2IucGF0aCwgdGhpc1tFTlRSWU9QVF0oam9iKSlcbiAgICAgICAgLm9uKCdlbmQnLCAoKSA9PiB0aGlzW0pPQkRPTkVdKGpvYikpXG4gICAgICAgIC5vbignZXJyb3InLCBlciA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgfVxuICB9XG5cbiAgW09ORFJBSU5dICgpIHtcbiAgICBpZiAodGhpc1tDVVJSRU5UXSAmJiB0aGlzW0NVUlJFTlRdLmVudHJ5KSB7XG4gICAgICB0aGlzW0NVUlJFTlRdLmVudHJ5LnJlc3VtZSgpXG4gICAgfVxuICB9XG5cbiAgLy8gbGlrZSAucGlwZSgpIGJ1dCB1c2luZyBzdXBlciwgYmVjYXVzZSBvdXIgd3JpdGUoKSBpcyBzcGVjaWFsXG4gIFtQSVBFXSAoam9iKSB7XG4gICAgam9iLnBpcGVkID0gdHJ1ZVxuXG4gICAgaWYgKGpvYi5yZWFkZGlyKSB7XG4gICAgICBqb2IucmVhZGRpci5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICAgICAgY29uc3QgcCA9IGpvYi5wYXRoXG4gICAgICAgIGNvbnN0IGJhc2UgPSBwID09PSAnLi8nID8gJycgOiBwLnJlcGxhY2UoL1xcLyokLywgJy8nKVxuICAgICAgICB0aGlzW0FEREZTRU5UUlldKGJhc2UgKyBlbnRyeSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgY29uc3Qgc291cmNlID0gam9iLmVudHJ5XG4gICAgY29uc3QgemlwID0gdGhpcy56aXBcblxuICAgIGlmICh6aXApIHtcbiAgICAgIHNvdXJjZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgaWYgKCF6aXAud3JpdGUoY2h1bmspKSB7XG4gICAgICAgICAgc291cmNlLnBhdXNlKClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICBpZiAoIXN1cGVyLndyaXRlKGNodW5rKSkge1xuICAgICAgICAgIHNvdXJjZS5wYXVzZSgpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9XG5cbiAgcGF1c2UgKCkge1xuICAgIGlmICh0aGlzLnppcCkge1xuICAgICAgdGhpcy56aXAucGF1c2UoKVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIucGF1c2UoKVxuICB9XG59KVxuXG5jbGFzcyBQYWNrU3luYyBleHRlbmRzIFBhY2sge1xuICBjb25zdHJ1Y3RvciAob3B0KSB7XG4gICAgc3VwZXIob3B0KVxuICAgIHRoaXNbV1JJVEVFTlRSWUNMQVNTXSA9IFdyaXRlRW50cnlTeW5jXG4gIH1cblxuICAvLyBwYXVzZS9yZXN1bWUgYXJlIG5vLW9wcyBpbiBzeW5jIHN0cmVhbXMuXG4gIHBhdXNlICgpIHt9XG4gIHJlc3VtZSAoKSB7fVxuXG4gIFtTVEFUXSAoam9iKSB7XG4gICAgY29uc3Qgc3RhdCA9IHRoaXMuZm9sbG93ID8gJ3N0YXRTeW5jJyA6ICdsc3RhdFN5bmMnXG4gICAgdGhpc1tPTlNUQVRdKGpvYiwgZnNbc3RhdF0oam9iLmFic29sdXRlKSlcbiAgfVxuXG4gIFtSRUFERElSXSAoam9iLCBzdGF0KSB7XG4gICAgdGhpc1tPTlJFQURESVJdKGpvYiwgZnMucmVhZGRpclN5bmMoam9iLmFic29sdXRlKSlcbiAgfVxuXG4gIC8vIGdvdHRhIGdldCBpdCBhbGwgaW4gdGhpcyB0aWNrXG4gIFtQSVBFXSAoam9iKSB7XG4gICAgY29uc3Qgc291cmNlID0gam9iLmVudHJ5XG4gICAgY29uc3QgemlwID0gdGhpcy56aXBcblxuICAgIGlmIChqb2IucmVhZGRpcikge1xuICAgICAgam9iLnJlYWRkaXIuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgICAgIGNvbnN0IHAgPSBqb2IucGF0aFxuICAgICAgICBjb25zdCBiYXNlID0gcCA9PT0gJy4vJyA/ICcnIDogcC5yZXBsYWNlKC9cXC8qJC8sICcvJylcbiAgICAgICAgdGhpc1tBRERGU0VOVFJZXShiYXNlICsgZW50cnkpXG4gICAgICB9KVxuICAgIH1cblxuICAgIGlmICh6aXApIHtcbiAgICAgIHNvdXJjZS5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgICAgemlwLndyaXRlKGNodW5rKVxuICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgc291cmNlLm9uKCdkYXRhJywgY2h1bmsgPT4ge1xuICAgICAgICBzdXBlcltXUklURV0oY2h1bmspXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5QYWNrLlN5bmMgPSBQYWNrU3luY1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhY2tcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/pack.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/parse.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/parse.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\n\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"./node_modules/tar/lib/warn-mixin.js\")\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Yallist = __webpack_require__(/*! yallist */ \"./node_modules/yallist/yallist.js\")\nconst maxMetaEntrySize = 1024 * 1024\nconst Entry = __webpack_require__(/*! ./read-entry.js */ \"./node_modules/tar/lib/read-entry.js\")\nconst Pax = __webpack_require__(/*! ./pax.js */ \"./node_modules/tar/lib/pax.js\")\nconst zlib = __webpack_require__(/*! minizlib */ \"./node_modules/minizlib/index.js\")\nconst { nextTick } = __webpack_require__(/*! process */ \"process\")\n\nconst gzipHeader = Buffer.from([0x1f, 0x8b])\nconst STATE = Symbol('state')\nconst WRITEENTRY = Symbol('writeEntry')\nconst READENTRY = Symbol('readEntry')\nconst NEXTENTRY = Symbol('nextEntry')\nconst PROCESSENTRY = Symbol('processEntry')\nconst EX = Symbol('extendedHeader')\nconst GEX = Symbol('globalExtendedHeader')\nconst META = Symbol('meta')\nconst EMITMETA = Symbol('emitMeta')\nconst BUFFER = Symbol('buffer')\nconst QUEUE = Symbol('queue')\nconst ENDED = Symbol('ended')\nconst EMITTEDEND = Symbol('emittedEnd')\nconst EMIT = Symbol('emit')\nconst UNZIP = Symbol('unzip')\nconst CONSUMECHUNK = Symbol('consumeChunk')\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub')\nconst CONSUMEBODY = Symbol('consumeBody')\nconst CONSUMEMETA = Symbol('consumeMeta')\nconst CONSUMEHEADER = Symbol('consumeHeader')\nconst CONSUMING = Symbol('consuming')\nconst BUFFERCONCAT = Symbol('bufferConcat')\nconst MAYBEEND = Symbol('maybeEnd')\nconst WRITING = Symbol('writing')\nconst ABORTED = Symbol('aborted')\nconst DONE = Symbol('onDone')\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry')\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock')\nconst SAW_EOF = Symbol('sawEOF')\nconst CLOSESTREAM = Symbol('closeStream')\n\nconst noop = _ => true\n\nmodule.exports = warner(class Parser extends EE {\n  constructor (opt) {\n    opt = opt || {}\n    super(opt)\n\n    this.file = opt.file || ''\n\n    // set to boolean false when an entry starts.  1024 bytes of \\0\n    // is technically a valid tarball, albeit a boring one.\n    this[SAW_VALID_ENTRY] = null\n\n    // these BADARCHIVE errors can't be detected early. listen on DONE.\n    this.on(DONE, _ => {\n      if (this[STATE] === 'begin' || this[SAW_VALID_ENTRY] === false) {\n        // either less than 1 block of data, or all entries were invalid.\n        // Either way, probably not even a tarball.\n        this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format')\n      }\n    })\n\n    if (opt.ondone) {\n      this.on(DONE, opt.ondone)\n    } else {\n      this.on(DONE, _ => {\n        this.emit('prefinish')\n        this.emit('finish')\n        this.emit('end')\n      })\n    }\n\n    this.strict = !!opt.strict\n    this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize\n    this.filter = typeof opt.filter === 'function' ? opt.filter : noop\n    // Unlike gzip, brotli doesn't have any magic bytes to identify it\n    // Users need to explicitly tell us they're extracting a brotli file\n    // Or we infer from the file extension\n    const isTBR = (opt.file && (\n        opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr')))\n    // if it's a tbr file it MIGHT be brotli, but we don't know until\n    // we look at it and verify it's not a valid tar file.\n    this.brotli = !opt.gzip && opt.brotli !== undefined ? opt.brotli\n      : isTBR ? undefined\n      : false\n\n    // have to set this so that streams are ok piping into it\n    this.writable = true\n    this.readable = false\n\n    this[QUEUE] = new Yallist()\n    this[BUFFER] = null\n    this[READENTRY] = null\n    this[WRITEENTRY] = null\n    this[STATE] = 'begin'\n    this[META] = ''\n    this[EX] = null\n    this[GEX] = null\n    this[ENDED] = false\n    this[UNZIP] = null\n    this[ABORTED] = false\n    this[SAW_NULL_BLOCK] = false\n    this[SAW_EOF] = false\n\n    this.on('end', () => this[CLOSESTREAM]())\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n    if (typeof opt.onentry === 'function') {\n      this.on('entry', opt.onentry)\n    }\n  }\n\n  [CONSUMEHEADER] (chunk, position) {\n    if (this[SAW_VALID_ENTRY] === null) {\n      this[SAW_VALID_ENTRY] = false\n    }\n    let header\n    try {\n      header = new Header(chunk, position, this[EX], this[GEX])\n    } catch (er) {\n      return this.warn('TAR_ENTRY_INVALID', er)\n    }\n\n    if (header.nullBlock) {\n      if (this[SAW_NULL_BLOCK]) {\n        this[SAW_EOF] = true\n        // ending an archive with no entries.  pointless, but legal.\n        if (this[STATE] === 'begin') {\n          this[STATE] = 'header'\n        }\n        this[EMIT]('eof')\n      } else {\n        this[SAW_NULL_BLOCK] = true\n        this[EMIT]('nullBlock')\n      }\n    } else {\n      this[SAW_NULL_BLOCK] = false\n      if (!header.cksumValid) {\n        this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header })\n      } else if (!header.path) {\n        this.warn('TAR_ENTRY_INVALID', 'path is required', { header })\n      } else {\n        const type = header.type\n        if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath required', { header })\n        } else if (!/^(Symbolic)?Link$/.test(type) && header.linkpath) {\n          this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', { header })\n        } else {\n          const entry = this[WRITEENTRY] = new Entry(header, this[EX], this[GEX])\n\n          // we do this for meta & ignored entries as well, because they\n          // are still valid tar, or else we wouldn't know to ignore them\n          if (!this[SAW_VALID_ENTRY]) {\n            if (entry.remain) {\n              // this might be the one!\n              const onend = () => {\n                if (!entry.invalid) {\n                  this[SAW_VALID_ENTRY] = true\n                }\n              }\n              entry.on('end', onend)\n            } else {\n              this[SAW_VALID_ENTRY] = true\n            }\n          }\n\n          if (entry.meta) {\n            if (entry.size > this.maxMetaEntrySize) {\n              entry.ignore = true\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = 'ignore'\n              entry.resume()\n            } else if (entry.size > 0) {\n              this[META] = ''\n              entry.on('data', c => this[META] += c)\n              this[STATE] = 'meta'\n            }\n          } else {\n            this[EX] = null\n            entry.ignore = entry.ignore || !this.filter(entry.path, entry)\n\n            if (entry.ignore) {\n              // probably valid, just not something we care about\n              this[EMIT]('ignoredEntry', entry)\n              this[STATE] = entry.remain ? 'ignore' : 'header'\n              entry.resume()\n            } else {\n              if (entry.remain) {\n                this[STATE] = 'body'\n              } else {\n                this[STATE] = 'header'\n                entry.end()\n              }\n\n              if (!this[READENTRY]) {\n                this[QUEUE].push(entry)\n                this[NEXTENTRY]()\n              } else {\n                this[QUEUE].push(entry)\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  [CLOSESTREAM] () {\n    nextTick(() => this.emit('close'))\n  }\n\n  [PROCESSENTRY] (entry) {\n    let go = true\n\n    if (!entry) {\n      this[READENTRY] = null\n      go = false\n    } else if (Array.isArray(entry)) {\n      this.emit.apply(this, entry)\n    } else {\n      this[READENTRY] = entry\n      this.emit('entry', entry)\n      if (!entry.emittedEnd) {\n        entry.on('end', _ => this[NEXTENTRY]())\n        go = false\n      }\n    }\n\n    return go\n  }\n\n  [NEXTENTRY] () {\n    do {} while (this[PROCESSENTRY](this[QUEUE].shift()))\n\n    if (!this[QUEUE].length) {\n      // At this point, there's nothing in the queue, but we may have an\n      // entry which is being consumed (readEntry).\n      // If we don't, then we definitely can handle more data.\n      // If we do, and either it's flowing, or it has never had any data\n      // written to it, then it needs more.\n      // The only other possibility is that it has returned false from a\n      // write() call, so we wait for the next drain to continue.\n      const re = this[READENTRY]\n      const drainNow = !re || re.flowing || re.size === re.remain\n      if (drainNow) {\n        if (!this[WRITING]) {\n          this.emit('drain')\n        }\n      } else {\n        re.once('drain', _ => this.emit('drain'))\n      }\n    }\n  }\n\n  [CONSUMEBODY] (chunk, position) {\n    // write up to but no  more than writeEntry.blockRemain\n    const entry = this[WRITEENTRY]\n    const br = entry.blockRemain\n    const c = (br >= chunk.length && position === 0) ? chunk\n      : chunk.slice(position, position + br)\n\n    entry.write(c)\n\n    if (!entry.blockRemain) {\n      this[STATE] = 'header'\n      this[WRITEENTRY] = null\n      entry.end()\n    }\n\n    return c.length\n  }\n\n  [CONSUMEMETA] (chunk, position) {\n    const entry = this[WRITEENTRY]\n    const ret = this[CONSUMEBODY](chunk, position)\n\n    // if we finished, then the entry is reset\n    if (!this[WRITEENTRY]) {\n      this[EMITMETA](entry)\n    }\n\n    return ret\n  }\n\n  [EMIT] (ev, data, extra) {\n    if (!this[QUEUE].length && !this[READENTRY]) {\n      this.emit(ev, data, extra)\n    } else {\n      this[QUEUE].push([ev, data, extra])\n    }\n  }\n\n  [EMITMETA] (entry) {\n    this[EMIT]('meta', this[META])\n    switch (entry.type) {\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this[EX] = Pax.parse(this[META], this[EX], false)\n        break\n\n      case 'GlobalExtendedHeader':\n        this[GEX] = Pax.parse(this[META], this[GEX], true)\n        break\n\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].path = this[META].replace(/\\0.*/, '')\n        break\n\n      case 'NextFileHasLongLinkpath':\n        this[EX] = this[EX] || Object.create(null)\n        this[EX].linkpath = this[META].replace(/\\0.*/, '')\n        break\n\n      /* istanbul ignore next */\n      default: throw new Error('unknown meta: ' + entry.type)\n    }\n  }\n\n  abort (error) {\n    this[ABORTED] = true\n    this.emit('abort', error)\n    // always throws, even in non-strict mode\n    this.warn('TAR_ABORT', error, { recoverable: false })\n  }\n\n  write (chunk) {\n    if (this[ABORTED]) {\n      return\n    }\n\n    // first write, might be gzipped\n    const needSniff = this[UNZIP] === null ||\n      this.brotli === undefined && this[UNZIP] === false\n    if (needSniff && chunk) {\n      if (this[BUFFER]) {\n        chunk = Buffer.concat([this[BUFFER], chunk])\n        this[BUFFER] = null\n      }\n      if (chunk.length < gzipHeader.length) {\n        this[BUFFER] = chunk\n        return true\n      }\n\n      // look for gzip header\n      for (let i = 0; this[UNZIP] === null && i < gzipHeader.length; i++) {\n        if (chunk[i] !== gzipHeader[i]) {\n          this[UNZIP] = false\n        }\n      }\n\n      const maybeBrotli = this.brotli === undefined\n      if (this[UNZIP] === false && maybeBrotli) {\n        // read the first header to see if it's a valid tar file. If so,\n        // we can safely assume that it's not actually brotli, despite the\n        // .tbr or .tar.br file extension.\n        // if we ended before getting a full chunk, yes, def brotli\n        if (chunk.length < 512) {\n          if (this[ENDED]) {\n            this.brotli = true\n          } else {\n            this[BUFFER] = chunk\n            return true\n          }\n        } else {\n          // if it's tar, it's pretty reliably not brotli, chances of\n          // that happening are astronomical.\n          try {\n            new Header(chunk.slice(0, 512))\n            this.brotli = false\n          } catch (_) {\n            this.brotli = true\n          }\n        }\n      }\n\n      if (this[UNZIP] === null || (this[UNZIP] === false && this.brotli)) {\n        const ended = this[ENDED]\n        this[ENDED] = false\n        this[UNZIP] = this[UNZIP] === null\n          ? new zlib.Unzip()\n          : new zlib.BrotliDecompress()\n        this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk))\n        this[UNZIP].on('error', er => this.abort(er))\n        this[UNZIP].on('end', _ => {\n          this[ENDED] = true\n          this[CONSUMECHUNK]()\n        })\n        this[WRITING] = true\n        const ret = this[UNZIP][ended ? 'end' : 'write'](chunk)\n        this[WRITING] = false\n        return ret\n      }\n    }\n\n    this[WRITING] = true\n    if (this[UNZIP]) {\n      this[UNZIP].write(chunk)\n    } else {\n      this[CONSUMECHUNK](chunk)\n    }\n    this[WRITING] = false\n\n    // return false if there's a queue, or if the current entry isn't flowing\n    const ret =\n      this[QUEUE].length ? false :\n      this[READENTRY] ? this[READENTRY].flowing :\n      true\n\n    // if we have no queue, then that means a clogged READENTRY\n    if (!ret && !this[QUEUE].length) {\n      this[READENTRY].once('drain', _ => this.emit('drain'))\n    }\n\n    return ret\n  }\n\n  [BUFFERCONCAT] (c) {\n    if (c && !this[ABORTED]) {\n      this[BUFFER] = this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c\n    }\n  }\n\n  [MAYBEEND] () {\n    if (this[ENDED] &&\n        !this[EMITTEDEND] &&\n        !this[ABORTED] &&\n        !this[CONSUMING]) {\n      this[EMITTEDEND] = true\n      const entry = this[WRITEENTRY]\n      if (entry && entry.blockRemain) {\n        // truncated, likely a damaged file\n        const have = this[BUFFER] ? this[BUFFER].length : 0\n        this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${\n          entry.blockRemain} more bytes, only ${have} available)`, { entry })\n        if (this[BUFFER]) {\n          entry.write(this[BUFFER])\n        }\n        entry.end()\n      }\n      this[EMIT](DONE)\n    }\n  }\n\n  [CONSUMECHUNK] (chunk) {\n    if (this[CONSUMING]) {\n      this[BUFFERCONCAT](chunk)\n    } else if (!chunk && !this[BUFFER]) {\n      this[MAYBEEND]()\n    } else {\n      this[CONSUMING] = true\n      if (this[BUFFER]) {\n        this[BUFFERCONCAT](chunk)\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      } else {\n        this[CONSUMECHUNKSUB](chunk)\n      }\n\n      while (this[BUFFER] &&\n          this[BUFFER].length >= 512 &&\n          !this[ABORTED] &&\n          !this[SAW_EOF]) {\n        const c = this[BUFFER]\n        this[BUFFER] = null\n        this[CONSUMECHUNKSUB](c)\n      }\n      this[CONSUMING] = false\n    }\n\n    if (!this[BUFFER] || this[ENDED]) {\n      this[MAYBEEND]()\n    }\n  }\n\n  [CONSUMECHUNKSUB] (chunk) {\n    // we know that we are in CONSUMING mode, so anything written goes into\n    // the buffer.  Advance the position and put any remainder in the buffer.\n    let position = 0\n    const length = chunk.length\n    while (position + 512 <= length && !this[ABORTED] && !this[SAW_EOF]) {\n      switch (this[STATE]) {\n        case 'begin':\n        case 'header':\n          this[CONSUMEHEADER](chunk, position)\n          position += 512\n          break\n\n        case 'ignore':\n        case 'body':\n          position += this[CONSUMEBODY](chunk, position)\n          break\n\n        case 'meta':\n          position += this[CONSUMEMETA](chunk, position)\n          break\n\n        /* istanbul ignore next */\n        default:\n          throw new Error('invalid state: ' + this[STATE])\n      }\n    }\n\n    if (position < length) {\n      if (this[BUFFER]) {\n        this[BUFFER] = Buffer.concat([chunk.slice(position), this[BUFFER]])\n      } else {\n        this[BUFFER] = chunk.slice(position)\n      }\n    }\n  }\n\n  end (chunk) {\n    if (!this[ABORTED]) {\n      if (this[UNZIP]) {\n        this[UNZIP].end(chunk)\n      } else {\n        this[ENDED] = true\n        if (this.brotli === undefined) chunk = chunk || Buffer.alloc(0)\n        this.write(chunk)\n      }\n    }\n  }\n})\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYXJzZS5qcz9hNGJlIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyB0aGlzW0JVRkZFUl0gaXMgdGhlIHJlbWFpbmRlciBvZiBhIGNodW5rIGlmIHdlJ3JlIHdhaXRpbmcgZm9yXG4vLyB0aGUgZnVsbCA1MTIgYnl0ZXMgb2YgYSBoZWFkZXIgdG8gY29tZSBpbi4gIFdlIHdpbGwgQnVmZmVyLmNvbmNhdCgpXG4vLyBpdCB0byB0aGUgbmV4dCB3cml0ZSgpLCB3aGljaCBpcyBhIG1lbSBjb3B5LCBidXQgYSBzbWFsbCBvbmUuXG4vL1xuLy8gdGhpc1tRVUVVRV0gaXMgYSBZYWxsaXN0IG9mIGVudHJpZXMgdGhhdCBoYXZlbid0IGJlZW4gZW1pdHRlZFxuLy8geWV0IHRoaXMgY2FuIG9ubHkgZ2V0IGZpbGxlZCB1cCBpZiB0aGUgdXNlciBrZWVwcyB3cml0ZSgpaW5nIGFmdGVyXG4vLyBhIHdyaXRlKCkgcmV0dXJucyBmYWxzZSwgb3IgZG9lcyBhIHdyaXRlKCkgd2l0aCBtb3JlIHRoYW4gb25lIGVudHJ5XG4vL1xuLy8gV2UgZG9uJ3QgYnVmZmVyIGNodW5rcywgd2UgYWx3YXlzIHBhcnNlIHRoZW0gYW5kIGVpdGhlciBjcmVhdGUgYW5cbi8vIGVudHJ5LCBvciBwdXNoIGl0IGludG8gdGhlIGFjdGl2ZSBlbnRyeS4gIFRoZSBSZWFkRW50cnkgY2xhc3Mga25vd3Ncbi8vIHRvIHRocm93IGRhdGEgYXdheSBpZiAuaWdub3JlPXRydWVcbi8vXG4vLyBTaGlmdCBlbnRyeSBvZmYgdGhlIGJ1ZmZlciB3aGVuIGl0IGVtaXRzICdlbmQnLCBhbmQgZW1pdCAnZW50cnknIGZvclxuLy8gdGhlIG5leHQgb25lIGluIHRoZSBsaXN0LlxuLy9cbi8vIEF0IGFueSB0aW1lLCB3ZSdyZSBwdXNoaW5nIGJvZHkgY2h1bmtzIGludG8gdGhlIGVudHJ5IGF0IFdSSVRFRU5UUlksXG4vLyBhbmQgd2FpdGluZyBmb3IgJ2VuZCcgb24gdGhlIGVudHJ5IGF0IFJFQURFTlRSWVxuLy9cbi8vIGlnbm9yZWQgZW50cmllcyBnZXQgLnJlc3VtZSgpIGNhbGxlZCBvbiB0aGVtIHN0cmFpZ2h0IGF3YXlcblxuY29uc3Qgd2FybmVyID0gcmVxdWlyZSgnLi93YXJuLW1peGluLmpzJylcbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyLmpzJylcbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IFlhbGxpc3QgPSByZXF1aXJlKCd5YWxsaXN0JylcbmNvbnN0IG1heE1ldGFFbnRyeVNpemUgPSAxMDI0ICogMTAyNFxuY29uc3QgRW50cnkgPSByZXF1aXJlKCcuL3JlYWQtZW50cnkuanMnKVxuY29uc3QgUGF4ID0gcmVxdWlyZSgnLi9wYXguanMnKVxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ21pbml6bGliJylcbmNvbnN0IHsgbmV4dFRpY2sgfSA9IHJlcXVpcmUoJ3Byb2Nlc3MnKVxuXG5jb25zdCBnemlwSGVhZGVyID0gQnVmZmVyLmZyb20oWzB4MWYsIDB4OGJdKVxuY29uc3QgU1RBVEUgPSBTeW1ib2woJ3N0YXRlJylcbmNvbnN0IFdSSVRFRU5UUlkgPSBTeW1ib2woJ3dyaXRlRW50cnknKVxuY29uc3QgUkVBREVOVFJZID0gU3ltYm9sKCdyZWFkRW50cnknKVxuY29uc3QgTkVYVEVOVFJZID0gU3ltYm9sKCduZXh0RW50cnknKVxuY29uc3QgUFJPQ0VTU0VOVFJZID0gU3ltYm9sKCdwcm9jZXNzRW50cnknKVxuY29uc3QgRVggPSBTeW1ib2woJ2V4dGVuZGVkSGVhZGVyJylcbmNvbnN0IEdFWCA9IFN5bWJvbCgnZ2xvYmFsRXh0ZW5kZWRIZWFkZXInKVxuY29uc3QgTUVUQSA9IFN5bWJvbCgnbWV0YScpXG5jb25zdCBFTUlUTUVUQSA9IFN5bWJvbCgnZW1pdE1ldGEnKVxuY29uc3QgQlVGRkVSID0gU3ltYm9sKCdidWZmZXInKVxuY29uc3QgUVVFVUUgPSBTeW1ib2woJ3F1ZXVlJylcbmNvbnN0IEVOREVEID0gU3ltYm9sKCdlbmRlZCcpXG5jb25zdCBFTUlUVEVERU5EID0gU3ltYm9sKCdlbWl0dGVkRW5kJylcbmNvbnN0IEVNSVQgPSBTeW1ib2woJ2VtaXQnKVxuY29uc3QgVU5aSVAgPSBTeW1ib2woJ3VuemlwJylcbmNvbnN0IENPTlNVTUVDSFVOSyA9IFN5bWJvbCgnY29uc3VtZUNodW5rJylcbmNvbnN0IENPTlNVTUVDSFVOS1NVQiA9IFN5bWJvbCgnY29uc3VtZUNodW5rU3ViJylcbmNvbnN0IENPTlNVTUVCT0RZID0gU3ltYm9sKCdjb25zdW1lQm9keScpXG5jb25zdCBDT05TVU1FTUVUQSA9IFN5bWJvbCgnY29uc3VtZU1ldGEnKVxuY29uc3QgQ09OU1VNRUhFQURFUiA9IFN5bWJvbCgnY29uc3VtZUhlYWRlcicpXG5jb25zdCBDT05TVU1JTkcgPSBTeW1ib2woJ2NvbnN1bWluZycpXG5jb25zdCBCVUZGRVJDT05DQVQgPSBTeW1ib2woJ2J1ZmZlckNvbmNhdCcpXG5jb25zdCBNQVlCRUVORCA9IFN5bWJvbCgnbWF5YmVFbmQnKVxuY29uc3QgV1JJVElORyA9IFN5bWJvbCgnd3JpdGluZycpXG5jb25zdCBBQk9SVEVEID0gU3ltYm9sKCdhYm9ydGVkJylcbmNvbnN0IERPTkUgPSBTeW1ib2woJ29uRG9uZScpXG5jb25zdCBTQVdfVkFMSURfRU5UUlkgPSBTeW1ib2woJ3Nhd1ZhbGlkRW50cnknKVxuY29uc3QgU0FXX05VTExfQkxPQ0sgPSBTeW1ib2woJ3Nhd051bGxCbG9jaycpXG5jb25zdCBTQVdfRU9GID0gU3ltYm9sKCdzYXdFT0YnKVxuY29uc3QgQ0xPU0VTVFJFQU0gPSBTeW1ib2woJ2Nsb3NlU3RyZWFtJylcblxuY29uc3Qgbm9vcCA9IF8gPT4gdHJ1ZVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5lcihjbGFzcyBQYXJzZXIgZXh0ZW5kcyBFRSB7XG4gIGNvbnN0cnVjdG9yIChvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG5cbiAgICB0aGlzLmZpbGUgPSBvcHQuZmlsZSB8fCAnJ1xuXG4gICAgLy8gc2V0IHRvIGJvb2xlYW4gZmFsc2Ugd2hlbiBhbiBlbnRyeSBzdGFydHMuICAxMDI0IGJ5dGVzIG9mIFxcMFxuICAgIC8vIGlzIHRlY2huaWNhbGx5IGEgdmFsaWQgdGFyYmFsbCwgYWxiZWl0IGEgYm9yaW5nIG9uZS5cbiAgICB0aGlzW1NBV19WQUxJRF9FTlRSWV0gPSBudWxsXG5cbiAgICAvLyB0aGVzZSBCQURBUkNISVZFIGVycm9ycyBjYW4ndCBiZSBkZXRlY3RlZCBlYXJseS4gbGlzdGVuIG9uIERPTkUuXG4gICAgdGhpcy5vbihET05FLCBfID0+IHtcbiAgICAgIGlmICh0aGlzW1NUQVRFXSA9PT0gJ2JlZ2luJyB8fCB0aGlzW1NBV19WQUxJRF9FTlRSWV0gPT09IGZhbHNlKSB7XG4gICAgICAgIC8vIGVpdGhlciBsZXNzIHRoYW4gMSBibG9jayBvZiBkYXRhLCBvciBhbGwgZW50cmllcyB3ZXJlIGludmFsaWQuXG4gICAgICAgIC8vIEVpdGhlciB3YXksIHByb2JhYmx5IG5vdCBldmVuIGEgdGFyYmFsbC5cbiAgICAgICAgdGhpcy53YXJuKCdUQVJfQkFEX0FSQ0hJVkUnLCAnVW5yZWNvZ25pemVkIGFyY2hpdmUgZm9ybWF0JylcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgaWYgKG9wdC5vbmRvbmUpIHtcbiAgICAgIHRoaXMub24oRE9ORSwgb3B0Lm9uZG9uZSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbihET05FLCBfID0+IHtcbiAgICAgICAgdGhpcy5lbWl0KCdwcmVmaW5pc2gnKVxuICAgICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICAgIHRoaXMuZW1pdCgnZW5kJylcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm1heE1ldGFFbnRyeVNpemUgPSBvcHQubWF4TWV0YUVudHJ5U2l6ZSB8fCBtYXhNZXRhRW50cnlTaXplXG4gICAgdGhpcy5maWx0ZXIgPSB0eXBlb2Ygb3B0LmZpbHRlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdC5maWx0ZXIgOiBub29wXG4gICAgLy8gVW5saWtlIGd6aXAsIGJyb3RsaSBkb2Vzbid0IGhhdmUgYW55IG1hZ2ljIGJ5dGVzIHRvIGlkZW50aWZ5IGl0XG4gICAgLy8gVXNlcnMgbmVlZCB0byBleHBsaWNpdGx5IHRlbGwgdXMgdGhleSdyZSBleHRyYWN0aW5nIGEgYnJvdGxpIGZpbGVcbiAgICAvLyBPciB3ZSBpbmZlciBmcm9tIHRoZSBmaWxlIGV4dGVuc2lvblxuICAgIGNvbnN0IGlzVEJSID0gKG9wdC5maWxlICYmIChcbiAgICAgICAgb3B0LmZpbGUuZW5kc1dpdGgoJy50YXIuYnInKSB8fCBvcHQuZmlsZS5lbmRzV2l0aCgnLnRicicpKSlcbiAgICAvLyBpZiBpdCdzIGEgdGJyIGZpbGUgaXQgTUlHSFQgYmUgYnJvdGxpLCBidXQgd2UgZG9uJ3Qga25vdyB1bnRpbFxuICAgIC8vIHdlIGxvb2sgYXQgaXQgYW5kIHZlcmlmeSBpdCdzIG5vdCBhIHZhbGlkIHRhciBmaWxlLlxuICAgIHRoaXMuYnJvdGxpID0gIW9wdC5nemlwICYmIG9wdC5icm90bGkgIT09IHVuZGVmaW5lZCA/IG9wdC5icm90bGlcbiAgICAgIDogaXNUQlIgPyB1bmRlZmluZWRcbiAgICAgIDogZmFsc2VcblxuICAgIC8vIGhhdmUgdG8gc2V0IHRoaXMgc28gdGhhdCBzdHJlYW1zIGFyZSBvayBwaXBpbmcgaW50byBpdFxuICAgIHRoaXMud3JpdGFibGUgPSB0cnVlXG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlXG5cbiAgICB0aGlzW1FVRVVFXSA9IG5ldyBZYWxsaXN0KClcbiAgICB0aGlzW0JVRkZFUl0gPSBudWxsXG4gICAgdGhpc1tSRUFERU5UUlldID0gbnVsbFxuICAgIHRoaXNbV1JJVEVFTlRSWV0gPSBudWxsXG4gICAgdGhpc1tTVEFURV0gPSAnYmVnaW4nXG4gICAgdGhpc1tNRVRBXSA9ICcnXG4gICAgdGhpc1tFWF0gPSBudWxsXG4gICAgdGhpc1tHRVhdID0gbnVsbFxuICAgIHRoaXNbRU5ERURdID0gZmFsc2VcbiAgICB0aGlzW1VOWklQXSA9IG51bGxcbiAgICB0aGlzW0FCT1JURURdID0gZmFsc2VcbiAgICB0aGlzW1NBV19OVUxMX0JMT0NLXSA9IGZhbHNlXG4gICAgdGhpc1tTQVdfRU9GXSA9IGZhbHNlXG5cbiAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiB0aGlzW0NMT1NFU1RSRUFNXSgpKVxuXG4gICAgaWYgKHR5cGVvZiBvcHQub253YXJuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzLm9uKCd3YXJuJywgb3B0Lm9ud2FybilcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHQub25lbnRyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vbignZW50cnknLCBvcHQub25lbnRyeSlcbiAgICB9XG4gIH1cblxuICBbQ09OU1VNRUhFQURFUl0gKGNodW5rLCBwb3NpdGlvbikge1xuICAgIGlmICh0aGlzW1NBV19WQUxJRF9FTlRSWV0gPT09IG51bGwpIHtcbiAgICAgIHRoaXNbU0FXX1ZBTElEX0VOVFJZXSA9IGZhbHNlXG4gICAgfVxuICAgIGxldCBoZWFkZXJcbiAgICB0cnkge1xuICAgICAgaGVhZGVyID0gbmV3IEhlYWRlcihjaHVuaywgcG9zaXRpb24sIHRoaXNbRVhdLCB0aGlzW0dFWF0pXG4gICAgfSBjYXRjaCAoZXIpIHtcbiAgICAgIHJldHVybiB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTlZBTElEJywgZXIpXG4gICAgfVxuXG4gICAgaWYgKGhlYWRlci5udWxsQmxvY2spIHtcbiAgICAgIGlmICh0aGlzW1NBV19OVUxMX0JMT0NLXSkge1xuICAgICAgICB0aGlzW1NBV19FT0ZdID0gdHJ1ZVxuICAgICAgICAvLyBlbmRpbmcgYW4gYXJjaGl2ZSB3aXRoIG5vIGVudHJpZXMuICBwb2ludGxlc3MsIGJ1dCBsZWdhbC5cbiAgICAgICAgaWYgKHRoaXNbU1RBVEVdID09PSAnYmVnaW4nKSB7XG4gICAgICAgICAgdGhpc1tTVEFURV0gPSAnaGVhZGVyJ1xuICAgICAgICB9XG4gICAgICAgIHRoaXNbRU1JVF0oJ2VvZicpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW1NBV19OVUxMX0JMT0NLXSA9IHRydWVcbiAgICAgICAgdGhpc1tFTUlUXSgnbnVsbEJsb2NrJylcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tTQVdfTlVMTF9CTE9DS10gPSBmYWxzZVxuICAgICAgaWYgKCFoZWFkZXIuY2tzdW1WYWxpZCkge1xuICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTlZBTElEJywgJ2NoZWNrc3VtIGZhaWx1cmUnLCB7IGhlYWRlciB9KVxuICAgICAgfSBlbHNlIGlmICghaGVhZGVyLnBhdGgpIHtcbiAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfSU5WQUxJRCcsICdwYXRoIGlzIHJlcXVpcmVkJywgeyBoZWFkZXIgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHR5cGUgPSBoZWFkZXIudHlwZVxuICAgICAgICBpZiAoL14oU3ltYm9saWMpP0xpbmskLy50ZXN0KHR5cGUpICYmICFoZWFkZXIubGlua3BhdGgpIHtcbiAgICAgICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTlZBTElEJywgJ2xpbmtwYXRoIHJlcXVpcmVkJywgeyBoZWFkZXIgfSlcbiAgICAgICAgfSBlbHNlIGlmICghL14oU3ltYm9saWMpP0xpbmskLy50ZXN0KHR5cGUpICYmIGhlYWRlci5saW5rcGF0aCkge1xuICAgICAgICAgIHRoaXMud2FybignVEFSX0VOVFJZX0lOVkFMSUQnLCAnbGlua3BhdGggZm9yYmlkZGVuJywgeyBoZWFkZXIgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV0gPSBuZXcgRW50cnkoaGVhZGVyLCB0aGlzW0VYXSwgdGhpc1tHRVhdKVxuXG4gICAgICAgICAgLy8gd2UgZG8gdGhpcyBmb3IgbWV0YSAmIGlnbm9yZWQgZW50cmllcyBhcyB3ZWxsLCBiZWNhdXNlIHRoZXlcbiAgICAgICAgICAvLyBhcmUgc3RpbGwgdmFsaWQgdGFyLCBvciBlbHNlIHdlIHdvdWxkbid0IGtub3cgdG8gaWdub3JlIHRoZW1cbiAgICAgICAgICBpZiAoIXRoaXNbU0FXX1ZBTElEX0VOVFJZXSkge1xuICAgICAgICAgICAgaWYgKGVudHJ5LnJlbWFpbikge1xuICAgICAgICAgICAgICAvLyB0aGlzIG1pZ2h0IGJlIHRoZSBvbmUhXG4gICAgICAgICAgICAgIGNvbnN0IG9uZW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZW50cnkuaW52YWxpZCkge1xuICAgICAgICAgICAgICAgICAgdGhpc1tTQVdfVkFMSURfRU5UUlldID0gdHJ1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbnRyeS5vbignZW5kJywgb25lbmQpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICB0aGlzW1NBV19WQUxJRF9FTlRSWV0gPSB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGVudHJ5Lm1ldGEpIHtcbiAgICAgICAgICAgIGlmIChlbnRyeS5zaXplID4gdGhpcy5tYXhNZXRhRW50cnlTaXplKSB7XG4gICAgICAgICAgICAgIGVudHJ5Lmlnbm9yZSA9IHRydWVcbiAgICAgICAgICAgICAgdGhpc1tFTUlUXSgnaWdub3JlZEVudHJ5JywgZW50cnkpXG4gICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gJ2lnbm9yZSdcbiAgICAgICAgICAgICAgZW50cnkucmVzdW1lKClcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZW50cnkuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgICAgdGhpc1tNRVRBXSA9ICcnXG4gICAgICAgICAgICAgIGVudHJ5Lm9uKCdkYXRhJywgYyA9PiB0aGlzW01FVEFdICs9IGMpXG4gICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gJ21ldGEnXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXNbRVhdID0gbnVsbFxuICAgICAgICAgICAgZW50cnkuaWdub3JlID0gZW50cnkuaWdub3JlIHx8ICF0aGlzLmZpbHRlcihlbnRyeS5wYXRoLCBlbnRyeSlcblxuICAgICAgICAgICAgaWYgKGVudHJ5Lmlnbm9yZSkge1xuICAgICAgICAgICAgICAvLyBwcm9iYWJseSB2YWxpZCwganVzdCBub3Qgc29tZXRoaW5nIHdlIGNhcmUgYWJvdXRcbiAgICAgICAgICAgICAgdGhpc1tFTUlUXSgnaWdub3JlZEVudHJ5JywgZW50cnkpXG4gICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gZW50cnkucmVtYWluID8gJ2lnbm9yZScgOiAnaGVhZGVyJ1xuICAgICAgICAgICAgICBlbnRyeS5yZXN1bWUoKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5LnJlbWFpbikge1xuICAgICAgICAgICAgICAgIHRoaXNbU1RBVEVdID0gJ2JvZHknXG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpc1tTVEFURV0gPSAnaGVhZGVyJ1xuICAgICAgICAgICAgICAgIGVudHJ5LmVuZCgpXG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXRoaXNbUkVBREVOVFJZXSkge1xuICAgICAgICAgICAgICAgIHRoaXNbUVVFVUVdLnB1c2goZW50cnkpXG4gICAgICAgICAgICAgICAgdGhpc1tORVhURU5UUlldKClcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzW1FVRVVFXS5wdXNoKGVudHJ5KVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgW0NMT1NFU1RSRUFNXSAoKSB7XG4gICAgbmV4dFRpY2soKCkgPT4gdGhpcy5lbWl0KCdjbG9zZScpKVxuICB9XG5cbiAgW1BST0NFU1NFTlRSWV0gKGVudHJ5KSB7XG4gICAgbGV0IGdvID0gdHJ1ZVxuXG4gICAgaWYgKCFlbnRyeSkge1xuICAgICAgdGhpc1tSRUFERU5UUlldID0gbnVsbFxuICAgICAgZ28gPSBmYWxzZVxuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShlbnRyeSkpIHtcbiAgICAgIHRoaXMuZW1pdC5hcHBseSh0aGlzLCBlbnRyeSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tSRUFERU5UUlldID0gZW50cnlcbiAgICAgIHRoaXMuZW1pdCgnZW50cnknLCBlbnRyeSlcbiAgICAgIGlmICghZW50cnkuZW1pdHRlZEVuZCkge1xuICAgICAgICBlbnRyeS5vbignZW5kJywgXyA9PiB0aGlzW05FWFRFTlRSWV0oKSlcbiAgICAgICAgZ28gPSBmYWxzZVxuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBnb1xuICB9XG5cbiAgW05FWFRFTlRSWV0gKCkge1xuICAgIGRvIHt9IHdoaWxlICh0aGlzW1BST0NFU1NFTlRSWV0odGhpc1tRVUVVRV0uc2hpZnQoKSkpXG5cbiAgICBpZiAoIXRoaXNbUVVFVUVdLmxlbmd0aCkge1xuICAgICAgLy8gQXQgdGhpcyBwb2ludCwgdGhlcmUncyBub3RoaW5nIGluIHRoZSBxdWV1ZSwgYnV0IHdlIG1heSBoYXZlIGFuXG4gICAgICAvLyBlbnRyeSB3aGljaCBpcyBiZWluZyBjb25zdW1lZCAocmVhZEVudHJ5KS5cbiAgICAgIC8vIElmIHdlIGRvbid0LCB0aGVuIHdlIGRlZmluaXRlbHkgY2FuIGhhbmRsZSBtb3JlIGRhdGEuXG4gICAgICAvLyBJZiB3ZSBkbywgYW5kIGVpdGhlciBpdCdzIGZsb3dpbmcsIG9yIGl0IGhhcyBuZXZlciBoYWQgYW55IGRhdGFcbiAgICAgIC8vIHdyaXR0ZW4gdG8gaXQsIHRoZW4gaXQgbmVlZHMgbW9yZS5cbiAgICAgIC8vIFRoZSBvbmx5IG90aGVyIHBvc3NpYmlsaXR5IGlzIHRoYXQgaXQgaGFzIHJldHVybmVkIGZhbHNlIGZyb20gYVxuICAgICAgLy8gd3JpdGUoKSBjYWxsLCBzbyB3ZSB3YWl0IGZvciB0aGUgbmV4dCBkcmFpbiB0byBjb250aW51ZS5cbiAgICAgIGNvbnN0IHJlID0gdGhpc1tSRUFERU5UUlldXG4gICAgICBjb25zdCBkcmFpbk5vdyA9ICFyZSB8fCByZS5mbG93aW5nIHx8IHJlLnNpemUgPT09IHJlLnJlbWFpblxuICAgICAgaWYgKGRyYWluTm93KSB7XG4gICAgICAgIGlmICghdGhpc1tXUklUSU5HXSkge1xuICAgICAgICAgIHRoaXMuZW1pdCgnZHJhaW4nKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZS5vbmNlKCdkcmFpbicsIF8gPT4gdGhpcy5lbWl0KCdkcmFpbicpKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFtDT05TVU1FQk9EWV0gKGNodW5rLCBwb3NpdGlvbikge1xuICAgIC8vIHdyaXRlIHVwIHRvIGJ1dCBubyAgbW9yZSB0aGFuIHdyaXRlRW50cnkuYmxvY2tSZW1haW5cbiAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV1cbiAgICBjb25zdCBiciA9IGVudHJ5LmJsb2NrUmVtYWluXG4gICAgY29uc3QgYyA9IChiciA+PSBjaHVuay5sZW5ndGggJiYgcG9zaXRpb24gPT09IDApID8gY2h1bmtcbiAgICAgIDogY2h1bmsuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgYnIpXG5cbiAgICBlbnRyeS53cml0ZShjKVxuXG4gICAgaWYgKCFlbnRyeS5ibG9ja1JlbWFpbikge1xuICAgICAgdGhpc1tTVEFURV0gPSAnaGVhZGVyJ1xuICAgICAgdGhpc1tXUklURUVOVFJZXSA9IG51bGxcbiAgICAgIGVudHJ5LmVuZCgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGMubGVuZ3RoXG4gIH1cblxuICBbQ09OU1VNRU1FVEFdIChjaHVuaywgcG9zaXRpb24pIHtcbiAgICBjb25zdCBlbnRyeSA9IHRoaXNbV1JJVEVFTlRSWV1cbiAgICBjb25zdCByZXQgPSB0aGlzW0NPTlNVTUVCT0RZXShjaHVuaywgcG9zaXRpb24pXG5cbiAgICAvLyBpZiB3ZSBmaW5pc2hlZCwgdGhlbiB0aGUgZW50cnkgaXMgcmVzZXRcbiAgICBpZiAoIXRoaXNbV1JJVEVFTlRSWV0pIHtcbiAgICAgIHRoaXNbRU1JVE1FVEFdKGVudHJ5KVxuICAgIH1cblxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlUXSAoZXYsIGRhdGEsIGV4dHJhKSB7XG4gICAgaWYgKCF0aGlzW1FVRVVFXS5sZW5ndGggJiYgIXRoaXNbUkVBREVOVFJZXSkge1xuICAgICAgdGhpcy5lbWl0KGV2LCBkYXRhLCBleHRyYSlcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tRVUVVRV0ucHVzaChbZXYsIGRhdGEsIGV4dHJhXSlcbiAgICB9XG4gIH1cblxuICBbRU1JVE1FVEFdIChlbnRyeSkge1xuICAgIHRoaXNbRU1JVF0oJ21ldGEnLCB0aGlzW01FVEFdKVxuICAgIHN3aXRjaCAoZW50cnkudHlwZSkge1xuICAgICAgY2FzZSAnRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgY2FzZSAnT2xkRXh0ZW5kZWRIZWFkZXInOlxuICAgICAgICB0aGlzW0VYXSA9IFBheC5wYXJzZSh0aGlzW01FVEFdLCB0aGlzW0VYXSwgZmFsc2UpXG4gICAgICAgIGJyZWFrXG5cbiAgICAgIGNhc2UgJ0dsb2JhbEV4dGVuZGVkSGVhZGVyJzpcbiAgICAgICAgdGhpc1tHRVhdID0gUGF4LnBhcnNlKHRoaXNbTUVUQV0sIHRoaXNbR0VYXSwgdHJ1ZSlcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnTmV4dEZpbGVIYXNMb25nUGF0aCc6XG4gICAgICBjYXNlICdPbGRHbnVMb25nUGF0aCc6XG4gICAgICAgIHRoaXNbRVhdID0gdGhpc1tFWF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICB0aGlzW0VYXS5wYXRoID0gdGhpc1tNRVRBXS5yZXBsYWNlKC9cXDAuKi8sICcnKVxuICAgICAgICBicmVha1xuXG4gICAgICBjYXNlICdOZXh0RmlsZUhhc0xvbmdMaW5rcGF0aCc6XG4gICAgICAgIHRoaXNbRVhdID0gdGhpc1tFWF0gfHwgT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgICB0aGlzW0VYXS5saW5rcGF0aCA9IHRoaXNbTUVUQV0ucmVwbGFjZSgvXFwwLiovLCAnJylcbiAgICAgICAgYnJlYWtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgIGRlZmF1bHQ6IHRocm93IG5ldyBFcnJvcigndW5rbm93biBtZXRhOiAnICsgZW50cnkudHlwZSlcbiAgICB9XG4gIH1cblxuICBhYm9ydCAoZXJyb3IpIHtcbiAgICB0aGlzW0FCT1JURURdID0gdHJ1ZVxuICAgIHRoaXMuZW1pdCgnYWJvcnQnLCBlcnJvcilcbiAgICAvLyBhbHdheXMgdGhyb3dzLCBldmVuIGluIG5vbi1zdHJpY3QgbW9kZVxuICAgIHRoaXMud2FybignVEFSX0FCT1JUJywgZXJyb3IsIHsgcmVjb3ZlcmFibGU6IGZhbHNlIH0pXG4gIH1cblxuICB3cml0ZSAoY2h1bmspIHtcbiAgICBpZiAodGhpc1tBQk9SVEVEXSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gZmlyc3Qgd3JpdGUsIG1pZ2h0IGJlIGd6aXBwZWRcbiAgICBjb25zdCBuZWVkU25pZmYgPSB0aGlzW1VOWklQXSA9PT0gbnVsbCB8fFxuICAgICAgdGhpcy5icm90bGkgPT09IHVuZGVmaW5lZCAmJiB0aGlzW1VOWklQXSA9PT0gZmFsc2VcbiAgICBpZiAobmVlZFNuaWZmICYmIGNodW5rKSB7XG4gICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmNvbmNhdChbdGhpc1tCVUZGRVJdLCBjaHVua10pXG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IG51bGxcbiAgICAgIH1cbiAgICAgIGlmIChjaHVuay5sZW5ndGggPCBnemlwSGVhZGVyLmxlbmd0aCkge1xuICAgICAgICB0aGlzW0JVRkZFUl0gPSBjaHVua1xuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgfVxuXG4gICAgICAvLyBsb29rIGZvciBnemlwIGhlYWRlclxuICAgICAgZm9yIChsZXQgaSA9IDA7IHRoaXNbVU5aSVBdID09PSBudWxsICYmIGkgPCBnemlwSGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjaHVua1tpXSAhPT0gZ3ppcEhlYWRlcltpXSkge1xuICAgICAgICAgIHRoaXNbVU5aSVBdID0gZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXliZUJyb3RsaSA9IHRoaXMuYnJvdGxpID09PSB1bmRlZmluZWRcbiAgICAgIGlmICh0aGlzW1VOWklQXSA9PT0gZmFsc2UgJiYgbWF5YmVCcm90bGkpIHtcbiAgICAgICAgLy8gcmVhZCB0aGUgZmlyc3QgaGVhZGVyIHRvIHNlZSBpZiBpdCdzIGEgdmFsaWQgdGFyIGZpbGUuIElmIHNvLFxuICAgICAgICAvLyB3ZSBjYW4gc2FmZWx5IGFzc3VtZSB0aGF0IGl0J3Mgbm90IGFjdHVhbGx5IGJyb3RsaSwgZGVzcGl0ZSB0aGVcbiAgICAgICAgLy8gLnRiciBvciAudGFyLmJyIGZpbGUgZXh0ZW5zaW9uLlxuICAgICAgICAvLyBpZiB3ZSBlbmRlZCBiZWZvcmUgZ2V0dGluZyBhIGZ1bGwgY2h1bmssIHllcywgZGVmIGJyb3RsaVxuICAgICAgICBpZiAoY2h1bmsubGVuZ3RoIDwgNTEyKSB7XG4gICAgICAgICAgaWYgKHRoaXNbRU5ERURdKSB7XG4gICAgICAgICAgICB0aGlzLmJyb3RsaSA9IHRydWVcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpc1tCVUZGRVJdID0gY2h1bmtcbiAgICAgICAgICAgIHJldHVybiB0cnVlXG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIGlmIGl0J3MgdGFyLCBpdCdzIHByZXR0eSByZWxpYWJseSBub3QgYnJvdGxpLCBjaGFuY2VzIG9mXG4gICAgICAgICAgLy8gdGhhdCBoYXBwZW5pbmcgYXJlIGFzdHJvbm9taWNhbC5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbmV3IEhlYWRlcihjaHVuay5zbGljZSgwLCA1MTIpKVxuICAgICAgICAgICAgdGhpcy5icm90bGkgPSBmYWxzZVxuICAgICAgICAgIH0gY2F0Y2ggKF8pIHtcbiAgICAgICAgICAgIHRoaXMuYnJvdGxpID0gdHJ1ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tVTlpJUF0gPT09IG51bGwgfHwgKHRoaXNbVU5aSVBdID09PSBmYWxzZSAmJiB0aGlzLmJyb3RsaSkpIHtcbiAgICAgICAgY29uc3QgZW5kZWQgPSB0aGlzW0VOREVEXVxuICAgICAgICB0aGlzW0VOREVEXSA9IGZhbHNlXG4gICAgICAgIHRoaXNbVU5aSVBdID0gdGhpc1tVTlpJUF0gPT09IG51bGxcbiAgICAgICAgICA/IG5ldyB6bGliLlVuemlwKClcbiAgICAgICAgICA6IG5ldyB6bGliLkJyb3RsaURlY29tcHJlc3MoKVxuICAgICAgICB0aGlzW1VOWklQXS5vbignZGF0YScsIGNodW5rID0+IHRoaXNbQ09OU1VNRUNIVU5LXShjaHVuaykpXG4gICAgICAgIHRoaXNbVU5aSVBdLm9uKCdlcnJvcicsIGVyID0+IHRoaXMuYWJvcnQoZXIpKVxuICAgICAgICB0aGlzW1VOWklQXS5vbignZW5kJywgXyA9PiB7XG4gICAgICAgICAgdGhpc1tFTkRFRF0gPSB0cnVlXG4gICAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktdKClcbiAgICAgICAgfSlcbiAgICAgICAgdGhpc1tXUklUSU5HXSA9IHRydWVcbiAgICAgICAgY29uc3QgcmV0ID0gdGhpc1tVTlpJUF1bZW5kZWQgPyAnZW5kJyA6ICd3cml0ZSddKGNodW5rKVxuICAgICAgICB0aGlzW1dSSVRJTkddID0gZmFsc2VcbiAgICAgICAgcmV0dXJuIHJldFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXNbV1JJVElOR10gPSB0cnVlXG4gICAgaWYgKHRoaXNbVU5aSVBdKSB7XG4gICAgICB0aGlzW1VOWklQXS53cml0ZShjaHVuaylcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpc1tDT05TVU1FQ0hVTktdKGNodW5rKVxuICAgIH1cbiAgICB0aGlzW1dSSVRJTkddID0gZmFsc2VcblxuICAgIC8vIHJldHVybiBmYWxzZSBpZiB0aGVyZSdzIGEgcXVldWUsIG9yIGlmIHRoZSBjdXJyZW50IGVudHJ5IGlzbid0IGZsb3dpbmdcbiAgICBjb25zdCByZXQgPVxuICAgICAgdGhpc1tRVUVVRV0ubGVuZ3RoID8gZmFsc2UgOlxuICAgICAgdGhpc1tSRUFERU5UUlldID8gdGhpc1tSRUFERU5UUlldLmZsb3dpbmcgOlxuICAgICAgdHJ1ZVxuXG4gICAgLy8gaWYgd2UgaGF2ZSBubyBxdWV1ZSwgdGhlbiB0aGF0IG1lYW5zIGEgY2xvZ2dlZCBSRUFERU5UUllcbiAgICBpZiAoIXJldCAmJiAhdGhpc1tRVUVVRV0ubGVuZ3RoKSB7XG4gICAgICB0aGlzW1JFQURFTlRSWV0ub25jZSgnZHJhaW4nLCBfID0+IHRoaXMuZW1pdCgnZHJhaW4nKSlcbiAgICB9XG5cbiAgICByZXR1cm4gcmV0XG4gIH1cblxuICBbQlVGRkVSQ09OQ0FUXSAoYykge1xuICAgIGlmIChjICYmICF0aGlzW0FCT1JURURdKSB7XG4gICAgICB0aGlzW0JVRkZFUl0gPSB0aGlzW0JVRkZFUl0gPyBCdWZmZXIuY29uY2F0KFt0aGlzW0JVRkZFUl0sIGNdKSA6IGNcbiAgICB9XG4gIH1cblxuICBbTUFZQkVFTkRdICgpIHtcbiAgICBpZiAodGhpc1tFTkRFRF0gJiZcbiAgICAgICAgIXRoaXNbRU1JVFRFREVORF0gJiZcbiAgICAgICAgIXRoaXNbQUJPUlRFRF0gJiZcbiAgICAgICAgIXRoaXNbQ09OU1VNSU5HXSkge1xuICAgICAgdGhpc1tFTUlUVEVERU5EXSA9IHRydWVcbiAgICAgIGNvbnN0IGVudHJ5ID0gdGhpc1tXUklURUVOVFJZXVxuICAgICAgaWYgKGVudHJ5ICYmIGVudHJ5LmJsb2NrUmVtYWluKSB7XG4gICAgICAgIC8vIHRydW5jYXRlZCwgbGlrZWx5IGEgZGFtYWdlZCBmaWxlXG4gICAgICAgIGNvbnN0IGhhdmUgPSB0aGlzW0JVRkZFUl0gPyB0aGlzW0JVRkZFUl0ubGVuZ3RoIDogMFxuICAgICAgICB0aGlzLndhcm4oJ1RBUl9CQURfQVJDSElWRScsIGBUcnVuY2F0ZWQgaW5wdXQgKG5lZWRlZCAke1xuICAgICAgICAgIGVudHJ5LmJsb2NrUmVtYWlufSBtb3JlIGJ5dGVzLCBvbmx5ICR7aGF2ZX0gYXZhaWxhYmxlKWAsIHsgZW50cnkgfSlcbiAgICAgICAgaWYgKHRoaXNbQlVGRkVSXSkge1xuICAgICAgICAgIGVudHJ5LndyaXRlKHRoaXNbQlVGRkVSXSlcbiAgICAgICAgfVxuICAgICAgICBlbnRyeS5lbmQoKVxuICAgICAgfVxuICAgICAgdGhpc1tFTUlUXShET05FKVxuICAgIH1cbiAgfVxuXG4gIFtDT05TVU1FQ0hVTktdIChjaHVuaykge1xuICAgIGlmICh0aGlzW0NPTlNVTUlOR10pIHtcbiAgICAgIHRoaXNbQlVGRkVSQ09OQ0FUXShjaHVuaylcbiAgICB9IGVsc2UgaWYgKCFjaHVuayAmJiAhdGhpc1tCVUZGRVJdKSB7XG4gICAgICB0aGlzW01BWUJFRU5EXSgpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbQ09OU1VNSU5HXSA9IHRydWVcbiAgICAgIGlmICh0aGlzW0JVRkZFUl0pIHtcbiAgICAgICAgdGhpc1tCVUZGRVJDT05DQVRdKGNodW5rKVxuICAgICAgICBjb25zdCBjID0gdGhpc1tCVUZGRVJdXG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IG51bGxcbiAgICAgICAgdGhpc1tDT05TVU1FQ0hVTktTVUJdKGMpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW0NPTlNVTUVDSFVOS1NVQl0oY2h1bmspXG4gICAgICB9XG5cbiAgICAgIHdoaWxlICh0aGlzW0JVRkZFUl0gJiZcbiAgICAgICAgICB0aGlzW0JVRkZFUl0ubGVuZ3RoID49IDUxMiAmJlxuICAgICAgICAgICF0aGlzW0FCT1JURURdICYmXG4gICAgICAgICAgIXRoaXNbU0FXX0VPRl0pIHtcbiAgICAgICAgY29uc3QgYyA9IHRoaXNbQlVGRkVSXVxuICAgICAgICB0aGlzW0JVRkZFUl0gPSBudWxsXG4gICAgICAgIHRoaXNbQ09OU1VNRUNIVU5LU1VCXShjKVxuICAgICAgfVxuICAgICAgdGhpc1tDT05TVU1JTkddID0gZmFsc2VcbiAgICB9XG5cbiAgICBpZiAoIXRoaXNbQlVGRkVSXSB8fCB0aGlzW0VOREVEXSkge1xuICAgICAgdGhpc1tNQVlCRUVORF0oKVxuICAgIH1cbiAgfVxuXG4gIFtDT05TVU1FQ0hVTktTVUJdIChjaHVuaykge1xuICAgIC8vIHdlIGtub3cgdGhhdCB3ZSBhcmUgaW4gQ09OU1VNSU5HIG1vZGUsIHNvIGFueXRoaW5nIHdyaXR0ZW4gZ29lcyBpbnRvXG4gICAgLy8gdGhlIGJ1ZmZlci4gIEFkdmFuY2UgdGhlIHBvc2l0aW9uIGFuZCBwdXQgYW55IHJlbWFpbmRlciBpbiB0aGUgYnVmZmVyLlxuICAgIGxldCBwb3NpdGlvbiA9IDBcbiAgICBjb25zdCBsZW5ndGggPSBjaHVuay5sZW5ndGhcbiAgICB3aGlsZSAocG9zaXRpb24gKyA1MTIgPD0gbGVuZ3RoICYmICF0aGlzW0FCT1JURURdICYmICF0aGlzW1NBV19FT0ZdKSB7XG4gICAgICBzd2l0Y2ggKHRoaXNbU1RBVEVdKSB7XG4gICAgICAgIGNhc2UgJ2JlZ2luJzpcbiAgICAgICAgY2FzZSAnaGVhZGVyJzpcbiAgICAgICAgICB0aGlzW0NPTlNVTUVIRUFERVJdKGNodW5rLCBwb3NpdGlvbilcbiAgICAgICAgICBwb3NpdGlvbiArPSA1MTJcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ2lnbm9yZSc6XG4gICAgICAgIGNhc2UgJ2JvZHknOlxuICAgICAgICAgIHBvc2l0aW9uICs9IHRoaXNbQ09OU1VNRUJPRFldKGNodW5rLCBwb3NpdGlvbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIGNhc2UgJ21ldGEnOlxuICAgICAgICAgIHBvc2l0aW9uICs9IHRoaXNbQ09OU1VNRU1FVEFdKGNodW5rLCBwb3NpdGlvbilcbiAgICAgICAgICBicmVha1xuXG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHN0YXRlOiAnICsgdGhpc1tTVEFURV0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgbGVuZ3RoKSB7XG4gICAgICBpZiAodGhpc1tCVUZGRVJdKSB7XG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IEJ1ZmZlci5jb25jYXQoW2NodW5rLnNsaWNlKHBvc2l0aW9uKSwgdGhpc1tCVUZGRVJdXSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbQlVGRkVSXSA9IGNodW5rLnNsaWNlKHBvc2l0aW9uKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGVuZCAoY2h1bmspIHtcbiAgICBpZiAoIXRoaXNbQUJPUlRFRF0pIHtcbiAgICAgIGlmICh0aGlzW1VOWklQXSkge1xuICAgICAgICB0aGlzW1VOWklQXS5lbmQoY2h1bmspXG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzW0VOREVEXSA9IHRydWVcbiAgICAgICAgaWYgKHRoaXMuYnJvdGxpID09PSB1bmRlZmluZWQpIGNodW5rID0gY2h1bmsgfHwgQnVmZmVyLmFsbG9jKDApXG4gICAgICAgIHRoaXMud3JpdGUoY2h1bmspXG4gICAgICB9XG4gICAgfVxuICB9XG59KVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/parse.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/path-reservations.js":
/*!***************************************************!*\
  !*** ./node_modules/tar/lib/path-reservations.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst normalize = __webpack_require__(/*! ./normalize-unicode.js */ \"./node_modules/tar/lib/normalize-unicode.js\")\nconst stripSlashes = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/lib/strip-trailing-slashes.js\")\nconst { join } = __webpack_require__(/*! path */ \"path\")\n\nconst platform = {}.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\n\nmodule.exports = () => {\n  // path => [function or Set]\n  // A Set object means a directory reservation\n  // A fn is a direct reservation on that path\n  const queues = new Map()\n\n  // fn => {paths:[path,...], dirs:[path, ...]}\n  const reservations = new Map()\n\n  // return a set of parent dirs for a given path\n  // '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\n  const getDirs = path => {\n    const dirs = path.split('/').slice(0, -1).reduce((set, path) => {\n      if (set.length) {\n        path = join(set[set.length - 1], path)\n      }\n      set.push(path || '/')\n      return set\n    }, [])\n    return dirs\n  }\n\n  // functions currently running\n  const running = new Set()\n\n  // return the queues for each path the function cares about\n  // fn => {paths, dirs}\n  const getQueues = fn => {\n    const res = reservations.get(fn)\n    /* istanbul ignore if - unpossible */\n    if (!res) {\n      throw new Error('function does not have any path reservations')\n    }\n    return {\n      paths: res.paths.map(path => queues.get(path)),\n      dirs: [...res.dirs].map(path => queues.get(path)),\n    }\n  }\n\n  // check if fn is first in line for all its paths, and is\n  // included in the first set for all its dir queues\n  const check = fn => {\n    const { paths, dirs } = getQueues(fn)\n    return paths.every(q => q[0] === fn) &&\n      dirs.every(q => q[0] instanceof Set && q[0].has(fn))\n  }\n\n  // run the function if it's first in line and not already running\n  const run = fn => {\n    if (running.has(fn) || !check(fn)) {\n      return false\n    }\n    running.add(fn)\n    fn(() => clear(fn))\n    return true\n  }\n\n  const clear = fn => {\n    if (!running.has(fn)) {\n      return false\n    }\n\n    const { paths, dirs } = reservations.get(fn)\n    const next = new Set()\n\n    paths.forEach(path => {\n      const q = queues.get(path)\n      assert.equal(q[0], fn)\n      if (q.length === 1) {\n        queues.delete(path)\n      } else {\n        q.shift()\n        if (typeof q[0] === 'function') {\n          next.add(q[0])\n        } else {\n          q[0].forEach(fn => next.add(fn))\n        }\n      }\n    })\n\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      assert(q[0] instanceof Set)\n      if (q[0].size === 1 && q.length === 1) {\n        queues.delete(dir)\n      } else if (q[0].size === 1) {\n        q.shift()\n\n        // must be a function or else the Set would've been reused\n        next.add(q[0])\n      } else {\n        q[0].delete(fn)\n      }\n    })\n    running.delete(fn)\n\n    next.forEach(fn => run(fn))\n    return true\n  }\n\n  const reserve = (paths, fn) => {\n    // collide on matches across case and unicode normalization\n    // On windows, thanks to the magic of 8.3 shortnames, it is fundamentally\n    // impossible to determine whether two paths refer to the same thing on\n    // disk, without asking the kernel for a shortname.\n    // So, we just pretend that every path matches every other path here,\n    // effectively removing all parallelization on windows.\n    paths = isWindows ? ['win32 parallelization disabled'] : paths.map(p => {\n      // don't need normPath, because we skip this entirely for windows\n      return stripSlashes(join(normalize(p))).toLowerCase()\n    })\n\n    const dirs = new Set(\n      paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b))\n    )\n    reservations.set(fn, { dirs, paths })\n    paths.forEach(path => {\n      const q = queues.get(path)\n      if (!q) {\n        queues.set(path, [fn])\n      } else {\n        q.push(fn)\n      }\n    })\n    dirs.forEach(dir => {\n      const q = queues.get(dir)\n      if (!q) {\n        queues.set(dir, [new Set([fn])])\n      } else if (q[q.length - 1] instanceof Set) {\n        q[q.length - 1].add(fn)\n      } else {\n        q.push(new Set([fn]))\n      }\n    })\n\n    return run(fn)\n  }\n\n  return { check, reserve }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYXRoLXJlc2VydmF0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0Isa0JBQWtCLG1CQUFPLENBQUMsMkVBQXdCO0FBQ2xELHFCQUFxQixtQkFBTyxDQUFDLHFGQUE2QjtBQUMxRCxRQUFRLE9BQU8sRUFBRSxtQkFBTyxDQUFDLGtCQUFNOztBQUUvQixpQkFBaUIsRUFBVztBQUM1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFlBQVk7QUFDWjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxjQUFjO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsYUFBYTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsV0FBVztBQUNYIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL3BhdGgtcmVzZXJ2YXRpb25zLmpzP2JiMTYiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQSBwYXRoIGV4Y2x1c2l2ZSByZXNlcnZhdGlvbiBzeXN0ZW1cbi8vIHJlc2VydmUoW2xpc3QsIG9mLCBwYXRoc10sIGZuKVxuLy8gV2hlbiB0aGUgZm4gaXMgZmlyc3QgaW4gbGluZSBmb3IgYWxsIGl0cyBwYXRocywgaXRcbi8vIGlzIGNhbGxlZCB3aXRoIGEgY2IgdGhhdCBjbGVhcnMgdGhlIHJlc2VydmF0aW9uLlxuLy9cbi8vIFVzZWQgYnkgYXN5bmMgdW5wYWNrIHRvIGF2b2lkIGNsb2JiZXJpbmcgcGF0aHMgaW4gdXNlLFxuLy8gd2hpbGUgc3RpbGwgYWxsb3dpbmcgbWF4aW1hbCBzYWZlIHBhcmFsbGVsaXphdGlvbi5cblxuY29uc3QgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0JylcbmNvbnN0IG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXVuaWNvZGUuanMnKVxuY29uc3Qgc3RyaXBTbGFzaGVzID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcbmNvbnN0IHsgam9pbiB9ID0gcmVxdWlyZSgncGF0aCcpXG5cbmNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuVEVTVElOR19UQVJfRkFLRV9QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5jb25zdCBpc1dpbmRvd3MgPSBwbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuXG5tb2R1bGUuZXhwb3J0cyA9ICgpID0+IHtcbiAgLy8gcGF0aCA9PiBbZnVuY3Rpb24gb3IgU2V0XVxuICAvLyBBIFNldCBvYmplY3QgbWVhbnMgYSBkaXJlY3RvcnkgcmVzZXJ2YXRpb25cbiAgLy8gQSBmbiBpcyBhIGRpcmVjdCByZXNlcnZhdGlvbiBvbiB0aGF0IHBhdGhcbiAgY29uc3QgcXVldWVzID0gbmV3IE1hcCgpXG5cbiAgLy8gZm4gPT4ge3BhdGhzOltwYXRoLC4uLl0sIGRpcnM6W3BhdGgsIC4uLl19XG4gIGNvbnN0IHJlc2VydmF0aW9ucyA9IG5ldyBNYXAoKVxuXG4gIC8vIHJldHVybiBhIHNldCBvZiBwYXJlbnQgZGlycyBmb3IgYSBnaXZlbiBwYXRoXG4gIC8vICcvYS9iL2MvZCcgLT4gWycvJywgJy9hJywgJy9hL2InLCAnL2EvYi9jJywgJy9hL2IvYy9kJ11cbiAgY29uc3QgZ2V0RGlycyA9IHBhdGggPT4ge1xuICAgIGNvbnN0IGRpcnMgPSBwYXRoLnNwbGl0KCcvJykuc2xpY2UoMCwgLTEpLnJlZHVjZSgoc2V0LCBwYXRoKSA9PiB7XG4gICAgICBpZiAoc2V0Lmxlbmd0aCkge1xuICAgICAgICBwYXRoID0gam9pbihzZXRbc2V0Lmxlbmd0aCAtIDFdLCBwYXRoKVxuICAgICAgfVxuICAgICAgc2V0LnB1c2gocGF0aCB8fCAnLycpXG4gICAgICByZXR1cm4gc2V0XG4gICAgfSwgW10pXG4gICAgcmV0dXJuIGRpcnNcbiAgfVxuXG4gIC8vIGZ1bmN0aW9ucyBjdXJyZW50bHkgcnVubmluZ1xuICBjb25zdCBydW5uaW5nID0gbmV3IFNldCgpXG5cbiAgLy8gcmV0dXJuIHRoZSBxdWV1ZXMgZm9yIGVhY2ggcGF0aCB0aGUgZnVuY3Rpb24gY2FyZXMgYWJvdXRcbiAgLy8gZm4gPT4ge3BhdGhzLCBkaXJzfVxuICBjb25zdCBnZXRRdWV1ZXMgPSBmbiA9PiB7XG4gICAgY29uc3QgcmVzID0gcmVzZXJ2YXRpb25zLmdldChmbilcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLSB1bnBvc3NpYmxlICovXG4gICAgaWYgKCFyZXMpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignZnVuY3Rpb24gZG9lcyBub3QgaGF2ZSBhbnkgcGF0aCByZXNlcnZhdGlvbnMnKVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgcGF0aHM6IHJlcy5wYXRocy5tYXAocGF0aCA9PiBxdWV1ZXMuZ2V0KHBhdGgpKSxcbiAgICAgIGRpcnM6IFsuLi5yZXMuZGlyc10ubWFwKHBhdGggPT4gcXVldWVzLmdldChwYXRoKSksXG4gICAgfVxuICB9XG5cbiAgLy8gY2hlY2sgaWYgZm4gaXMgZmlyc3QgaW4gbGluZSBmb3IgYWxsIGl0cyBwYXRocywgYW5kIGlzXG4gIC8vIGluY2x1ZGVkIGluIHRoZSBmaXJzdCBzZXQgZm9yIGFsbCBpdHMgZGlyIHF1ZXVlc1xuICBjb25zdCBjaGVjayA9IGZuID0+IHtcbiAgICBjb25zdCB7IHBhdGhzLCBkaXJzIH0gPSBnZXRRdWV1ZXMoZm4pXG4gICAgcmV0dXJuIHBhdGhzLmV2ZXJ5KHEgPT4gcVswXSA9PT0gZm4pICYmXG4gICAgICBkaXJzLmV2ZXJ5KHEgPT4gcVswXSBpbnN0YW5jZW9mIFNldCAmJiBxWzBdLmhhcyhmbikpXG4gIH1cblxuICAvLyBydW4gdGhlIGZ1bmN0aW9uIGlmIGl0J3MgZmlyc3QgaW4gbGluZSBhbmQgbm90IGFscmVhZHkgcnVubmluZ1xuICBjb25zdCBydW4gPSBmbiA9PiB7XG4gICAgaWYgKHJ1bm5pbmcuaGFzKGZuKSB8fCAhY2hlY2soZm4pKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgcnVubmluZy5hZGQoZm4pXG4gICAgZm4oKCkgPT4gY2xlYXIoZm4pKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCBjbGVhciA9IGZuID0+IHtcbiAgICBpZiAoIXJ1bm5pbmcuaGFzKGZuKSkge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgY29uc3QgeyBwYXRocywgZGlycyB9ID0gcmVzZXJ2YXRpb25zLmdldChmbilcbiAgICBjb25zdCBuZXh0ID0gbmV3IFNldCgpXG5cbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQocGF0aClcbiAgICAgIGFzc2VydC5lcXVhbChxWzBdLCBmbilcbiAgICAgIGlmIChxLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBxdWV1ZXMuZGVsZXRlKHBhdGgpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxLnNoaWZ0KClcbiAgICAgICAgaWYgKHR5cGVvZiBxWzBdID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgbmV4dC5hZGQocVswXSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBxWzBdLmZvckVhY2goZm4gPT4gbmV4dC5hZGQoZm4pKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIGRpcnMuZm9yRWFjaChkaXIgPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQoZGlyKVxuICAgICAgYXNzZXJ0KHFbMF0gaW5zdGFuY2VvZiBTZXQpXG4gICAgICBpZiAocVswXS5zaXplID09PSAxICYmIHEubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHF1ZXVlcy5kZWxldGUoZGlyKVxuICAgICAgfSBlbHNlIGlmIChxWzBdLnNpemUgPT09IDEpIHtcbiAgICAgICAgcS5zaGlmdCgpXG5cbiAgICAgICAgLy8gbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGVsc2UgdGhlIFNldCB3b3VsZCd2ZSBiZWVuIHJldXNlZFxuICAgICAgICBuZXh0LmFkZChxWzBdKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcVswXS5kZWxldGUoZm4pXG4gICAgICB9XG4gICAgfSlcbiAgICBydW5uaW5nLmRlbGV0ZShmbilcblxuICAgIG5leHQuZm9yRWFjaChmbiA9PiBydW4oZm4pKVxuICAgIHJldHVybiB0cnVlXG4gIH1cblxuICBjb25zdCByZXNlcnZlID0gKHBhdGhzLCBmbikgPT4ge1xuICAgIC8vIGNvbGxpZGUgb24gbWF0Y2hlcyBhY3Jvc3MgY2FzZSBhbmQgdW5pY29kZSBub3JtYWxpemF0aW9uXG4gICAgLy8gT24gd2luZG93cywgdGhhbmtzIHRvIHRoZSBtYWdpYyBvZiA4LjMgc2hvcnRuYW1lcywgaXQgaXMgZnVuZGFtZW50YWxseVxuICAgIC8vIGltcG9zc2libGUgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdHdvIHBhdGhzIHJlZmVyIHRvIHRoZSBzYW1lIHRoaW5nIG9uXG4gICAgLy8gZGlzaywgd2l0aG91dCBhc2tpbmcgdGhlIGtlcm5lbCBmb3IgYSBzaG9ydG5hbWUuXG4gICAgLy8gU28sIHdlIGp1c3QgcHJldGVuZCB0aGF0IGV2ZXJ5IHBhdGggbWF0Y2hlcyBldmVyeSBvdGhlciBwYXRoIGhlcmUsXG4gICAgLy8gZWZmZWN0aXZlbHkgcmVtb3ZpbmcgYWxsIHBhcmFsbGVsaXphdGlvbiBvbiB3aW5kb3dzLlxuICAgIHBhdGhzID0gaXNXaW5kb3dzID8gWyd3aW4zMiBwYXJhbGxlbGl6YXRpb24gZGlzYWJsZWQnXSA6IHBhdGhzLm1hcChwID0+IHtcbiAgICAgIC8vIGRvbid0IG5lZWQgbm9ybVBhdGgsIGJlY2F1c2Ugd2Ugc2tpcCB0aGlzIGVudGlyZWx5IGZvciB3aW5kb3dzXG4gICAgICByZXR1cm4gc3RyaXBTbGFzaGVzKGpvaW4obm9ybWFsaXplKHApKSkudG9Mb3dlckNhc2UoKVxuICAgIH0pXG5cbiAgICBjb25zdCBkaXJzID0gbmV3IFNldChcbiAgICAgIHBhdGhzLm1hcChwYXRoID0+IGdldERpcnMocGF0aCkpLnJlZHVjZSgoYSwgYikgPT4gYS5jb25jYXQoYikpXG4gICAgKVxuICAgIHJlc2VydmF0aW9ucy5zZXQoZm4sIHsgZGlycywgcGF0aHMgfSlcbiAgICBwYXRocy5mb3JFYWNoKHBhdGggPT4ge1xuICAgICAgY29uc3QgcSA9IHF1ZXVlcy5nZXQocGF0aClcbiAgICAgIGlmICghcSkge1xuICAgICAgICBxdWV1ZXMuc2V0KHBhdGgsIFtmbl0pXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBxLnB1c2goZm4pXG4gICAgICB9XG4gICAgfSlcbiAgICBkaXJzLmZvckVhY2goZGlyID0+IHtcbiAgICAgIGNvbnN0IHEgPSBxdWV1ZXMuZ2V0KGRpcilcbiAgICAgIGlmICghcSkge1xuICAgICAgICBxdWV1ZXMuc2V0KGRpciwgW25ldyBTZXQoW2ZuXSldKVxuICAgICAgfSBlbHNlIGlmIChxW3EubGVuZ3RoIC0gMV0gaW5zdGFuY2VvZiBTZXQpIHtcbiAgICAgICAgcVtxLmxlbmd0aCAtIDFdLmFkZChmbilcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHEucHVzaChuZXcgU2V0KFtmbl0pKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICByZXR1cm4gcnVuKGZuKVxuICB9XG5cbiAgcmV0dXJuIHsgY2hlY2ssIHJlc2VydmUgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/path-reservations.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/pax.js":
/*!*************************************!*\
  !*** ./node_modules/tar/lib/pax.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\nclass Pax {\n  constructor (obj, global) {\n    this.atime = obj.atime || null\n    this.charset = obj.charset || null\n    this.comment = obj.comment || null\n    this.ctime = obj.ctime || null\n    this.gid = obj.gid || null\n    this.gname = obj.gname || null\n    this.linkpath = obj.linkpath || null\n    this.mtime = obj.mtime || null\n    this.path = obj.path || null\n    this.size = obj.size || null\n    this.uid = obj.uid || null\n    this.uname = obj.uname || null\n    this.dev = obj.dev || null\n    this.ino = obj.ino || null\n    this.nlink = obj.nlink || null\n    this.global = global || false\n  }\n\n  encode () {\n    const body = this.encodeBody()\n    if (body === '') {\n      return null\n    }\n\n    const bodyLen = Buffer.byteLength(body)\n    // round up to 512 bytes\n    // add 512 for header\n    const bufLen = 512 * Math.ceil(1 + bodyLen / 512)\n    const buf = Buffer.allocUnsafe(bufLen)\n\n    // 0-fill the header section, it might not hit every field\n    for (let i = 0; i < 512; i++) {\n      buf[i] = 0\n    }\n\n    new Header({\n      // XXX split the path\n      // then the path should be PaxHeader + basename, but less than 99,\n      // prepend with the dirname\n      path: ('PaxHeader/' + path.basename(this.path)).slice(0, 99),\n      mode: this.mode || 0o644,\n      uid: this.uid || null,\n      gid: this.gid || null,\n      size: bodyLen,\n      mtime: this.mtime || null,\n      type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n      linkpath: '',\n      uname: this.uname || '',\n      gname: this.gname || '',\n      devmaj: 0,\n      devmin: 0,\n      atime: this.atime || null,\n      ctime: this.ctime || null,\n    }).encode(buf)\n\n    buf.write(body, 512, bodyLen, 'utf8')\n\n    // null pad after the body\n    for (let i = bodyLen + 512; i < buf.length; i++) {\n      buf[i] = 0\n    }\n\n    return buf\n  }\n\n  encodeBody () {\n    return (\n      this.encodeField('path') +\n      this.encodeField('ctime') +\n      this.encodeField('atime') +\n      this.encodeField('dev') +\n      this.encodeField('ino') +\n      this.encodeField('nlink') +\n      this.encodeField('charset') +\n      this.encodeField('comment') +\n      this.encodeField('gid') +\n      this.encodeField('gname') +\n      this.encodeField('linkpath') +\n      this.encodeField('mtime') +\n      this.encodeField('size') +\n      this.encodeField('uid') +\n      this.encodeField('uname')\n    )\n  }\n\n  encodeField (field) {\n    if (this[field] === null || this[field] === undefined) {\n      return ''\n    }\n    const v = this[field] instanceof Date ? this[field].getTime() / 1000\n      : this[field]\n    const s = ' ' +\n      (field === 'dev' || field === 'ino' || field === 'nlink'\n        ? 'SCHILY.' : '') +\n      field + '=' + v + '\\n'\n    const byteLen = Buffer.byteLength(s)\n    // the digits includes the length of the digits in ascii base-10\n    // so if it's 9 characters, then adding 1 for the 9 makes it 10\n    // which makes it 11 chars.\n    let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1\n    if (byteLen + digits >= Math.pow(10, digits)) {\n      digits += 1\n    }\n    const len = digits + byteLen\n    return len + s\n  }\n}\n\nPax.parse = (string, ex, g) => new Pax(merge(parseKV(string), ex), g)\n\nconst merge = (a, b) =>\n  b ? Object.keys(a).reduce((s, k) => (s[k] = a[k], s), b) : a\n\nconst parseKV = string =>\n  string\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null))\n\nconst parseKVLine = (set, line) => {\n  const n = parseInt(line, 10)\n\n  // XXX Values with \\n in them will fail this.\n  // Refactor to not be a naive line-by-line parse.\n  if (n !== Buffer.byteLength(line) + 1) {\n    return set\n  }\n\n  line = line.slice((n + ' ').length)\n  const kv = line.split('=')\n  const k = kv.shift().replace(/^SCHILY\\.(dev|ino|nlink)/, '$1')\n  if (!k) {\n    return set\n  }\n\n  const v = kv.join('=')\n  set[k] = /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k)\n    ? new Date(v * 1000)\n    : /^[0-9]+$/.test(v) ? +v\n    : v\n  return set\n}\n\nmodule.exports = Pax\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYXguanMiLCJtYXBwaW5ncyI6IkFBQVk7QUFDWixlQUFlLG1CQUFPLENBQUMscURBQWE7QUFDcEMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvQkFBb0IsU0FBUztBQUM3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUE7QUFDQSxnQ0FBZ0MsZ0JBQWdCO0FBQ2hEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9wYXguanM/NzY1YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyLmpzJylcbmNvbnN0IHBhdGggPSByZXF1aXJlKCdwYXRoJylcblxuY2xhc3MgUGF4IHtcbiAgY29uc3RydWN0b3IgKG9iaiwgZ2xvYmFsKSB7XG4gICAgdGhpcy5hdGltZSA9IG9iai5hdGltZSB8fCBudWxsXG4gICAgdGhpcy5jaGFyc2V0ID0gb2JqLmNoYXJzZXQgfHwgbnVsbFxuICAgIHRoaXMuY29tbWVudCA9IG9iai5jb21tZW50IHx8IG51bGxcbiAgICB0aGlzLmN0aW1lID0gb2JqLmN0aW1lIHx8IG51bGxcbiAgICB0aGlzLmdpZCA9IG9iai5naWQgfHwgbnVsbFxuICAgIHRoaXMuZ25hbWUgPSBvYmouZ25hbWUgfHwgbnVsbFxuICAgIHRoaXMubGlua3BhdGggPSBvYmoubGlua3BhdGggfHwgbnVsbFxuICAgIHRoaXMubXRpbWUgPSBvYmoubXRpbWUgfHwgbnVsbFxuICAgIHRoaXMucGF0aCA9IG9iai5wYXRoIHx8IG51bGxcbiAgICB0aGlzLnNpemUgPSBvYmouc2l6ZSB8fCBudWxsXG4gICAgdGhpcy51aWQgPSBvYmoudWlkIHx8IG51bGxcbiAgICB0aGlzLnVuYW1lID0gb2JqLnVuYW1lIHx8IG51bGxcbiAgICB0aGlzLmRldiA9IG9iai5kZXYgfHwgbnVsbFxuICAgIHRoaXMuaW5vID0gb2JqLmlubyB8fCBudWxsXG4gICAgdGhpcy5ubGluayA9IG9iai5ubGluayB8fCBudWxsXG4gICAgdGhpcy5nbG9iYWwgPSBnbG9iYWwgfHwgZmFsc2VcbiAgfVxuXG4gIGVuY29kZSAoKSB7XG4gICAgY29uc3QgYm9keSA9IHRoaXMuZW5jb2RlQm9keSgpXG4gICAgaWYgKGJvZHkgPT09ICcnKSB7XG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGNvbnN0IGJvZHlMZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aChib2R5KVxuICAgIC8vIHJvdW5kIHVwIHRvIDUxMiBieXRlc1xuICAgIC8vIGFkZCA1MTIgZm9yIGhlYWRlclxuICAgIGNvbnN0IGJ1ZkxlbiA9IDUxMiAqIE1hdGguY2VpbCgxICsgYm9keUxlbiAvIDUxMilcbiAgICBjb25zdCBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoYnVmTGVuKVxuXG4gICAgLy8gMC1maWxsIHRoZSBoZWFkZXIgc2VjdGlvbiwgaXQgbWlnaHQgbm90IGhpdCBldmVyeSBmaWVsZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNTEyOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IDBcbiAgICB9XG5cbiAgICBuZXcgSGVhZGVyKHtcbiAgICAgIC8vIFhYWCBzcGxpdCB0aGUgcGF0aFxuICAgICAgLy8gdGhlbiB0aGUgcGF0aCBzaG91bGQgYmUgUGF4SGVhZGVyICsgYmFzZW5hbWUsIGJ1dCBsZXNzIHRoYW4gOTksXG4gICAgICAvLyBwcmVwZW5kIHdpdGggdGhlIGRpcm5hbWVcbiAgICAgIHBhdGg6ICgnUGF4SGVhZGVyLycgKyBwYXRoLmJhc2VuYW1lKHRoaXMucGF0aCkpLnNsaWNlKDAsIDk5KSxcbiAgICAgIG1vZGU6IHRoaXMubW9kZSB8fCAwbzY0NCxcbiAgICAgIHVpZDogdGhpcy51aWQgfHwgbnVsbCxcbiAgICAgIGdpZDogdGhpcy5naWQgfHwgbnVsbCxcbiAgICAgIHNpemU6IGJvZHlMZW4sXG4gICAgICBtdGltZTogdGhpcy5tdGltZSB8fCBudWxsLFxuICAgICAgdHlwZTogdGhpcy5nbG9iYWwgPyAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInIDogJ0V4dGVuZGVkSGVhZGVyJyxcbiAgICAgIGxpbmtwYXRoOiAnJyxcbiAgICAgIHVuYW1lOiB0aGlzLnVuYW1lIHx8ICcnLFxuICAgICAgZ25hbWU6IHRoaXMuZ25hbWUgfHwgJycsXG4gICAgICBkZXZtYWo6IDAsXG4gICAgICBkZXZtaW46IDAsXG4gICAgICBhdGltZTogdGhpcy5hdGltZSB8fCBudWxsLFxuICAgICAgY3RpbWU6IHRoaXMuY3RpbWUgfHwgbnVsbCxcbiAgICB9KS5lbmNvZGUoYnVmKVxuXG4gICAgYnVmLndyaXRlKGJvZHksIDUxMiwgYm9keUxlbiwgJ3V0ZjgnKVxuXG4gICAgLy8gbnVsbCBwYWQgYWZ0ZXIgdGhlIGJvZHlcbiAgICBmb3IgKGxldCBpID0gYm9keUxlbiArIDUxMjsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgYnVmW2ldID0gMFxuICAgIH1cblxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGVuY29kZUJvZHkgKCkge1xuICAgIHJldHVybiAoXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdwYXRoJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnY3RpbWUnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdhdGltZScpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2RldicpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2lubycpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ25saW5rJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnY2hhcnNldCcpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2NvbW1lbnQnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdnaWQnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdnbmFtZScpICtcbiAgICAgIHRoaXMuZW5jb2RlRmllbGQoJ2xpbmtwYXRoJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgnbXRpbWUnKSArXG4gICAgICB0aGlzLmVuY29kZUZpZWxkKCdzaXplJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgndWlkJykgK1xuICAgICAgdGhpcy5lbmNvZGVGaWVsZCgndW5hbWUnKVxuICAgIClcbiAgfVxuXG4gIGVuY29kZUZpZWxkIChmaWVsZCkge1xuICAgIGlmICh0aGlzW2ZpZWxkXSA9PT0gbnVsbCB8fCB0aGlzW2ZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gJydcbiAgICB9XG4gICAgY29uc3QgdiA9IHRoaXNbZmllbGRdIGluc3RhbmNlb2YgRGF0ZSA/IHRoaXNbZmllbGRdLmdldFRpbWUoKSAvIDEwMDBcbiAgICAgIDogdGhpc1tmaWVsZF1cbiAgICBjb25zdCBzID0gJyAnICtcbiAgICAgIChmaWVsZCA9PT0gJ2RldicgfHwgZmllbGQgPT09ICdpbm8nIHx8IGZpZWxkID09PSAnbmxpbmsnXG4gICAgICAgID8gJ1NDSElMWS4nIDogJycpICtcbiAgICAgIGZpZWxkICsgJz0nICsgdiArICdcXG4nXG4gICAgY29uc3QgYnl0ZUxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHMpXG4gICAgLy8gdGhlIGRpZ2l0cyBpbmNsdWRlcyB0aGUgbGVuZ3RoIG9mIHRoZSBkaWdpdHMgaW4gYXNjaWkgYmFzZS0xMFxuICAgIC8vIHNvIGlmIGl0J3MgOSBjaGFyYWN0ZXJzLCB0aGVuIGFkZGluZyAxIGZvciB0aGUgOSBtYWtlcyBpdCAxMFxuICAgIC8vIHdoaWNoIG1ha2VzIGl0IDExIGNoYXJzLlxuICAgIGxldCBkaWdpdHMgPSBNYXRoLmZsb29yKE1hdGgubG9nKGJ5dGVMZW4pIC8gTWF0aC5sb2coMTApKSArIDFcbiAgICBpZiAoYnl0ZUxlbiArIGRpZ2l0cyA+PSBNYXRoLnBvdygxMCwgZGlnaXRzKSkge1xuICAgICAgZGlnaXRzICs9IDFcbiAgICB9XG4gICAgY29uc3QgbGVuID0gZGlnaXRzICsgYnl0ZUxlblxuICAgIHJldHVybiBsZW4gKyBzXG4gIH1cbn1cblxuUGF4LnBhcnNlID0gKHN0cmluZywgZXgsIGcpID0+IG5ldyBQYXgobWVyZ2UocGFyc2VLVihzdHJpbmcpLCBleCksIGcpXG5cbmNvbnN0IG1lcmdlID0gKGEsIGIpID0+XG4gIGIgPyBPYmplY3Qua2V5cyhhKS5yZWR1Y2UoKHMsIGspID0+IChzW2tdID0gYVtrXSwgcyksIGIpIDogYVxuXG5jb25zdCBwYXJzZUtWID0gc3RyaW5nID0+XG4gIHN0cmluZ1xuICAgIC5yZXBsYWNlKC9cXG4kLywgJycpXG4gICAgLnNwbGl0KCdcXG4nKVxuICAgIC5yZWR1Y2UocGFyc2VLVkxpbmUsIE9iamVjdC5jcmVhdGUobnVsbCkpXG5cbmNvbnN0IHBhcnNlS1ZMaW5lID0gKHNldCwgbGluZSkgPT4ge1xuICBjb25zdCBuID0gcGFyc2VJbnQobGluZSwgMTApXG5cbiAgLy8gWFhYIFZhbHVlcyB3aXRoIFxcbiBpbiB0aGVtIHdpbGwgZmFpbCB0aGlzLlxuICAvLyBSZWZhY3RvciB0byBub3QgYmUgYSBuYWl2ZSBsaW5lLWJ5LWxpbmUgcGFyc2UuXG4gIGlmIChuICE9PSBCdWZmZXIuYnl0ZUxlbmd0aChsaW5lKSArIDEpIHtcbiAgICByZXR1cm4gc2V0XG4gIH1cblxuICBsaW5lID0gbGluZS5zbGljZSgobiArICcgJykubGVuZ3RoKVxuICBjb25zdCBrdiA9IGxpbmUuc3BsaXQoJz0nKVxuICBjb25zdCBrID0ga3Yuc2hpZnQoKS5yZXBsYWNlKC9eU0NISUxZXFwuKGRldnxpbm98bmxpbmspLywgJyQxJylcbiAgaWYgKCFrKSB7XG4gICAgcmV0dXJuIHNldFxuICB9XG5cbiAgY29uc3QgdiA9IGt2LmpvaW4oJz0nKVxuICBzZXRba10gPSAvXihbQS1aXStcXC4pPyhbbWFjXXxiaXJ0aHxjcmVhdGlvbil0aW1lJC8udGVzdChrKVxuICAgID8gbmV3IERhdGUodiAqIDEwMDApXG4gICAgOiAvXlswLTldKyQvLnRlc3QodikgPyArdlxuICAgIDogdlxuICByZXR1cm4gc2V0XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGF4XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/pax.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/read-entry.js":
/*!********************************************!*\
  !*** ./node_modules/tar/lib/read-entry.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Minipass } = __webpack_require__(/*! minipass */ \"./node_modules/tar/node_modules/minipass/index.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/lib/normalize-windows-path.js\")\n\nconst SLURP = Symbol('slurp')\nmodule.exports = class ReadEntry extends Minipass {\n  constructor (header, ex, gex) {\n    super()\n    // read entries always start life paused.  this is to avoid the\n    // situation where Minipass's auto-ending empty streams results\n    // in an entry ending before we're ready for it.\n    this.pause()\n    this.extended = ex\n    this.globalExtended = gex\n    this.header = header\n    this.startBlockSize = 512 * Math.ceil(header.size / 512)\n    this.blockRemain = this.startBlockSize\n    this.remain = header.size\n    this.type = header.type\n    this.meta = false\n    this.ignore = false\n    switch (this.type) {\n      case 'File':\n      case 'OldFile':\n      case 'Link':\n      case 'SymbolicLink':\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'Directory':\n      case 'FIFO':\n      case 'ContiguousFile':\n      case 'GNUDumpDir':\n        break\n\n      case 'NextFileHasLongLinkpath':\n      case 'NextFileHasLongPath':\n      case 'OldGnuLongPath':\n      case 'GlobalExtendedHeader':\n      case 'ExtendedHeader':\n      case 'OldExtendedHeader':\n        this.meta = true\n        break\n\n      // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n      // it may be worth doing the same, but with a warning.\n      default:\n        this.ignore = true\n    }\n\n    this.path = normPath(header.path)\n    this.mode = header.mode\n    if (this.mode) {\n      this.mode = this.mode & 0o7777\n    }\n    this.uid = header.uid\n    this.gid = header.gid\n    this.uname = header.uname\n    this.gname = header.gname\n    this.size = header.size\n    this.mtime = header.mtime\n    this.atime = header.atime\n    this.ctime = header.ctime\n    this.linkpath = normPath(header.linkpath)\n    this.uname = header.uname\n    this.gname = header.gname\n\n    if (ex) {\n      this[SLURP](ex)\n    }\n    if (gex) {\n      this[SLURP](gex, true)\n    }\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n\n    const r = this.remain\n    const br = this.blockRemain\n    this.remain = Math.max(0, r - writeLen)\n    this.blockRemain = Math.max(0, br - writeLen)\n    if (this.ignore) {\n      return true\n    }\n\n    if (r >= writeLen) {\n      return super.write(data)\n    }\n\n    // r < writeLen\n    return super.write(data.slice(0, r))\n  }\n\n  [SLURP] (ex, global) {\n    for (const k in ex) {\n      // we slurp in everything except for the path attribute in\n      // a global extended header, because that's weird.\n      if (ex[k] !== null && ex[k] !== undefined &&\n          !(global && k === 'path')) {\n        this[k] = k === 'path' || k === 'linkpath' ? normPath(ex[k]) : ex[k]\n      }\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9yZWFkLWVudHJ5LmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1osUUFBUSxXQUFXLEVBQUUsbUJBQU8sQ0FBQyxtRUFBVTtBQUN2QyxpQkFBaUIsbUJBQU8sQ0FBQyxxRkFBNkI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL3JlYWQtZW50cnkuanM/MjM4NiJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IHsgTWluaXBhc3MgfSA9IHJlcXVpcmUoJ21pbmlwYXNzJylcbmNvbnN0IG5vcm1QYXRoID0gcmVxdWlyZSgnLi9ub3JtYWxpemUtd2luZG93cy1wYXRoLmpzJylcblxuY29uc3QgU0xVUlAgPSBTeW1ib2woJ3NsdXJwJylcbm1vZHVsZS5leHBvcnRzID0gY2xhc3MgUmVhZEVudHJ5IGV4dGVuZHMgTWluaXBhc3Mge1xuICBjb25zdHJ1Y3RvciAoaGVhZGVyLCBleCwgZ2V4KSB7XG4gICAgc3VwZXIoKVxuICAgIC8vIHJlYWQgZW50cmllcyBhbHdheXMgc3RhcnQgbGlmZSBwYXVzZWQuICB0aGlzIGlzIHRvIGF2b2lkIHRoZVxuICAgIC8vIHNpdHVhdGlvbiB3aGVyZSBNaW5pcGFzcydzIGF1dG8tZW5kaW5nIGVtcHR5IHN0cmVhbXMgcmVzdWx0c1xuICAgIC8vIGluIGFuIGVudHJ5IGVuZGluZyBiZWZvcmUgd2UncmUgcmVhZHkgZm9yIGl0LlxuICAgIHRoaXMucGF1c2UoKVxuICAgIHRoaXMuZXh0ZW5kZWQgPSBleFxuICAgIHRoaXMuZ2xvYmFsRXh0ZW5kZWQgPSBnZXhcbiAgICB0aGlzLmhlYWRlciA9IGhlYWRlclxuICAgIHRoaXMuc3RhcnRCbG9ja1NpemUgPSA1MTIgKiBNYXRoLmNlaWwoaGVhZGVyLnNpemUgLyA1MTIpXG4gICAgdGhpcy5ibG9ja1JlbWFpbiA9IHRoaXMuc3RhcnRCbG9ja1NpemVcbiAgICB0aGlzLnJlbWFpbiA9IGhlYWRlci5zaXplXG4gICAgdGhpcy50eXBlID0gaGVhZGVyLnR5cGVcbiAgICB0aGlzLm1ldGEgPSBmYWxzZVxuICAgIHRoaXMuaWdub3JlID0gZmFsc2VcbiAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgY2FzZSAnRmlsZSc6XG4gICAgICBjYXNlICdPbGRGaWxlJzpcbiAgICAgIGNhc2UgJ0xpbmsnOlxuICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgIGNhc2UgJ0NoYXJhY3RlckRldmljZSc6XG4gICAgICBjYXNlICdCbG9ja0RldmljZSc6XG4gICAgICBjYXNlICdEaXJlY3RvcnknOlxuICAgICAgY2FzZSAnRklGTyc6XG4gICAgICBjYXNlICdDb250aWd1b3VzRmlsZSc6XG4gICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgYnJlYWtcblxuICAgICAgY2FzZSAnTmV4dEZpbGVIYXNMb25nTGlua3BhdGgnOlxuICAgICAgY2FzZSAnTmV4dEZpbGVIYXNMb25nUGF0aCc6XG4gICAgICBjYXNlICdPbGRHbnVMb25nUGF0aCc6XG4gICAgICBjYXNlICdHbG9iYWxFeHRlbmRlZEhlYWRlcic6XG4gICAgICBjYXNlICdFeHRlbmRlZEhlYWRlcic6XG4gICAgICBjYXNlICdPbGRFeHRlbmRlZEhlYWRlcic6XG4gICAgICAgIHRoaXMubWV0YSA9IHRydWVcbiAgICAgICAgYnJlYWtcblxuICAgICAgLy8gTk9URTogZ251dGFyIGFuZCBic2R0YXIgdHJlYXQgdW5yZWNvZ25pemVkIHR5cGVzIGFzICdGaWxlJ1xuICAgICAgLy8gaXQgbWF5IGJlIHdvcnRoIGRvaW5nIHRoZSBzYW1lLCBidXQgd2l0aCBhIHdhcm5pbmcuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aGlzLmlnbm9yZSA9IHRydWVcbiAgICB9XG5cbiAgICB0aGlzLnBhdGggPSBub3JtUGF0aChoZWFkZXIucGF0aClcbiAgICB0aGlzLm1vZGUgPSBoZWFkZXIubW9kZVxuICAgIGlmICh0aGlzLm1vZGUpIHtcbiAgICAgIHRoaXMubW9kZSA9IHRoaXMubW9kZSAmIDBvNzc3N1xuICAgIH1cbiAgICB0aGlzLnVpZCA9IGhlYWRlci51aWRcbiAgICB0aGlzLmdpZCA9IGhlYWRlci5naWRcbiAgICB0aGlzLnVuYW1lID0gaGVhZGVyLnVuYW1lXG4gICAgdGhpcy5nbmFtZSA9IGhlYWRlci5nbmFtZVxuICAgIHRoaXMuc2l6ZSA9IGhlYWRlci5zaXplXG4gICAgdGhpcy5tdGltZSA9IGhlYWRlci5tdGltZVxuICAgIHRoaXMuYXRpbWUgPSBoZWFkZXIuYXRpbWVcbiAgICB0aGlzLmN0aW1lID0gaGVhZGVyLmN0aW1lXG4gICAgdGhpcy5saW5rcGF0aCA9IG5vcm1QYXRoKGhlYWRlci5saW5rcGF0aClcbiAgICB0aGlzLnVuYW1lID0gaGVhZGVyLnVuYW1lXG4gICAgdGhpcy5nbmFtZSA9IGhlYWRlci5nbmFtZVxuXG4gICAgaWYgKGV4KSB7XG4gICAgICB0aGlzW1NMVVJQXShleClcbiAgICB9XG4gICAgaWYgKGdleCkge1xuICAgICAgdGhpc1tTTFVSUF0oZ2V4LCB0cnVlKVxuICAgIH1cbiAgfVxuXG4gIHdyaXRlIChkYXRhKSB7XG4gICAgY29uc3Qgd3JpdGVMZW4gPSBkYXRhLmxlbmd0aFxuICAgIGlmICh3cml0ZUxlbiA+IHRoaXMuYmxvY2tSZW1haW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGluZyBtb3JlIHRvIGVudHJ5IHRoYW4gaXMgYXBwcm9wcmlhdGUnKVxuICAgIH1cblxuICAgIGNvbnN0IHIgPSB0aGlzLnJlbWFpblxuICAgIGNvbnN0IGJyID0gdGhpcy5ibG9ja1JlbWFpblxuICAgIHRoaXMucmVtYWluID0gTWF0aC5tYXgoMCwgciAtIHdyaXRlTGVuKVxuICAgIHRoaXMuYmxvY2tSZW1haW4gPSBNYXRoLm1heCgwLCBiciAtIHdyaXRlTGVuKVxuICAgIGlmICh0aGlzLmlnbm9yZSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG5cbiAgICBpZiAociA+PSB3cml0ZUxlbikge1xuICAgICAgcmV0dXJuIHN1cGVyLndyaXRlKGRhdGEpXG4gICAgfVxuXG4gICAgLy8gciA8IHdyaXRlTGVuXG4gICAgcmV0dXJuIHN1cGVyLndyaXRlKGRhdGEuc2xpY2UoMCwgcikpXG4gIH1cblxuICBbU0xVUlBdIChleCwgZ2xvYmFsKSB7XG4gICAgZm9yIChjb25zdCBrIGluIGV4KSB7XG4gICAgICAvLyB3ZSBzbHVycCBpbiBldmVyeXRoaW5nIGV4Y2VwdCBmb3IgdGhlIHBhdGggYXR0cmlidXRlIGluXG4gICAgICAvLyBhIGdsb2JhbCBleHRlbmRlZCBoZWFkZXIsIGJlY2F1c2UgdGhhdCdzIHdlaXJkLlxuICAgICAgaWYgKGV4W2tdICE9PSBudWxsICYmIGV4W2tdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAhKGdsb2JhbCAmJiBrID09PSAncGF0aCcpKSB7XG4gICAgICAgIHRoaXNba10gPSBrID09PSAncGF0aCcgfHwgayA9PT0gJ2xpbmtwYXRoJyA/IG5vcm1QYXRoKGV4W2tdKSA6IGV4W2tdXG4gICAgICB9XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/read-entry.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/replace.js":
/*!*****************************************!*\
  !*** ./node_modules/tar/lib/replace.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -r\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst Pack = __webpack_require__(/*! ./pack.js */ \"./node_modules/tar/lib/pack.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst t = __webpack_require__(/*! ./list.js */ \"./node_modules/tar/lib/list.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\n\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\n\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  return opt.sync ? replaceSync(opt, files)\n    : replace(opt, files, cb)\n}\n\nconst replaceSync = (opt, files) => {\n  const p = new Pack.Sync(opt)\n\n  let threw = true\n  let fd\n  let position\n\n  try {\n    try {\n      fd = fs.openSync(opt.file, 'r+')\n    } catch (er) {\n      if (er.code === 'ENOENT') {\n        fd = fs.openSync(opt.file, 'w+')\n      } else {\n        throw er\n      }\n    }\n\n    const st = fs.fstatSync(fd)\n    const headBuf = Buffer.alloc(512)\n\n    POSITION: for (position = 0; position < st.size; position += 512) {\n      for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n        bytes = fs.readSync(\n          fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos\n        )\n\n        if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n          throw new Error('cannot append to compressed archives')\n        }\n\n        if (!bytes) {\n          break POSITION\n        }\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        break\n      }\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > st.size) {\n        break\n      }\n      // the 512 for the header we just parsed will be added as well\n      // also jump ahead all the blocks for the body\n      position += entryBlockSize\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n    }\n    threw = false\n\n    streamSync(opt, p, position, fd, files)\n  } finally {\n    if (threw) {\n      try {\n        fs.closeSync(fd)\n      } catch (er) {}\n    }\n  }\n}\n\nconst streamSync = (opt, p, position, fd, files) => {\n  const stream = new fsm.WriteStreamSync(opt.file, {\n    fd: fd,\n    start: position,\n  })\n  p.pipe(stream)\n  addFilesSync(p, files)\n}\n\nconst replace = (opt, files, cb) => {\n  files = Array.from(files)\n  const p = new Pack(opt)\n\n  const getPos = (fd, size, cb_) => {\n    const cb = (er, pos) => {\n      if (er) {\n        fs.close(fd, _ => cb_(er))\n      } else {\n        cb_(null, pos)\n      }\n    }\n\n    let position = 0\n    if (size === 0) {\n      return cb(null, 0)\n    }\n\n    let bufPos = 0\n    const headBuf = Buffer.alloc(512)\n    const onread = (er, bytes) => {\n      if (er) {\n        return cb(er)\n      }\n      bufPos += bytes\n      if (bufPos < 512 && bytes) {\n        return fs.read(\n          fd, headBuf, bufPos, headBuf.length - bufPos,\n          position + bufPos, onread\n        )\n      }\n\n      if (position === 0 && headBuf[0] === 0x1f && headBuf[1] === 0x8b) {\n        return cb(new Error('cannot append to compressed archives'))\n      }\n\n      // truncated header\n      if (bufPos < 512) {\n        return cb(null, position)\n      }\n\n      const h = new Header(headBuf)\n      if (!h.cksumValid) {\n        return cb(null, position)\n      }\n\n      const entryBlockSize = 512 * Math.ceil(h.size / 512)\n      if (position + entryBlockSize + 512 > size) {\n        return cb(null, position)\n      }\n\n      position += entryBlockSize + 512\n      if (position >= size) {\n        return cb(null, position)\n      }\n\n      if (opt.mtimeCache) {\n        opt.mtimeCache.set(h.path, h.mtime)\n      }\n      bufPos = 0\n      fs.read(fd, headBuf, 0, 512, position, onread)\n    }\n    fs.read(fd, headBuf, 0, 512, position, onread)\n  }\n\n  const promise = new Promise((resolve, reject) => {\n    p.on('error', reject)\n    let flag = 'r+'\n    const onopen = (er, fd) => {\n      if (er && er.code === 'ENOENT' && flag === 'r+') {\n        flag = 'w+'\n        return fs.open(opt.file, flag, onopen)\n      }\n\n      if (er) {\n        return reject(er)\n      }\n\n      fs.fstat(fd, (er, st) => {\n        if (er) {\n          return fs.close(fd, () => reject(er))\n        }\n\n        getPos(fd, st.size, (er, position) => {\n          if (er) {\n            return reject(er)\n          }\n          const stream = new fsm.WriteStream(opt.file, {\n            fd: fd,\n            start: position,\n          })\n          p.pipe(stream)\n          stream.on('error', reject)\n          stream.on('close', resolve)\n          addFilesAsync(p, files)\n        })\n      })\n    }\n    fs.open(opt.file, flag, onopen)\n  })\n\n  return cb ? promise.then(cb, cb) : promise\n}\n\nconst addFilesSync = (p, files) => {\n  files.forEach(file => {\n    if (file.charAt(0) === '@') {\n      t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        sync: true,\n        noResume: true,\n        onentry: entry => p.add(entry),\n      })\n    } else {\n      p.add(file)\n    }\n  })\n  p.end()\n}\n\nconst addFilesAsync = (p, files) => {\n  while (files.length) {\n    const file = files.shift()\n    if (file.charAt(0) === '@') {\n      return t({\n        file: path.resolve(p.cwd, file.slice(1)),\n        noResume: true,\n        onentry: entry => p.add(entry),\n      }).then(_ => addFilesAsync(p, files))\n    } else {\n      p.add(file)\n    }\n  }\n  p.end()\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9yZXBsYWNlLmpzIiwibWFwcGluZ3MiOiJBQUFZOztBQUVaO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLHFFQUFxQjtBQUN6QyxhQUFhLG1CQUFPLENBQUMsaURBQVc7QUFDaEMsV0FBVyxtQkFBTyxDQUFDLGNBQUk7QUFDdkIsWUFBWSxtQkFBTyxDQUFDLHdEQUFhO0FBQ2pDLFVBQVUsbUJBQU8sQ0FBQyxpREFBVztBQUM3QixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxtQkFBTyxDQUFDLHFEQUFhOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQ0FBaUMsb0JBQW9CO0FBQ3JELHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9yZXBsYWNlLmpzPzIzMjEiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHRhciAtclxuY29uc3QgaGxvID0gcmVxdWlyZSgnLi9oaWdoLWxldmVsLW9wdC5qcycpXG5jb25zdCBQYWNrID0gcmVxdWlyZSgnLi9wYWNrLmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnMtbWluaXBhc3MnKVxuY29uc3QgdCA9IHJlcXVpcmUoJy4vbGlzdC5qcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5cbi8vIHN0YXJ0aW5nIGF0IHRoZSBoZWFkIG9mIHRoZSBmaWxlLCByZWFkIGEgSGVhZGVyXG4vLyBJZiB0aGUgY2hlY2tzdW0gaXMgaW52YWxpZCwgdGhhdCdzIG91ciBwb3NpdGlvbiB0byBzdGFydCB3cml0aW5nXG4vLyBJZiBpdCBpcywganVtcCBmb3J3YXJkIGJ5IHRoZSBzcGVjaWZpZWQgc2l6ZSAocm91bmQgdXAgdG8gNTEyKVxuLy8gYW5kIHRyeSBhZ2Fpbi5cbi8vIFdyaXRlIHRoZSBuZXcgUGFjayBzdHJlYW0gc3RhcnRpbmcgdGhlcmUuXG5cbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyLmpzJylcblxubW9kdWxlLmV4cG9ydHMgPSAob3B0XywgZmlsZXMsIGNiKSA9PiB7XG4gIGNvbnN0IG9wdCA9IGhsbyhvcHRfKVxuXG4gIGlmICghb3B0LmZpbGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWxlIGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmIChvcHQuZ3ppcCB8fCBvcHQuYnJvdGxpIHx8IG9wdC5maWxlLmVuZHNXaXRoKCcuYnInKSB8fCBvcHQuZmlsZS5lbmRzV2l0aCgnLnRicicpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IGFwcGVuZCB0byBjb21wcmVzc2VkIGFyY2hpdmVzJylcbiAgfVxuXG4gIGlmICghZmlsZXMgfHwgIUFycmF5LmlzQXJyYXkoZmlsZXMpIHx8ICFmaWxlcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBmaWxlcyBvciBkaXJlY3RvcmllcyBzcGVjaWZpZWQnKVxuICB9XG5cbiAgZmlsZXMgPSBBcnJheS5mcm9tKGZpbGVzKVxuXG4gIHJldHVybiBvcHQuc3luYyA/IHJlcGxhY2VTeW5jKG9wdCwgZmlsZXMpXG4gICAgOiByZXBsYWNlKG9wdCwgZmlsZXMsIGNiKVxufVxuXG5jb25zdCByZXBsYWNlU3luYyA9IChvcHQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IHAgPSBuZXcgUGFjay5TeW5jKG9wdClcblxuICBsZXQgdGhyZXcgPSB0cnVlXG4gIGxldCBmZFxuICBsZXQgcG9zaXRpb25cblxuICB0cnkge1xuICAgIHRyeSB7XG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKG9wdC5maWxlLCAncisnKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICBpZiAoZXIuY29kZSA9PT0gJ0VOT0VOVCcpIHtcbiAgICAgICAgZmQgPSBmcy5vcGVuU3luYyhvcHQuZmlsZSwgJ3crJylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IGVyXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3QgPSBmcy5mc3RhdFN5bmMoZmQpXG4gICAgY29uc3QgaGVhZEJ1ZiA9IEJ1ZmZlci5hbGxvYyg1MTIpXG5cbiAgICBQT1NJVElPTjogZm9yIChwb3NpdGlvbiA9IDA7IHBvc2l0aW9uIDwgc3Quc2l6ZTsgcG9zaXRpb24gKz0gNTEyKSB7XG4gICAgICBmb3IgKGxldCBidWZQb3MgPSAwLCBieXRlcyA9IDA7IGJ1ZlBvcyA8IDUxMjsgYnVmUG9zICs9IGJ5dGVzKSB7XG4gICAgICAgIGJ5dGVzID0gZnMucmVhZFN5bmMoXG4gICAgICAgICAgZmQsIGhlYWRCdWYsIGJ1ZlBvcywgaGVhZEJ1Zi5sZW5ndGggLSBidWZQb3MsIHBvc2l0aW9uICsgYnVmUG9zXG4gICAgICAgIClcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDAgJiYgaGVhZEJ1ZlswXSA9PT0gMHgxZiAmJiBoZWFkQnVmWzFdID09PSAweDhiKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFieXRlcykge1xuICAgICAgICAgIGJyZWFrIFBPU0lUSU9OXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgaCA9IG5ldyBIZWFkZXIoaGVhZEJ1ZilcbiAgICAgIGlmICghaC5ja3N1bVZhbGlkKSB7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBjb25zdCBlbnRyeUJsb2NrU2l6ZSA9IDUxMiAqIE1hdGguY2VpbChoLnNpemUgLyA1MTIpXG4gICAgICBpZiAocG9zaXRpb24gKyBlbnRyeUJsb2NrU2l6ZSArIDUxMiA+IHN0LnNpemUpIHtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICAgIC8vIHRoZSA1MTIgZm9yIHRoZSBoZWFkZXIgd2UganVzdCBwYXJzZWQgd2lsbCBiZSBhZGRlZCBhcyB3ZWxsXG4gICAgICAvLyBhbHNvIGp1bXAgYWhlYWQgYWxsIHRoZSBibG9ja3MgZm9yIHRoZSBib2R5XG4gICAgICBwb3NpdGlvbiArPSBlbnRyeUJsb2NrU2l6ZVxuICAgICAgaWYgKG9wdC5tdGltZUNhY2hlKSB7XG4gICAgICAgIG9wdC5tdGltZUNhY2hlLnNldChoLnBhdGgsIGgubXRpbWUpXG4gICAgICB9XG4gICAgfVxuICAgIHRocmV3ID0gZmFsc2VcblxuICAgIHN0cmVhbVN5bmMob3B0LCBwLCBwb3NpdGlvbiwgZmQsIGZpbGVzKVxuICB9IGZpbmFsbHkge1xuICAgIGlmICh0aHJldykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgfSBjYXRjaCAoZXIpIHt9XG4gICAgfVxuICB9XG59XG5cbmNvbnN0IHN0cmVhbVN5bmMgPSAob3B0LCBwLCBwb3NpdGlvbiwgZmQsIGZpbGVzKSA9PiB7XG4gIGNvbnN0IHN0cmVhbSA9IG5ldyBmc20uV3JpdGVTdHJlYW1TeW5jKG9wdC5maWxlLCB7XG4gICAgZmQ6IGZkLFxuICAgIHN0YXJ0OiBwb3NpdGlvbixcbiAgfSlcbiAgcC5waXBlKHN0cmVhbSlcbiAgYWRkRmlsZXNTeW5jKHAsIGZpbGVzKVxufVxuXG5jb25zdCByZXBsYWNlID0gKG9wdCwgZmlsZXMsIGNiKSA9PiB7XG4gIGZpbGVzID0gQXJyYXkuZnJvbShmaWxlcylcbiAgY29uc3QgcCA9IG5ldyBQYWNrKG9wdClcblxuICBjb25zdCBnZXRQb3MgPSAoZmQsIHNpemUsIGNiXykgPT4ge1xuICAgIGNvbnN0IGNiID0gKGVyLCBwb3MpID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICBmcy5jbG9zZShmZCwgXyA9PiBjYl8oZXIpKVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2JfKG51bGwsIHBvcylcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgcG9zaXRpb24gPSAwXG4gICAgaWYgKHNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiBjYihudWxsLCAwKVxuICAgIH1cblxuICAgIGxldCBidWZQb3MgPSAwXG4gICAgY29uc3QgaGVhZEJ1ZiA9IEJ1ZmZlci5hbGxvYyg1MTIpXG4gICAgY29uc3Qgb25yZWFkID0gKGVyLCBieXRlcykgPT4ge1xuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIHJldHVybiBjYihlcilcbiAgICAgIH1cbiAgICAgIGJ1ZlBvcyArPSBieXRlc1xuICAgICAgaWYgKGJ1ZlBvcyA8IDUxMiAmJiBieXRlcykge1xuICAgICAgICByZXR1cm4gZnMucmVhZChcbiAgICAgICAgICBmZCwgaGVhZEJ1ZiwgYnVmUG9zLCBoZWFkQnVmLmxlbmd0aCAtIGJ1ZlBvcyxcbiAgICAgICAgICBwb3NpdGlvbiArIGJ1ZlBvcywgb25yZWFkXG4gICAgICAgIClcbiAgICAgIH1cblxuICAgICAgaWYgKHBvc2l0aW9uID09PSAwICYmIGhlYWRCdWZbMF0gPT09IDB4MWYgJiYgaGVhZEJ1ZlsxXSA9PT0gMHg4Yikge1xuICAgICAgICByZXR1cm4gY2IobmV3IEVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKSlcbiAgICAgIH1cblxuICAgICAgLy8gdHJ1bmNhdGVkIGhlYWRlclxuICAgICAgaWYgKGJ1ZlBvcyA8IDUxMikge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGggPSBuZXcgSGVhZGVyKGhlYWRCdWYpXG4gICAgICBpZiAoIWguY2tzdW1WYWxpZCkge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pXG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVudHJ5QmxvY2tTaXplID0gNTEyICogTWF0aC5jZWlsKGguc2l6ZSAvIDUxMilcbiAgICAgIGlmIChwb3NpdGlvbiArIGVudHJ5QmxvY2tTaXplICsgNTEyID4gc2l6ZSkge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pXG4gICAgICB9XG5cbiAgICAgIHBvc2l0aW9uICs9IGVudHJ5QmxvY2tTaXplICsgNTEyXG4gICAgICBpZiAocG9zaXRpb24gPj0gc2l6ZSkge1xuICAgICAgICByZXR1cm4gY2IobnVsbCwgcG9zaXRpb24pXG4gICAgICB9XG5cbiAgICAgIGlmIChvcHQubXRpbWVDYWNoZSkge1xuICAgICAgICBvcHQubXRpbWVDYWNoZS5zZXQoaC5wYXRoLCBoLm10aW1lKVxuICAgICAgfVxuICAgICAgYnVmUG9zID0gMFxuICAgICAgZnMucmVhZChmZCwgaGVhZEJ1ZiwgMCwgNTEyLCBwb3NpdGlvbiwgb25yZWFkKVxuICAgIH1cbiAgICBmcy5yZWFkKGZkLCBoZWFkQnVmLCAwLCA1MTIsIHBvc2l0aW9uLCBvbnJlYWQpXG4gIH1cblxuICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIHAub24oJ2Vycm9yJywgcmVqZWN0KVxuICAgIGxldCBmbGFnID0gJ3IrJ1xuICAgIGNvbnN0IG9ub3BlbiA9IChlciwgZmQpID0+IHtcbiAgICAgIGlmIChlciAmJiBlci5jb2RlID09PSAnRU5PRU5UJyAmJiBmbGFnID09PSAncisnKSB7XG4gICAgICAgIGZsYWcgPSAndysnXG4gICAgICAgIHJldHVybiBmcy5vcGVuKG9wdC5maWxlLCBmbGFnLCBvbm9wZW4pXG4gICAgICB9XG5cbiAgICAgIGlmIChlcikge1xuICAgICAgICByZXR1cm4gcmVqZWN0KGVyKVxuICAgICAgfVxuXG4gICAgICBmcy5mc3RhdChmZCwgKGVyLCBzdCkgPT4ge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICByZXR1cm4gZnMuY2xvc2UoZmQsICgpID0+IHJlamVjdChlcikpXG4gICAgICAgIH1cblxuICAgICAgICBnZXRQb3MoZmQsIHN0LnNpemUsIChlciwgcG9zaXRpb24pID0+IHtcbiAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIHJldHVybiByZWplY3QoZXIpXG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IG5ldyBmc20uV3JpdGVTdHJlYW0ob3B0LmZpbGUsIHtcbiAgICAgICAgICAgIGZkOiBmZCxcbiAgICAgICAgICAgIHN0YXJ0OiBwb3NpdGlvbixcbiAgICAgICAgICB9KVxuICAgICAgICAgIHAucGlwZShzdHJlYW0pXG4gICAgICAgICAgc3RyZWFtLm9uKCdlcnJvcicsIHJlamVjdClcbiAgICAgICAgICBzdHJlYW0ub24oJ2Nsb3NlJywgcmVzb2x2ZSlcbiAgICAgICAgICBhZGRGaWxlc0FzeW5jKHAsIGZpbGVzKVxuICAgICAgICB9KVxuICAgICAgfSlcbiAgICB9XG4gICAgZnMub3BlbihvcHQuZmlsZSwgZmxhZywgb25vcGVuKVxuICB9KVxuXG4gIHJldHVybiBjYiA/IHByb21pc2UudGhlbihjYiwgY2IpIDogcHJvbWlzZVxufVxuXG5jb25zdCBhZGRGaWxlc1N5bmMgPSAocCwgZmlsZXMpID0+IHtcbiAgZmlsZXMuZm9yRWFjaChmaWxlID0+IHtcbiAgICBpZiAoZmlsZS5jaGFyQXQoMCkgPT09ICdAJykge1xuICAgICAgdCh7XG4gICAgICAgIGZpbGU6IHBhdGgucmVzb2x2ZShwLmN3ZCwgZmlsZS5zbGljZSgxKSksXG4gICAgICAgIHN5bmM6IHRydWUsXG4gICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICBvbmVudHJ5OiBlbnRyeSA9PiBwLmFkZChlbnRyeSksXG4gICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICBwLmFkZChmaWxlKVxuICAgIH1cbiAgfSlcbiAgcC5lbmQoKVxufVxuXG5jb25zdCBhZGRGaWxlc0FzeW5jID0gKHAsIGZpbGVzKSA9PiB7XG4gIHdoaWxlIChmaWxlcy5sZW5ndGgpIHtcbiAgICBjb25zdCBmaWxlID0gZmlsZXMuc2hpZnQoKVxuICAgIGlmIChmaWxlLmNoYXJBdCgwKSA9PT0gJ0AnKSB7XG4gICAgICByZXR1cm4gdCh7XG4gICAgICAgIGZpbGU6IHBhdGgucmVzb2x2ZShwLmN3ZCwgZmlsZS5zbGljZSgxKSksXG4gICAgICAgIG5vUmVzdW1lOiB0cnVlLFxuICAgICAgICBvbmVudHJ5OiBlbnRyeSA9PiBwLmFkZChlbnRyeSksXG4gICAgICB9KS50aGVuKF8gPT4gYWRkRmlsZXNBc3luYyhwLCBmaWxlcykpXG4gICAgfSBlbHNlIHtcbiAgICAgIHAuYWRkKGZpbGUpXG4gICAgfVxuICB9XG4gIHAuZW5kKClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/replace.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/strip-absolute-path.js":
/*!*****************************************************!*\
  !*** ./node_modules/tar/lib/strip-absolute-path.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// unix absolute paths are also absolute on win32, so we use this for both\nconst { isAbsolute, parse } = (__webpack_require__(/*! path */ \"path\").win32)\n\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nmodule.exports = path => {\n  let r = ''\n\n  let parsed = parse(path)\n  while (isAbsolute(path) || parsed.root) {\n    // windows will think that //x/y/z has a \"root\" of //x/y/\n    // but strip the //?/C:/ off of //?/C:/path\n    const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ? '/'\n      : parsed.root\n    path = path.slice(root.length)\n    r += root\n    parsed = parse(path)\n  }\n  return [r, path]\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsUUFBUSxvQkFBb0IsRUFBRSwrQ0FBcUI7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL3N0cmlwLWFic29sdXRlLXBhdGguanM/MTVhNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB1bml4IGFic29sdXRlIHBhdGhzIGFyZSBhbHNvIGFic29sdXRlIG9uIHdpbjMyLCBzbyB3ZSB1c2UgdGhpcyBmb3IgYm90aFxuY29uc3QgeyBpc0Fic29sdXRlLCBwYXJzZSB9ID0gcmVxdWlyZSgncGF0aCcpLndpbjMyXG5cbi8vIHJldHVybnMgW3Jvb3QsIHN0cmlwcGVkXVxuLy8gTm90ZSB0aGF0IHdpbmRvd3Mgd2lsbCB0aGluayB0aGF0IC8veC95L3ovYSBoYXMgYSBcInJvb3RcIiBvZiAvL3gveSwgYW5kIGluXG4vLyB0aG9zZSBjYXNlcywgd2Ugd2FudCB0byBzYW5pdGl6ZSBpdCB0byB4L3kvei9hLCBub3Qgei9hLCBzbyB3ZSBzdHJpcCAvXG4vLyBleHBsaWNpdGx5IGlmIGl0J3MgdGhlIGZpcnN0IGNoYXJhY3Rlci5cbi8vIGRyaXZlLXNwZWNpZmljIHJlbGF0aXZlIHBhdGhzIG9uIFdpbmRvd3MgZ2V0IHRoZWlyIHJvb3Qgc3RyaXBwZWQgb2ZmIGV2ZW5cbi8vIHRob3VnaCB0aGV5IGFyZSBub3QgYWJzb2x1dGUsIHNvIGBjOi4uL2Zvb2AgYmVjb21lcyBbJ2M6JywgJy4uL2ZvbyddXG5tb2R1bGUuZXhwb3J0cyA9IHBhdGggPT4ge1xuICBsZXQgciA9ICcnXG5cbiAgbGV0IHBhcnNlZCA9IHBhcnNlKHBhdGgpXG4gIHdoaWxlIChpc0Fic29sdXRlKHBhdGgpIHx8IHBhcnNlZC5yb290KSB7XG4gICAgLy8gd2luZG93cyB3aWxsIHRoaW5rIHRoYXQgLy94L3kveiBoYXMgYSBcInJvb3RcIiBvZiAvL3gveS9cbiAgICAvLyBidXQgc3RyaXAgdGhlIC8vPy9DOi8gb2ZmIG9mIC8vPy9DOi9wYXRoXG4gICAgY29uc3Qgcm9vdCA9IHBhdGguY2hhckF0KDApID09PSAnLycgJiYgcGF0aC5zbGljZSgwLCA0KSAhPT0gJy8vPy8nID8gJy8nXG4gICAgICA6IHBhcnNlZC5yb290XG4gICAgcGF0aCA9IHBhdGguc2xpY2Uocm9vdC5sZW5ndGgpXG4gICAgciArPSByb290XG4gICAgcGFyc2VkID0gcGFyc2UocGF0aClcbiAgfVxuICByZXR1cm4gW3IsIHBhdGhdXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/strip-absolute-path.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/strip-trailing-slashes.js":
/*!********************************************************!*\
  !*** ./node_modules/tar/lib/strip-trailing-slashes.js ***!
  \********************************************************/
/***/ ((module) => {

eval("// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nmodule.exports = str => {\n  let i = str.length - 1\n  let slashesStart = -1\n  while (i > -1 && str.charAt(i) === '/') {\n    slashesStart = i\n    i--\n  }\n  return slashesStart === -1 ? str : str.slice(0, slashesStart)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL3N0cmlwLXRyYWlsaW5nLXNsYXNoZXMuanM/ZTc0YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyB3YXJuaW5nOiBleHRyZW1lbHkgaG90IGNvZGUgcGF0aC5cbi8vIFRoaXMgaGFzIGJlZW4gbWV0aWN1bG91c2x5IG9wdGltaXplZCBmb3IgdXNlXG4vLyB3aXRoaW4gbnBtIGluc3RhbGwgb24gbGFyZ2UgcGFja2FnZSB0cmVlcy5cbi8vIERvIG5vdCBlZGl0IHdpdGhvdXQgY2FyZWZ1bCBiZW5jaG1hcmtpbmcuXG5tb2R1bGUuZXhwb3J0cyA9IHN0ciA9PiB7XG4gIGxldCBpID0gc3RyLmxlbmd0aCAtIDFcbiAgbGV0IHNsYXNoZXNTdGFydCA9IC0xXG4gIHdoaWxlIChpID4gLTEgJiYgc3RyLmNoYXJBdChpKSA9PT0gJy8nKSB7XG4gICAgc2xhc2hlc1N0YXJ0ID0gaVxuICAgIGktLVxuICB9XG4gIHJldHVybiBzbGFzaGVzU3RhcnQgPT09IC0xID8gc3RyIDogc3RyLnNsaWNlKDAsIHNsYXNoZXNTdGFydClcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/strip-trailing-slashes.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/types.js":
/*!***************************************!*\
  !*** ./node_modules/tar/lib/types.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

"use strict";
eval("\n// map types from key to human-friendly name\nexports.name = new Map([\n  ['0', 'File'],\n  // same as File\n  ['', 'OldFile'],\n  ['1', 'Link'],\n  ['2', 'SymbolicLink'],\n  // Devices and FIFOs aren't fully supported\n  // they are parsed, but skipped when unpacking\n  ['3', 'CharacterDevice'],\n  ['4', 'BlockDevice'],\n  ['5', 'Directory'],\n  ['6', 'FIFO'],\n  // same as File\n  ['7', 'ContiguousFile'],\n  // pax headers\n  ['g', 'GlobalExtendedHeader'],\n  ['x', 'ExtendedHeader'],\n  // vendor-specific stuff\n  // skip\n  ['A', 'SolarisACL'],\n  // like 5, but with data, which should be skipped\n  ['D', 'GNUDumpDir'],\n  // metadata only, skip\n  ['I', 'Inode'],\n  // data = link path of next file\n  ['K', 'NextFileHasLongLinkpath'],\n  // data = path of next file\n  ['L', 'NextFileHasLongPath'],\n  // skip\n  ['M', 'ContinuationFile'],\n  // like L\n  ['N', 'OldGnuLongPath'],\n  // skip\n  ['S', 'SparseFile'],\n  // skip\n  ['V', 'TapeVolumeHeader'],\n  // like x\n  ['X', 'OldExtendedHeader'],\n])\n\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]))\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi90eXBlcy5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL3R5cGVzLmpzPzE0YTciXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBtYXAgdHlwZXMgZnJvbSBrZXkgdG8gaHVtYW4tZnJpZW5kbHkgbmFtZVxuZXhwb3J0cy5uYW1lID0gbmV3IE1hcChbXG4gIFsnMCcsICdGaWxlJ10sXG4gIC8vIHNhbWUgYXMgRmlsZVxuICBbJycsICdPbGRGaWxlJ10sXG4gIFsnMScsICdMaW5rJ10sXG4gIFsnMicsICdTeW1ib2xpY0xpbmsnXSxcbiAgLy8gRGV2aWNlcyBhbmQgRklGT3MgYXJlbid0IGZ1bGx5IHN1cHBvcnRlZFxuICAvLyB0aGV5IGFyZSBwYXJzZWQsIGJ1dCBza2lwcGVkIHdoZW4gdW5wYWNraW5nXG4gIFsnMycsICdDaGFyYWN0ZXJEZXZpY2UnXSxcbiAgWyc0JywgJ0Jsb2NrRGV2aWNlJ10sXG4gIFsnNScsICdEaXJlY3RvcnknXSxcbiAgWyc2JywgJ0ZJRk8nXSxcbiAgLy8gc2FtZSBhcyBGaWxlXG4gIFsnNycsICdDb250aWd1b3VzRmlsZSddLFxuICAvLyBwYXggaGVhZGVyc1xuICBbJ2cnLCAnR2xvYmFsRXh0ZW5kZWRIZWFkZXInXSxcbiAgWyd4JywgJ0V4dGVuZGVkSGVhZGVyJ10sXG4gIC8vIHZlbmRvci1zcGVjaWZpYyBzdHVmZlxuICAvLyBza2lwXG4gIFsnQScsICdTb2xhcmlzQUNMJ10sXG4gIC8vIGxpa2UgNSwgYnV0IHdpdGggZGF0YSwgd2hpY2ggc2hvdWxkIGJlIHNraXBwZWRcbiAgWydEJywgJ0dOVUR1bXBEaXInXSxcbiAgLy8gbWV0YWRhdGEgb25seSwgc2tpcFxuICBbJ0knLCAnSW5vZGUnXSxcbiAgLy8gZGF0YSA9IGxpbmsgcGF0aCBvZiBuZXh0IGZpbGVcbiAgWydLJywgJ05leHRGaWxlSGFzTG9uZ0xpbmtwYXRoJ10sXG4gIC8vIGRhdGEgPSBwYXRoIG9mIG5leHQgZmlsZVxuICBbJ0wnLCAnTmV4dEZpbGVIYXNMb25nUGF0aCddLFxuICAvLyBza2lwXG4gIFsnTScsICdDb250aW51YXRpb25GaWxlJ10sXG4gIC8vIGxpa2UgTFxuICBbJ04nLCAnT2xkR251TG9uZ1BhdGgnXSxcbiAgLy8gc2tpcFxuICBbJ1MnLCAnU3BhcnNlRmlsZSddLFxuICAvLyBza2lwXG4gIFsnVicsICdUYXBlVm9sdW1lSGVhZGVyJ10sXG4gIC8vIGxpa2UgeFxuICBbJ1gnLCAnT2xkRXh0ZW5kZWRIZWFkZXInXSxcbl0pXG5cbi8vIG1hcCB0aGUgb3RoZXIgZGlyZWN0aW9uXG5leHBvcnRzLmNvZGUgPSBuZXcgTWFwKEFycmF5LmZyb20oZXhwb3J0cy5uYW1lKS5tYXAoa3YgPT4gW2t2WzFdLCBrdlswXV0pKVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/types.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/unpack.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/unpack.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\n\nconst assert = __webpack_require__(/*! assert */ \"assert\")\nconst Parser = __webpack_require__(/*! ./parse.js */ \"./node_modules/tar/lib/parse.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst fsm = __webpack_require__(/*! fs-minipass */ \"./node_modules/fs-minipass/index.js\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst mkdir = __webpack_require__(/*! ./mkdir.js */ \"./node_modules/tar/lib/mkdir.js\")\nconst wc = __webpack_require__(/*! ./winchars.js */ \"./node_modules/tar/lib/winchars.js\")\nconst pathReservations = __webpack_require__(/*! ./path-reservations.js */ \"./node_modules/tar/lib/path-reservations.js\")\nconst stripAbsolutePath = __webpack_require__(/*! ./strip-absolute-path.js */ \"./node_modules/tar/lib/strip-absolute-path.js\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/lib/normalize-windows-path.js\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/lib/strip-trailing-slashes.js\")\nconst normalize = __webpack_require__(/*! ./normalize-unicode.js */ \"./node_modules/tar/lib/normalize-unicode.js\")\n\nconst ONENTRY = Symbol('onEntry')\nconst CHECKFS = Symbol('checkFs')\nconst CHECKFS2 = Symbol('checkFs2')\nconst PRUNECACHE = Symbol('pruneCache')\nconst ISREUSABLE = Symbol('isReusable')\nconst MAKEFS = Symbol('makeFs')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst LINK = Symbol('link')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst UNSUPPORTED = Symbol('unsupported')\nconst CHECKPATH = Symbol('checkPath')\nconst MKDIR = Symbol('mkdir')\nconst ONERROR = Symbol('onError')\nconst PENDING = Symbol('pending')\nconst PEND = Symbol('pend')\nconst UNPEND = Symbol('unpend')\nconst ENDED = Symbol('ended')\nconst MAYBECLOSE = Symbol('maybeClose')\nconst SKIP = Symbol('skip')\nconst DOCHOWN = Symbol('doChown')\nconst UID = Symbol('uid')\nconst GID = Symbol('gid')\nconst CHECKED_CWD = Symbol('checkedCwd')\nconst crypto = __webpack_require__(/*! crypto */ \"crypto\")\nconst getFlag = __webpack_require__(/*! ./get-write-flag.js */ \"./node_modules/tar/lib/get-write-flag.js\")\nconst platform = {}.TESTING_TAR_FAKE_PLATFORM || process.platform\nconst isWindows = platform === 'win32'\nconst DEFAULT_MAX_DEPTH = 1024\n\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* istanbul ignore next */\nconst unlinkFile = (path, cb) => {\n  if (!isWindows) {\n    return fs.unlink(path, cb)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.rename(path, name, er => {\n    if (er) {\n      return cb(er)\n    }\n    fs.unlink(name, cb)\n  })\n}\n\n/* istanbul ignore next */\nconst unlinkFileSync = path => {\n  if (!isWindows) {\n    return fs.unlinkSync(path)\n  }\n\n  const name = path + '.DELETE.' + crypto.randomBytes(16).toString('hex')\n  fs.renameSync(path, name)\n  fs.unlinkSync(name)\n}\n\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) =>\n  a === a >>> 0 ? a\n  : b === b >>> 0 ? b\n  : c\n\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = path => stripSlash(normPath(normalize(path)))\n  .toLowerCase()\n\nconst pruneCache = (cache, abs) => {\n  abs = cacheKeyNormalize(abs)\n  for (const path of cache.keys()) {\n    const pnorm = cacheKeyNormalize(path)\n    if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n      cache.delete(path)\n    }\n  }\n}\n\nconst dropCache = cache => {\n  for (const key of cache.keys()) {\n    cache.delete(key)\n  }\n}\n\nclass Unpack extends Parser {\n  constructor (opt) {\n    if (!opt) {\n      opt = {}\n    }\n\n    opt.ondone = _ => {\n      this[ENDED] = true\n      this[MAYBECLOSE]()\n    }\n\n    super(opt)\n\n    this[CHECKED_CWD] = false\n\n    this.reservations = pathReservations()\n\n    this.transform = typeof opt.transform === 'function' ? opt.transform : null\n\n    this.writable = true\n    this.readable = false\n\n    this[PENDING] = 0\n    this[ENDED] = false\n\n    this.dirCache = opt.dirCache || new Map()\n\n    if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n      // need both or neither\n      if (typeof opt.uid !== 'number' || typeof opt.gid !== 'number') {\n        throw new TypeError('cannot set owner without number uid and gid')\n      }\n      if (opt.preserveOwner) {\n        throw new TypeError(\n          'cannot preserve owner in archive and also set owner explicitly')\n      }\n      this.uid = opt.uid\n      this.gid = opt.gid\n      this.setOwner = true\n    } else {\n      this.uid = null\n      this.gid = null\n      this.setOwner = false\n    }\n\n    // default true for root\n    if (opt.preserveOwner === undefined && typeof opt.uid !== 'number') {\n      this.preserveOwner = process.getuid && process.getuid() === 0\n    } else {\n      this.preserveOwner = !!opt.preserveOwner\n    }\n\n    this.processUid = (this.preserveOwner || this.setOwner) && process.getuid ?\n      process.getuid() : null\n    this.processGid = (this.preserveOwner || this.setOwner) && process.getgid ?\n      process.getgid() : null\n\n    // prevent excessively deep nesting of subfolders\n    // set to `Infinity` to remove this restriction\n    this.maxDepth = typeof opt.maxDepth === 'number'\n      ? opt.maxDepth\n      : DEFAULT_MAX_DEPTH\n\n    // mostly just for testing, but useful in some cases.\n    // Forcibly trigger a chown on every entry, no matter what\n    this.forceChown = opt.forceChown === true\n\n    // turn ><?| in filenames into 0xf000-higher encoded forms\n    this.win32 = !!opt.win32 || isWindows\n\n    // do not unpack over files that are newer than what's in the archive\n    this.newer = !!opt.newer\n\n    // do not unpack over ANY files\n    this.keep = !!opt.keep\n\n    // do not set mtime/atime of extracted entries\n    this.noMtime = !!opt.noMtime\n\n    // allow .., absolute path entries, and unpacking through symlinks\n    // without this, warn and skip .., relativize absolutes, and error\n    // on symlinks in extraction path\n    this.preservePaths = !!opt.preservePaths\n\n    // unlink files and links before writing. This breaks existing hard\n    // links, and removes symlink directories rather than erroring\n    this.unlink = !!opt.unlink\n\n    this.cwd = normPath(path.resolve(opt.cwd || process.cwd()))\n    this.strip = +opt.strip || 0\n    // if we're not chmodding, then we don't need the process umask\n    this.processUmask = opt.noChmod ? 0 : process.umask()\n    this.umask = typeof opt.umask === 'number' ? opt.umask : this.processUmask\n\n    // default mode for dirs created as parents\n    this.dmode = opt.dmode || (0o0777 & (~this.umask))\n    this.fmode = opt.fmode || (0o0666 & (~this.umask))\n\n    this.on('entry', entry => this[ONENTRY](entry))\n  }\n\n  // a bad or damaged archive is a warning for Parser, but an error\n  // when extracting.  Mark those errors as unrecoverable, because\n  // the Unpack contract cannot be met.\n  warn (code, msg, data = {}) {\n    if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n      data.recoverable = false\n    }\n    return super.warn(code, msg, data)\n  }\n\n  [MAYBECLOSE] () {\n    if (this[ENDED] && this[PENDING] === 0) {\n      this.emit('prefinish')\n      this.emit('finish')\n      this.emit('end')\n    }\n  }\n\n  [CHECKPATH] (entry) {\n    const p = normPath(entry.path)\n    const parts = p.split('/')\n\n    if (this.strip) {\n      if (parts.length < this.strip) {\n        return false\n      }\n      if (entry.type === 'Link') {\n        const linkparts = normPath(entry.linkpath).split('/')\n        if (linkparts.length >= this.strip) {\n          entry.linkpath = linkparts.slice(this.strip).join('/')\n        } else {\n          return false\n        }\n      }\n      parts.splice(0, this.strip)\n      entry.path = parts.join('/')\n    }\n\n    if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n      this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n        entry,\n        path: p,\n        depth: parts.length,\n        maxDepth: this.maxDepth,\n      })\n      return false\n    }\n\n    if (!this.preservePaths) {\n      if (parts.includes('..') || isWindows && /^[a-z]:\\.\\.$/i.test(parts[0])) {\n        this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n          entry,\n          path: p,\n        })\n        return false\n      }\n\n      // strip off the root\n      const [root, stripped] = stripAbsolutePath(p)\n      if (root) {\n        entry.path = stripped\n        this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n          entry,\n          path: p,\n        })\n      }\n    }\n\n    if (path.isAbsolute(entry.path)) {\n      entry.absolute = normPath(path.resolve(entry.path))\n    } else {\n      entry.absolute = normPath(path.resolve(this.cwd, entry.path))\n    }\n\n    // if we somehow ended up with a path that escapes the cwd, and we are\n    // not in preservePaths mode, then something is fishy!  This should have\n    // been prevented above, so ignore this for coverage.\n    /* istanbul ignore if - defense in depth */\n    if (!this.preservePaths &&\n        entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n        entry.absolute !== this.cwd) {\n      this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n        entry,\n        path: normPath(entry.path),\n        resolvedPath: entry.absolute,\n        cwd: this.cwd,\n      })\n      return false\n    }\n\n    // an archive can set properties on the extraction directory, but it\n    // may not replace the cwd with a different kind of thing entirely.\n    if (entry.absolute === this.cwd &&\n        entry.type !== 'Directory' &&\n        entry.type !== 'GNUDumpDir') {\n      return false\n    }\n\n    // only encode : chars that aren't drive letter indicators\n    if (this.win32) {\n      const { root: aRoot } = path.win32.parse(entry.absolute)\n      entry.absolute = aRoot + wc.encode(entry.absolute.slice(aRoot.length))\n      const { root: pRoot } = path.win32.parse(entry.path)\n      entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length))\n    }\n\n    return true\n  }\n\n  [ONENTRY] (entry) {\n    if (!this[CHECKPATH](entry)) {\n      return entry.resume()\n    }\n\n    assert.equal(typeof entry.absolute, 'string')\n\n    switch (entry.type) {\n      case 'Directory':\n      case 'GNUDumpDir':\n        if (entry.mode) {\n          entry.mode = entry.mode | 0o700\n        }\n\n      // eslint-disable-next-line no-fallthrough\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n      case 'Link':\n      case 'SymbolicLink':\n        return this[CHECKFS](entry)\n\n      case 'CharacterDevice':\n      case 'BlockDevice':\n      case 'FIFO':\n      default:\n        return this[UNSUPPORTED](entry)\n    }\n  }\n\n  [ONERROR] (er, entry) {\n    // Cwd has to exist, or else nothing works. That's serious.\n    // Other errors are warnings, which raise the error in strict\n    // mode, but otherwise continue on.\n    if (er.name === 'CwdError') {\n      this.emit('error', er)\n    } else {\n      this.warn('TAR_ENTRY_ERROR', er, { entry })\n      this[UNPEND]()\n      entry.resume()\n    }\n  }\n\n  [MKDIR] (dir, mode, cb) {\n    mkdir(normPath(dir), {\n      uid: this.uid,\n      gid: this.gid,\n      processUid: this.processUid,\n      processGid: this.processGid,\n      umask: this.processUmask,\n      preserve: this.preservePaths,\n      unlink: this.unlink,\n      cache: this.dirCache,\n      cwd: this.cwd,\n      mode: mode,\n      noChmod: this.noChmod,\n    }, cb)\n  }\n\n  [DOCHOWN] (entry) {\n    // in preserve owner mode, chown if the entry doesn't match process\n    // in set owner mode, chown if setting doesn't match process\n    return this.forceChown ||\n      this.preserveOwner &&\n      (typeof entry.uid === 'number' && entry.uid !== this.processUid ||\n        typeof entry.gid === 'number' && entry.gid !== this.processGid)\n      ||\n      (typeof this.uid === 'number' && this.uid !== this.processUid ||\n        typeof this.gid === 'number' && this.gid !== this.processGid)\n  }\n\n  [UID] (entry) {\n    return uint32(this.uid, entry.uid, this.processUid)\n  }\n\n  [GID] (entry) {\n    return uint32(this.gid, entry.gid, this.processGid)\n  }\n\n  [FILE] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.fmode\n    const stream = new fsm.WriteStream(entry.absolute, {\n      flags: getFlag(entry.size),\n      mode: mode,\n      autoClose: false,\n    })\n    stream.on('error', er => {\n      if (stream.fd) {\n        fs.close(stream.fd, () => {})\n      }\n\n      // flush all the data out so that we aren't left hanging\n      // if the error wasn't actually fatal.  otherwise the parse\n      // is blocked, and we never proceed.\n      stream.write = () => true\n      this[ONERROR](er, entry)\n      fullyDone()\n    })\n\n    let actions = 1\n    const done = er => {\n      if (er) {\n        /* istanbul ignore else - we should always have a fd by now */\n        if (stream.fd) {\n          fs.close(stream.fd, () => {})\n        }\n\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      if (--actions === 0) {\n        fs.close(stream.fd, er => {\n          if (er) {\n            this[ONERROR](er, entry)\n          } else {\n            this[UNPEND]()\n          }\n          fullyDone()\n        })\n      }\n    }\n\n    stream.on('finish', _ => {\n      // if futimes fails, try utimes\n      // if utimes fails, fail with the original error\n      // same for fchown/chown\n      const abs = entry.absolute\n      const fd = stream.fd\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        fs.futimes(fd, atime, mtime, er =>\n          er ? fs.utimes(abs, atime, mtime, er2 => done(er2 && er))\n          : done())\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n        fs.fchown(fd, uid, gid, er =>\n          er ? fs.chown(abs, uid, gid, er2 => done(er2 && er))\n          : done())\n      }\n\n      done()\n    })\n\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => {\n        this[ONERROR](er, entry)\n        fullyDone()\n      })\n      entry.pipe(tx)\n    }\n    tx.pipe(stream)\n  }\n\n  [DIRECTORY] (entry, fullyDone) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    this[MKDIR](entry.absolute, mode, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n        fullyDone()\n        return\n      }\n\n      let actions = 1\n      const done = _ => {\n        if (--actions === 0) {\n          fullyDone()\n          this[UNPEND]()\n          entry.resume()\n        }\n      }\n\n      if (entry.mtime && !this.noMtime) {\n        actions++\n        fs.utimes(entry.absolute, entry.atime || new Date(), entry.mtime, done)\n      }\n\n      if (this[DOCHOWN](entry)) {\n        actions++\n        fs.chown(entry.absolute, this[UID](entry), this[GID](entry), done)\n      }\n\n      done()\n    })\n  }\n\n  [UNSUPPORTED] (entry) {\n    entry.unsupported = true\n    this.warn('TAR_ENTRY_UNSUPPORTED',\n      `unsupported entry type: ${entry.type}`, { entry })\n    entry.resume()\n  }\n\n  [SYMLINK] (entry, done) {\n    this[LINK](entry, entry.linkpath, 'symlink', done)\n  }\n\n  [HARDLINK] (entry, done) {\n    const linkpath = normPath(path.resolve(this.cwd, entry.linkpath))\n    this[LINK](entry, linkpath, 'link', done)\n  }\n\n  [PEND] () {\n    this[PENDING]++\n  }\n\n  [UNPEND] () {\n    this[PENDING]--\n    this[MAYBECLOSE]()\n  }\n\n  [SKIP] (entry) {\n    this[UNPEND]()\n    entry.resume()\n  }\n\n  // Check if we can reuse an existing filesystem entry safely and\n  // overwrite it, rather than unlinking and recreating\n  // Windows doesn't report a useful nlink, so we just never reuse entries\n  [ISREUSABLE] (entry, st) {\n    return entry.type === 'File' &&\n      !this.unlink &&\n      st.isFile() &&\n      st.nlink <= 1 &&\n      !isWindows\n  }\n\n  // check if a thing is there, and if so, try to clobber it\n  [CHECKFS] (entry) {\n    this[PEND]()\n    const paths = [entry.path]\n    if (entry.linkpath) {\n      paths.push(entry.linkpath)\n    }\n    this.reservations.reserve(paths, done => this[CHECKFS2](entry, done))\n  }\n\n  [PRUNECACHE] (entry) {\n    // if we are not creating a directory, and the path is in the dirCache,\n    // then that means we are about to delete the directory we created\n    // previously, and it is no longer going to be a directory, and neither\n    // is any of its children.\n    // If a symbolic link is encountered, all bets are off.  There is no\n    // reasonable way to sanitize the cache in such a way we will be able to\n    // avoid having filesystem collisions.  If this happens with a non-symlink\n    // entry, it'll just fail to unpack, but a symlink to a directory, using an\n    // 8.3 shortname or certain unicode attacks, can evade detection and lead\n    // to arbitrary writes to anywhere on the system.\n    if (entry.type === 'SymbolicLink') {\n      dropCache(this.dirCache)\n    } else if (entry.type !== 'Directory') {\n      pruneCache(this.dirCache, entry.absolute)\n    }\n  }\n\n  [CHECKFS2] (entry, fullyDone) {\n    this[PRUNECACHE](entry)\n\n    const done = er => {\n      this[PRUNECACHE](entry)\n      fullyDone(er)\n    }\n\n    const checkCwd = () => {\n      this[MKDIR](this.cwd, this.dmode, er => {\n        if (er) {\n          this[ONERROR](er, entry)\n          done()\n          return\n        }\n        this[CHECKED_CWD] = true\n        start()\n      })\n    }\n\n    const start = () => {\n      if (entry.absolute !== this.cwd) {\n        const parent = normPath(path.dirname(entry.absolute))\n        if (parent !== this.cwd) {\n          return this[MKDIR](parent, this.dmode, er => {\n            if (er) {\n              this[ONERROR](er, entry)\n              done()\n              return\n            }\n            afterMakeParent()\n          })\n        }\n      }\n      afterMakeParent()\n    }\n\n    const afterMakeParent = () => {\n      fs.lstat(entry.absolute, (lstatEr, st) => {\n        if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n          this[SKIP](entry)\n          done()\n          return\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        if (st.isDirectory()) {\n          if (entry.type === 'Directory') {\n            const needChmod = !this.noChmod &&\n              entry.mode &&\n              (st.mode & 0o7777) !== entry.mode\n            const afterChmod = er => this[MAKEFS](er, entry, done)\n            if (!needChmod) {\n              return afterChmod()\n            }\n            return fs.chmod(entry.absolute, entry.mode, afterChmod)\n          }\n          // Not a dir entry, have to remove it.\n          // NB: the only way to end up with an entry that is the cwd\n          // itself, in such a way that == does not detect, is a\n          // tricky windows absolute path with UNC or 8.3 parts (and\n          // preservePaths:true, or else it will have been stripped).\n          // In that case, the user has opted out of path protections\n          // explicitly, so if they blow away the cwd, c'est la vie.\n          if (entry.absolute !== this.cwd) {\n            return fs.rmdir(entry.absolute, er =>\n              this[MAKEFS](er, entry, done))\n          }\n        }\n\n        // not a dir, and not reusable\n        // don't remove if the cwd, we want that error\n        if (entry.absolute === this.cwd) {\n          return this[MAKEFS](null, entry, done)\n        }\n\n        unlinkFile(entry.absolute, er =>\n          this[MAKEFS](er, entry, done))\n      })\n    }\n\n    if (this[CHECKED_CWD]) {\n      start()\n    } else {\n      checkCwd()\n    }\n  }\n\n  [MAKEFS] (er, entry, done) {\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n\n    switch (entry.type) {\n      case 'File':\n      case 'OldFile':\n      case 'ContiguousFile':\n        return this[FILE](entry, done)\n\n      case 'Link':\n        return this[HARDLINK](entry, done)\n\n      case 'SymbolicLink':\n        return this[SYMLINK](entry, done)\n\n      case 'Directory':\n      case 'GNUDumpDir':\n        return this[DIRECTORY](entry, done)\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    // XXX: get the type ('symlink' or 'junction') for windows\n    fs[link](linkpath, entry.absolute, er => {\n      if (er) {\n        this[ONERROR](er, entry)\n      } else {\n        this[UNPEND]()\n        entry.resume()\n      }\n      done()\n    })\n  }\n}\n\nconst callSync = fn => {\n  try {\n    return [null, fn()]\n  } catch (er) {\n    return [er, null]\n  }\n}\nclass UnpackSync extends Unpack {\n  [MAKEFS] (er, entry) {\n    return super[MAKEFS](er, entry, () => {})\n  }\n\n  [CHECKFS] (entry) {\n    this[PRUNECACHE](entry)\n\n    if (!this[CHECKED_CWD]) {\n      const er = this[MKDIR](this.cwd, this.dmode)\n      if (er) {\n        return this[ONERROR](er, entry)\n      }\n      this[CHECKED_CWD] = true\n    }\n\n    // don't bother to make the parent if the current entry is the cwd,\n    // we've already checked it.\n    if (entry.absolute !== this.cwd) {\n      const parent = normPath(path.dirname(entry.absolute))\n      if (parent !== this.cwd) {\n        const mkParent = this[MKDIR](parent, this.dmode)\n        if (mkParent) {\n          return this[ONERROR](mkParent, entry)\n        }\n      }\n    }\n\n    const [lstatEr, st] = callSync(() => fs.lstatSync(entry.absolute))\n    if (st && (this.keep || this.newer && st.mtime > entry.mtime)) {\n      return this[SKIP](entry)\n    }\n\n    if (lstatEr || this[ISREUSABLE](entry, st)) {\n      return this[MAKEFS](null, entry)\n    }\n\n    if (st.isDirectory()) {\n      if (entry.type === 'Directory') {\n        const needChmod = !this.noChmod &&\n          entry.mode &&\n          (st.mode & 0o7777) !== entry.mode\n        const [er] = needChmod ? callSync(() => {\n          fs.chmodSync(entry.absolute, entry.mode)\n        }) : []\n        return this[MAKEFS](er, entry)\n      }\n      // not a dir entry, have to remove it\n      const [er] = callSync(() => fs.rmdirSync(entry.absolute))\n      this[MAKEFS](er, entry)\n    }\n\n    // not a dir, and not reusable.\n    // don't remove if it's the cwd, since we want that error.\n    const [er] = entry.absolute === this.cwd ? []\n      : callSync(() => unlinkFileSync(entry.absolute))\n    this[MAKEFS](er, entry)\n  }\n\n  [FILE] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.fmode\n\n    const oner = er => {\n      let closeError\n      try {\n        fs.closeSync(fd)\n      } catch (e) {\n        closeError = e\n      }\n      if (er || closeError) {\n        this[ONERROR](er || closeError, entry)\n      }\n      done()\n    }\n\n    let fd\n    try {\n      fd = fs.openSync(entry.absolute, getFlag(entry.size), mode)\n    } catch (er) {\n      return oner(er)\n    }\n    const tx = this.transform ? this.transform(entry) || entry : entry\n    if (tx !== entry) {\n      tx.on('error', er => this[ONERROR](er, entry))\n      entry.pipe(tx)\n    }\n\n    tx.on('data', chunk => {\n      try {\n        fs.writeSync(fd, chunk, 0, chunk.length)\n      } catch (er) {\n        oner(er)\n      }\n    })\n\n    tx.on('end', _ => {\n      let er = null\n      // try both, falling futimes back to utimes\n      // if either fails, handle the first error\n      if (entry.mtime && !this.noMtime) {\n        const atime = entry.atime || new Date()\n        const mtime = entry.mtime\n        try {\n          fs.futimesSync(fd, atime, mtime)\n        } catch (futimeser) {\n          try {\n            fs.utimesSync(entry.absolute, atime, mtime)\n          } catch (utimeser) {\n            er = futimeser\n          }\n        }\n      }\n\n      if (this[DOCHOWN](entry)) {\n        const uid = this[UID](entry)\n        const gid = this[GID](entry)\n\n        try {\n          fs.fchownSync(fd, uid, gid)\n        } catch (fchowner) {\n          try {\n            fs.chownSync(entry.absolute, uid, gid)\n          } catch (chowner) {\n            er = er || fchowner\n          }\n        }\n      }\n\n      oner(er)\n    })\n  }\n\n  [DIRECTORY] (entry, done) {\n    const mode = entry.mode & 0o7777 || this.dmode\n    const er = this[MKDIR](entry.absolute, mode)\n    if (er) {\n      this[ONERROR](er, entry)\n      done()\n      return\n    }\n    if (entry.mtime && !this.noMtime) {\n      try {\n        fs.utimesSync(entry.absolute, entry.atime || new Date(), entry.mtime)\n      } catch (er) {}\n    }\n    if (this[DOCHOWN](entry)) {\n      try {\n        fs.chownSync(entry.absolute, this[UID](entry), this[GID](entry))\n      } catch (er) {}\n    }\n    done()\n    entry.resume()\n  }\n\n  [MKDIR] (dir, mode) {\n    try {\n      return mkdir.sync(normPath(dir), {\n        uid: this.uid,\n        gid: this.gid,\n        processUid: this.processUid,\n        processGid: this.processGid,\n        umask: this.processUmask,\n        preserve: this.preservePaths,\n        unlink: this.unlink,\n        cache: this.dirCache,\n        cwd: this.cwd,\n        mode: mode,\n      })\n    } catch (er) {\n      return er\n    }\n  }\n\n  [LINK] (entry, linkpath, link, done) {\n    try {\n      fs[link + 'Sync'](linkpath, entry.absolute)\n      done()\n      entry.resume()\n    } catch (er) {\n      return this[ONERROR](er, entry)\n    }\n  }\n}\n\nUnpack.Sync = UnpackSync\nmodule.exports = Unpack\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi91bnBhY2suanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLG1CQUFPLENBQUMsc0JBQVE7QUFDL0IsZUFBZSxtQkFBTyxDQUFDLG1EQUFZO0FBQ25DLFdBQVcsbUJBQU8sQ0FBQyxjQUFJO0FBQ3ZCLFlBQVksbUJBQU8sQ0FBQyx3REFBYTtBQUNqQyxhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsY0FBYyxtQkFBTyxDQUFDLG1EQUFZO0FBQ2xDLFdBQVcsbUJBQU8sQ0FBQyx5REFBZTtBQUNsQyx5QkFBeUIsbUJBQU8sQ0FBQywyRUFBd0I7QUFDekQsMEJBQTBCLG1CQUFPLENBQUMsK0VBQTBCO0FBQzVELGlCQUFpQixtQkFBTyxDQUFDLHFGQUE2QjtBQUN0RCxtQkFBbUIsbUJBQU8sQ0FBQyxxRkFBNkI7QUFDeEQsa0JBQWtCLG1CQUFPLENBQUMsMkVBQXdCOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixnQkFBZ0IsbUJBQU8sQ0FBQyxxRUFBcUI7QUFDN0MsaUJBQWlCLEVBQVc7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELE1BQU07QUFDdkQ7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0EsY0FBYyxjQUFjO0FBQzVCO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLHlDQUF5QyxPQUFPO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLG9DQUFvQztBQUNwQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFdBQVcsS0FBSyxPQUFPO0FBQ3hEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL3VucGFjay5qcz9iNWNjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyB0aGUgUEVORC9VTlBFTkQgc3R1ZmYgdHJhY2tzIHdoZXRoZXIgd2UncmUgcmVhZHkgdG8gZW1pdCBlbmQvY2xvc2UgeWV0LlxuLy8gYnV0IHRoZSBwYXRoIHJlc2VydmF0aW9ucyBhcmUgcmVxdWlyZWQgdG8gYXZvaWQgcmFjZSBjb25kaXRpb25zIHdoZXJlXG4vLyBwYXJhbGxlbGl6ZWQgdW5wYWNrIG9wcyBtYXkgbWVzcyB3aXRoIG9uZSBhbm90aGVyLCBkdWUgdG8gZGVwZW5kZW5jaWVzXG4vLyAobGlrZSBhIExpbmsgZGVwZW5kaW5nIG9uIGl0cyB0YXJnZXQpIG9yIGRlc3RydWN0aXZlIG9wZXJhdGlvbnMgKGxpa2Vcbi8vIGNsb2JiZXJpbmcgYW4gZnMgb2JqZWN0IHRvIGNyZWF0ZSBvbmUgb2YgYSBkaWZmZXJlbnQgdHlwZS4pXG5cbmNvbnN0IGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpXG5jb25zdCBQYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlLmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgZnNtID0gcmVxdWlyZSgnZnMtbWluaXBhc3MnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3QgbWtkaXIgPSByZXF1aXJlKCcuL21rZGlyLmpzJylcbmNvbnN0IHdjID0gcmVxdWlyZSgnLi93aW5jaGFycy5qcycpXG5jb25zdCBwYXRoUmVzZXJ2YXRpb25zID0gcmVxdWlyZSgnLi9wYXRoLXJlc2VydmF0aW9ucy5qcycpXG5jb25zdCBzdHJpcEFic29sdXRlUGF0aCA9IHJlcXVpcmUoJy4vc3RyaXAtYWJzb2x1dGUtcGF0aC5qcycpXG5jb25zdCBub3JtUGF0aCA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXdpbmRvd3MtcGF0aC5qcycpXG5jb25zdCBzdHJpcFNsYXNoID0gcmVxdWlyZSgnLi9zdHJpcC10cmFpbGluZy1zbGFzaGVzLmpzJylcbmNvbnN0IG5vcm1hbGl6ZSA9IHJlcXVpcmUoJy4vbm9ybWFsaXplLXVuaWNvZGUuanMnKVxuXG5jb25zdCBPTkVOVFJZID0gU3ltYm9sKCdvbkVudHJ5JylcbmNvbnN0IENIRUNLRlMgPSBTeW1ib2woJ2NoZWNrRnMnKVxuY29uc3QgQ0hFQ0tGUzIgPSBTeW1ib2woJ2NoZWNrRnMyJylcbmNvbnN0IFBSVU5FQ0FDSEUgPSBTeW1ib2woJ3BydW5lQ2FjaGUnKVxuY29uc3QgSVNSRVVTQUJMRSA9IFN5bWJvbCgnaXNSZXVzYWJsZScpXG5jb25zdCBNQUtFRlMgPSBTeW1ib2woJ21ha2VGcycpXG5jb25zdCBGSUxFID0gU3ltYm9sKCdmaWxlJylcbmNvbnN0IERJUkVDVE9SWSA9IFN5bWJvbCgnZGlyZWN0b3J5JylcbmNvbnN0IExJTksgPSBTeW1ib2woJ2xpbmsnKVxuY29uc3QgU1lNTElOSyA9IFN5bWJvbCgnc3ltbGluaycpXG5jb25zdCBIQVJETElOSyA9IFN5bWJvbCgnaGFyZGxpbmsnKVxuY29uc3QgVU5TVVBQT1JURUQgPSBTeW1ib2woJ3Vuc3VwcG9ydGVkJylcbmNvbnN0IENIRUNLUEFUSCA9IFN5bWJvbCgnY2hlY2tQYXRoJylcbmNvbnN0IE1LRElSID0gU3ltYm9sKCdta2RpcicpXG5jb25zdCBPTkVSUk9SID0gU3ltYm9sKCdvbkVycm9yJylcbmNvbnN0IFBFTkRJTkcgPSBTeW1ib2woJ3BlbmRpbmcnKVxuY29uc3QgUEVORCA9IFN5bWJvbCgncGVuZCcpXG5jb25zdCBVTlBFTkQgPSBTeW1ib2woJ3VucGVuZCcpXG5jb25zdCBFTkRFRCA9IFN5bWJvbCgnZW5kZWQnKVxuY29uc3QgTUFZQkVDTE9TRSA9IFN5bWJvbCgnbWF5YmVDbG9zZScpXG5jb25zdCBTS0lQID0gU3ltYm9sKCdza2lwJylcbmNvbnN0IERPQ0hPV04gPSBTeW1ib2woJ2RvQ2hvd24nKVxuY29uc3QgVUlEID0gU3ltYm9sKCd1aWQnKVxuY29uc3QgR0lEID0gU3ltYm9sKCdnaWQnKVxuY29uc3QgQ0hFQ0tFRF9DV0QgPSBTeW1ib2woJ2NoZWNrZWRDd2QnKVxuY29uc3QgY3J5cHRvID0gcmVxdWlyZSgnY3J5cHRvJylcbmNvbnN0IGdldEZsYWcgPSByZXF1aXJlKCcuL2dldC13cml0ZS1mbGFnLmpzJylcbmNvbnN0IHBsYXRmb3JtID0gcHJvY2Vzcy5lbnYuVEVTVElOR19UQVJfRkFLRV9QTEFURk9STSB8fCBwcm9jZXNzLnBsYXRmb3JtXG5jb25zdCBpc1dpbmRvd3MgPSBwbGF0Zm9ybSA9PT0gJ3dpbjMyJ1xuY29uc3QgREVGQVVMVF9NQVhfREVQVEggPSAxMDI0XG5cbi8vIFVubGlua3Mgb24gV2luZG93cyBhcmUgbm90IGF0b21pYy5cbi8vXG4vLyBUaGlzIG1lYW5zIHRoYXQgaWYgeW91IGhhdmUgYSBmaWxlIGVudHJ5LCBmb2xsb3dlZCBieSBhbm90aGVyXG4vLyBmaWxlIGVudHJ5IHdpdGggYW4gaWRlbnRpY2FsIG5hbWUsIGFuZCB5b3UgY2Fubm90IHJlLXVzZSB0aGUgZmlsZVxuLy8gKGJlY2F1c2UgaXQncyBhIGhhcmRsaW5rLCBvciBiZWNhdXNlIHVubGluazp0cnVlIGlzIHNldCwgb3IgaXQnc1xuLy8gV2luZG93cywgd2hpY2ggZG9lcyBub3QgaGF2ZSB1c2VmdWwgbmxpbmsgdmFsdWVzKSwgdGhlbiB0aGUgdW5saW5rXG4vLyB3aWxsIGJlIGNvbW1pdHRlZCB0byB0aGUgZGlzayBBRlRFUiB0aGUgbmV3IGZpbGUgaGFzIGJlZW4gd3JpdHRlblxuLy8gb3ZlciB0aGUgb2xkIG9uZSwgZGVsZXRpbmcgdGhlIG5ldyBmaWxlLlxuLy9cbi8vIFRvIHdvcmsgYXJvdW5kIHRoaXMsIG9uIFdpbmRvd3Mgc3lzdGVtcywgd2UgcmVuYW1lIHRoZSBmaWxlIGFuZCB0aGVuXG4vLyBkZWxldGUgdGhlIHJlbmFtZWQgZmlsZS4gIEl0J3MgYSBzbG9wcHkga2x1ZGdlLCBidXQgZnJhbmtseSwgSSBkbyBub3Rcbi8vIGtub3cgb2YgYSBiZXR0ZXIgd2F5IHRvIGRvIHRoaXMsIGdpdmVuIHdpbmRvd3MnIG5vbi1hdG9taWMgdW5saW5rXG4vLyBzZW1hbnRpY3MuXG4vL1xuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vbnBtL25vZGUtdGFyL2lzc3Vlcy8xODNcbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5jb25zdCB1bmxpbmtGaWxlID0gKHBhdGgsIGNiKSA9PiB7XG4gIGlmICghaXNXaW5kb3dzKSB7XG4gICAgcmV0dXJuIGZzLnVubGluayhwYXRoLCBjYilcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSBwYXRoICsgJy5ERUxFVEUuJyArIGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2hleCcpXG4gIGZzLnJlbmFtZShwYXRoLCBuYW1lLCBlciA9PiB7XG4gICAgaWYgKGVyKSB7XG4gICAgICByZXR1cm4gY2IoZXIpXG4gICAgfVxuICAgIGZzLnVubGluayhuYW1lLCBjYilcbiAgfSlcbn1cblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmNvbnN0IHVubGlua0ZpbGVTeW5jID0gcGF0aCA9PiB7XG4gIGlmICghaXNXaW5kb3dzKSB7XG4gICAgcmV0dXJuIGZzLnVubGlua1N5bmMocGF0aClcbiAgfVxuXG4gIGNvbnN0IG5hbWUgPSBwYXRoICsgJy5ERUxFVEUuJyArIGNyeXB0by5yYW5kb21CeXRlcygxNikudG9TdHJpbmcoJ2hleCcpXG4gIGZzLnJlbmFtZVN5bmMocGF0aCwgbmFtZSlcbiAgZnMudW5saW5rU3luYyhuYW1lKVxufVxuXG4vLyB0aGlzLmdpZCwgZW50cnkuZ2lkLCB0aGlzLnByb2Nlc3NVaWRcbmNvbnN0IHVpbnQzMiA9IChhLCBiLCBjKSA9PlxuICBhID09PSBhID4+PiAwID8gYVxuICA6IGIgPT09IGIgPj4+IDAgPyBiXG4gIDogY1xuXG4vLyBjbGVhciB0aGUgY2FjaGUgaWYgaXQncyBhIGNhc2UtaW5zZW5zaXRpdmUgdW5pY29kZS1zcXVhc2hpbmcgbWF0Y2guXG4vLyB3ZSBjYW4ndCBrbm93IGlmIHRoZSBjdXJyZW50IGZpbGUgc3lzdGVtIGlzIGNhc2Utc2Vuc2l0aXZlIG9yIHN1cHBvcnRzXG4vLyB1bmljb2RlIGZ1bGx5LCBzbyB3ZSBjaGVjayBmb3Igc2ltaWxhcml0eSBvbiB0aGUgbWF4aW1hbGx5IGNvbXBhdGlibGVcbi8vIHJlcHJlc2VudGF0aW9uLiAgRXJyIG9uIHRoZSBzaWRlIG9mIHBydW5pbmcsIHNpbmNlIGFsbCBpdCdzIGRvaW5nIGlzXG4vLyBwcmV2ZW50aW5nIGxzdGF0cywgYW5kIGl0J3Mgbm90IHRoZSBlbmQgb2YgdGhlIHdvcmxkIGlmIHdlIGdldCBhIGZhbHNlXG4vLyBwb3NpdGl2ZS5cbi8vIE5vdGUgdGhhdCBvbiB3aW5kb3dzLCB3ZSBhbHdheXMgZHJvcCB0aGUgZW50aXJlIGNhY2hlIHdoZW5ldmVyIGFcbi8vIHN5bWJvbGljIGxpbmsgaXMgZW5jb3VudGVyZWQsIGJlY2F1c2UgOC4zIGZpbGVuYW1lcyBhcmUgaW1wb3NzaWJsZVxuLy8gdG8gcmVhc29uIGFib3V0LCBhbmQgY29sbGlzaW9ucyBhcmUgaGF6YXJkcyByYXRoZXIgdGhhbiBqdXN0IGZhaWx1cmVzLlxuY29uc3QgY2FjaGVLZXlOb3JtYWxpemUgPSBwYXRoID0+IHN0cmlwU2xhc2gobm9ybVBhdGgobm9ybWFsaXplKHBhdGgpKSlcbiAgLnRvTG93ZXJDYXNlKClcblxuY29uc3QgcHJ1bmVDYWNoZSA9IChjYWNoZSwgYWJzKSA9PiB7XG4gIGFicyA9IGNhY2hlS2V5Tm9ybWFsaXplKGFicylcbiAgZm9yIChjb25zdCBwYXRoIG9mIGNhY2hlLmtleXMoKSkge1xuICAgIGNvbnN0IHBub3JtID0gY2FjaGVLZXlOb3JtYWxpemUocGF0aClcbiAgICBpZiAocG5vcm0gPT09IGFicyB8fCBwbm9ybS5pbmRleE9mKGFicyArICcvJykgPT09IDApIHtcbiAgICAgIGNhY2hlLmRlbGV0ZShwYXRoKVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBkcm9wQ2FjaGUgPSBjYWNoZSA9PiB7XG4gIGZvciAoY29uc3Qga2V5IG9mIGNhY2hlLmtleXMoKSkge1xuICAgIGNhY2hlLmRlbGV0ZShrZXkpXG4gIH1cbn1cblxuY2xhc3MgVW5wYWNrIGV4dGVuZHMgUGFyc2VyIHtcbiAgY29uc3RydWN0b3IgKG9wdCkge1xuICAgIGlmICghb3B0KSB7XG4gICAgICBvcHQgPSB7fVxuICAgIH1cblxuICAgIG9wdC5vbmRvbmUgPSBfID0+IHtcbiAgICAgIHRoaXNbRU5ERURdID0gdHJ1ZVxuICAgICAgdGhpc1tNQVlCRUNMT1NFXSgpXG4gICAgfVxuXG4gICAgc3VwZXIob3B0KVxuXG4gICAgdGhpc1tDSEVDS0VEX0NXRF0gPSBmYWxzZVxuXG4gICAgdGhpcy5yZXNlcnZhdGlvbnMgPSBwYXRoUmVzZXJ2YXRpb25zKClcblxuICAgIHRoaXMudHJhbnNmb3JtID0gdHlwZW9mIG9wdC50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicgPyBvcHQudHJhbnNmb3JtIDogbnVsbFxuXG4gICAgdGhpcy53cml0YWJsZSA9IHRydWVcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2VcblxuICAgIHRoaXNbUEVORElOR10gPSAwXG4gICAgdGhpc1tFTkRFRF0gPSBmYWxzZVxuXG4gICAgdGhpcy5kaXJDYWNoZSA9IG9wdC5kaXJDYWNoZSB8fCBuZXcgTWFwKClcblxuICAgIGlmICh0eXBlb2Ygb3B0LnVpZCA9PT0gJ251bWJlcicgfHwgdHlwZW9mIG9wdC5naWQgPT09ICdudW1iZXInKSB7XG4gICAgICAvLyBuZWVkIGJvdGggb3IgbmVpdGhlclxuICAgICAgaWYgKHR5cGVvZiBvcHQudWlkICE9PSAnbnVtYmVyJyB8fCB0eXBlb2Ygb3B0LmdpZCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2Fubm90IHNldCBvd25lciB3aXRob3V0IG51bWJlciB1aWQgYW5kIGdpZCcpXG4gICAgICB9XG4gICAgICBpZiAob3B0LnByZXNlcnZlT3duZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAnY2Fubm90IHByZXNlcnZlIG93bmVyIGluIGFyY2hpdmUgYW5kIGFsc28gc2V0IG93bmVyIGV4cGxpY2l0bHknKVxuICAgICAgfVxuICAgICAgdGhpcy51aWQgPSBvcHQudWlkXG4gICAgICB0aGlzLmdpZCA9IG9wdC5naWRcbiAgICAgIHRoaXMuc2V0T3duZXIgPSB0cnVlXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMudWlkID0gbnVsbFxuICAgICAgdGhpcy5naWQgPSBudWxsXG4gICAgICB0aGlzLnNldE93bmVyID0gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBkZWZhdWx0IHRydWUgZm9yIHJvb3RcbiAgICBpZiAob3B0LnByZXNlcnZlT3duZXIgPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb3B0LnVpZCAhPT0gJ251bWJlcicpIHtcbiAgICAgIHRoaXMucHJlc2VydmVPd25lciA9IHByb2Nlc3MuZ2V0dWlkICYmIHByb2Nlc3MuZ2V0dWlkKCkgPT09IDBcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5wcmVzZXJ2ZU93bmVyID0gISFvcHQucHJlc2VydmVPd25lclxuICAgIH1cblxuICAgIHRoaXMucHJvY2Vzc1VpZCA9ICh0aGlzLnByZXNlcnZlT3duZXIgfHwgdGhpcy5zZXRPd25lcikgJiYgcHJvY2Vzcy5nZXR1aWQgP1xuICAgICAgcHJvY2Vzcy5nZXR1aWQoKSA6IG51bGxcbiAgICB0aGlzLnByb2Nlc3NHaWQgPSAodGhpcy5wcmVzZXJ2ZU93bmVyIHx8IHRoaXMuc2V0T3duZXIpICYmIHByb2Nlc3MuZ2V0Z2lkID9cbiAgICAgIHByb2Nlc3MuZ2V0Z2lkKCkgOiBudWxsXG5cbiAgICAvLyBwcmV2ZW50IGV4Y2Vzc2l2ZWx5IGRlZXAgbmVzdGluZyBvZiBzdWJmb2xkZXJzXG4gICAgLy8gc2V0IHRvIGBJbmZpbml0eWAgdG8gcmVtb3ZlIHRoaXMgcmVzdHJpY3Rpb25cbiAgICB0aGlzLm1heERlcHRoID0gdHlwZW9mIG9wdC5tYXhEZXB0aCA9PT0gJ251bWJlcidcbiAgICAgID8gb3B0Lm1heERlcHRoXG4gICAgICA6IERFRkFVTFRfTUFYX0RFUFRIXG5cbiAgICAvLyBtb3N0bHkganVzdCBmb3IgdGVzdGluZywgYnV0IHVzZWZ1bCBpbiBzb21lIGNhc2VzLlxuICAgIC8vIEZvcmNpYmx5IHRyaWdnZXIgYSBjaG93biBvbiBldmVyeSBlbnRyeSwgbm8gbWF0dGVyIHdoYXRcbiAgICB0aGlzLmZvcmNlQ2hvd24gPSBvcHQuZm9yY2VDaG93biA9PT0gdHJ1ZVxuXG4gICAgLy8gdHVybiA+PD98IGluIGZpbGVuYW1lcyBpbnRvIDB4ZjAwMC1oaWdoZXIgZW5jb2RlZCBmb3Jtc1xuICAgIHRoaXMud2luMzIgPSAhIW9wdC53aW4zMiB8fCBpc1dpbmRvd3NcblxuICAgIC8vIGRvIG5vdCB1bnBhY2sgb3ZlciBmaWxlcyB0aGF0IGFyZSBuZXdlciB0aGFuIHdoYXQncyBpbiB0aGUgYXJjaGl2ZVxuICAgIHRoaXMubmV3ZXIgPSAhIW9wdC5uZXdlclxuXG4gICAgLy8gZG8gbm90IHVucGFjayBvdmVyIEFOWSBmaWxlc1xuICAgIHRoaXMua2VlcCA9ICEhb3B0LmtlZXBcblxuICAgIC8vIGRvIG5vdCBzZXQgbXRpbWUvYXRpbWUgb2YgZXh0cmFjdGVkIGVudHJpZXNcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG5cbiAgICAvLyBhbGxvdyAuLiwgYWJzb2x1dGUgcGF0aCBlbnRyaWVzLCBhbmQgdW5wYWNraW5nIHRocm91Z2ggc3ltbGlua3NcbiAgICAvLyB3aXRob3V0IHRoaXMsIHdhcm4gYW5kIHNraXAgLi4sIHJlbGF0aXZpemUgYWJzb2x1dGVzLCBhbmQgZXJyb3JcbiAgICAvLyBvbiBzeW1saW5rcyBpbiBleHRyYWN0aW9uIHBhdGhcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG5cbiAgICAvLyB1bmxpbmsgZmlsZXMgYW5kIGxpbmtzIGJlZm9yZSB3cml0aW5nLiBUaGlzIGJyZWFrcyBleGlzdGluZyBoYXJkXG4gICAgLy8gbGlua3MsIGFuZCByZW1vdmVzIHN5bWxpbmsgZGlyZWN0b3JpZXMgcmF0aGVyIHRoYW4gZXJyb3JpbmdcbiAgICB0aGlzLnVubGluayA9ICEhb3B0LnVubGlua1xuXG4gICAgdGhpcy5jd2QgPSBub3JtUGF0aChwYXRoLnJlc29sdmUob3B0LmN3ZCB8fCBwcm9jZXNzLmN3ZCgpKSlcbiAgICB0aGlzLnN0cmlwID0gK29wdC5zdHJpcCB8fCAwXG4gICAgLy8gaWYgd2UncmUgbm90IGNobW9kZGluZywgdGhlbiB3ZSBkb24ndCBuZWVkIHRoZSBwcm9jZXNzIHVtYXNrXG4gICAgdGhpcy5wcm9jZXNzVW1hc2sgPSBvcHQubm9DaG1vZCA/IDAgOiBwcm9jZXNzLnVtYXNrKClcbiAgICB0aGlzLnVtYXNrID0gdHlwZW9mIG9wdC51bWFzayA9PT0gJ251bWJlcicgPyBvcHQudW1hc2sgOiB0aGlzLnByb2Nlc3NVbWFza1xuXG4gICAgLy8gZGVmYXVsdCBtb2RlIGZvciBkaXJzIGNyZWF0ZWQgYXMgcGFyZW50c1xuICAgIHRoaXMuZG1vZGUgPSBvcHQuZG1vZGUgfHwgKDBvMDc3NyAmICh+dGhpcy51bWFzaykpXG4gICAgdGhpcy5mbW9kZSA9IG9wdC5mbW9kZSB8fCAoMG8wNjY2ICYgKH50aGlzLnVtYXNrKSlcblxuICAgIHRoaXMub24oJ2VudHJ5JywgZW50cnkgPT4gdGhpc1tPTkVOVFJZXShlbnRyeSkpXG4gIH1cblxuICAvLyBhIGJhZCBvciBkYW1hZ2VkIGFyY2hpdmUgaXMgYSB3YXJuaW5nIGZvciBQYXJzZXIsIGJ1dCBhbiBlcnJvclxuICAvLyB3aGVuIGV4dHJhY3RpbmcuICBNYXJrIHRob3NlIGVycm9ycyBhcyB1bnJlY292ZXJhYmxlLCBiZWNhdXNlXG4gIC8vIHRoZSBVbnBhY2sgY29udHJhY3QgY2Fubm90IGJlIG1ldC5cbiAgd2FybiAoY29kZSwgbXNnLCBkYXRhID0ge30pIHtcbiAgICBpZiAoY29kZSA9PT0gJ1RBUl9CQURfQVJDSElWRScgfHwgY29kZSA9PT0gJ1RBUl9BQk9SVCcpIHtcbiAgICAgIGRhdGEucmVjb3ZlcmFibGUgPSBmYWxzZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIud2Fybihjb2RlLCBtc2csIGRhdGEpXG4gIH1cblxuICBbTUFZQkVDTE9TRV0gKCkge1xuICAgIGlmICh0aGlzW0VOREVEXSAmJiB0aGlzW1BFTkRJTkddID09PSAwKSB7XG4gICAgICB0aGlzLmVtaXQoJ3ByZWZpbmlzaCcpXG4gICAgICB0aGlzLmVtaXQoJ2ZpbmlzaCcpXG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpXG4gICAgfVxuICB9XG5cbiAgW0NIRUNLUEFUSF0gKGVudHJ5KSB7XG4gICAgY29uc3QgcCA9IG5vcm1QYXRoKGVudHJ5LnBhdGgpXG4gICAgY29uc3QgcGFydHMgPSBwLnNwbGl0KCcvJylcblxuICAgIGlmICh0aGlzLnN0cmlwKSB7XG4gICAgICBpZiAocGFydHMubGVuZ3RoIDwgdGhpcy5zdHJpcCkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS50eXBlID09PSAnTGluaycpIHtcbiAgICAgICAgY29uc3QgbGlua3BhcnRzID0gbm9ybVBhdGgoZW50cnkubGlua3BhdGgpLnNwbGl0KCcvJylcbiAgICAgICAgaWYgKGxpbmtwYXJ0cy5sZW5ndGggPj0gdGhpcy5zdHJpcCkge1xuICAgICAgICAgIGVudHJ5LmxpbmtwYXRoID0gbGlua3BhcnRzLnNsaWNlKHRoaXMuc3RyaXApLmpvaW4oJy8nKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXJ0cy5zcGxpY2UoMCwgdGhpcy5zdHJpcClcbiAgICAgIGVudHJ5LnBhdGggPSBwYXJ0cy5qb2luKCcvJylcbiAgICB9XG5cbiAgICBpZiAoaXNGaW5pdGUodGhpcy5tYXhEZXB0aCkgJiYgcGFydHMubGVuZ3RoID4gdGhpcy5tYXhEZXB0aCkge1xuICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfRVJST1InLCAncGF0aCBleGNlc3NpdmVseSBkZWVwJywge1xuICAgICAgICBlbnRyeSxcbiAgICAgICAgcGF0aDogcCxcbiAgICAgICAgZGVwdGg6IHBhcnRzLmxlbmd0aCxcbiAgICAgICAgbWF4RGVwdGg6IHRoaXMubWF4RGVwdGgsXG4gICAgICB9KVxuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgIGlmIChwYXJ0cy5pbmNsdWRlcygnLi4nKSB8fCBpc1dpbmRvd3MgJiYgL15bYS16XTpcXC5cXC4kL2kudGVzdChwYXJ0c1swXSkpIHtcbiAgICAgICAgdGhpcy53YXJuKCdUQVJfRU5UUllfRVJST1InLCBgcGF0aCBjb250YWlucyAnLi4nYCwge1xuICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgIHBhdGg6IHAsXG4gICAgICAgIH0pXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuXG4gICAgICAvLyBzdHJpcCBvZmYgdGhlIHJvb3RcbiAgICAgIGNvbnN0IFtyb290LCBzdHJpcHBlZF0gPSBzdHJpcEFic29sdXRlUGF0aChwKVxuICAgICAgaWYgKHJvb3QpIHtcbiAgICAgICAgZW50cnkucGF0aCA9IHN0cmlwcGVkXG4gICAgICAgIHRoaXMud2FybignVEFSX0VOVFJZX0lORk8nLCBgc3RyaXBwaW5nICR7cm9vdH0gZnJvbSBhYnNvbHV0ZSBwYXRoYCwge1xuICAgICAgICAgIGVudHJ5LFxuICAgICAgICAgIHBhdGg6IHAsXG4gICAgICAgIH0pXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBhdGguaXNBYnNvbHV0ZShlbnRyeS5wYXRoKSkge1xuICAgICAgZW50cnkuYWJzb2x1dGUgPSBub3JtUGF0aChwYXRoLnJlc29sdmUoZW50cnkucGF0aCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIGVudHJ5LmFic29sdXRlID0gbm9ybVBhdGgocGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBlbnRyeS5wYXRoKSlcbiAgICB9XG5cbiAgICAvLyBpZiB3ZSBzb21laG93IGVuZGVkIHVwIHdpdGggYSBwYXRoIHRoYXQgZXNjYXBlcyB0aGUgY3dkLCBhbmQgd2UgYXJlXG4gICAgLy8gbm90IGluIHByZXNlcnZlUGF0aHMgbW9kZSwgdGhlbiBzb21ldGhpbmcgaXMgZmlzaHkhICBUaGlzIHNob3VsZCBoYXZlXG4gICAgLy8gYmVlbiBwcmV2ZW50ZWQgYWJvdmUsIHNvIGlnbm9yZSB0aGlzIGZvciBjb3ZlcmFnZS5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgLSBkZWZlbnNlIGluIGRlcHRoICovXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMgJiZcbiAgICAgICAgZW50cnkuYWJzb2x1dGUuaW5kZXhPZih0aGlzLmN3ZCArICcvJykgIT09IDAgJiZcbiAgICAgICAgZW50cnkuYWJzb2x1dGUgIT09IHRoaXMuY3dkKSB7XG4gICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9FUlJPUicsICdwYXRoIGVzY2FwZWQgZXh0cmFjdGlvbiB0YXJnZXQnLCB7XG4gICAgICAgIGVudHJ5LFxuICAgICAgICBwYXRoOiBub3JtUGF0aChlbnRyeS5wYXRoKSxcbiAgICAgICAgcmVzb2x2ZWRQYXRoOiBlbnRyeS5hYnNvbHV0ZSxcbiAgICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIH0pXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG5cbiAgICAvLyBhbiBhcmNoaXZlIGNhbiBzZXQgcHJvcGVydGllcyBvbiB0aGUgZXh0cmFjdGlvbiBkaXJlY3RvcnksIGJ1dCBpdFxuICAgIC8vIG1heSBub3QgcmVwbGFjZSB0aGUgY3dkIHdpdGggYSBkaWZmZXJlbnQga2luZCBvZiB0aGluZyBlbnRpcmVseS5cbiAgICBpZiAoZW50cnkuYWJzb2x1dGUgPT09IHRoaXMuY3dkICYmXG4gICAgICAgIGVudHJ5LnR5cGUgIT09ICdEaXJlY3RvcnknICYmXG4gICAgICAgIGVudHJ5LnR5cGUgIT09ICdHTlVEdW1wRGlyJykge1xuICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLy8gb25seSBlbmNvZGUgOiBjaGFycyB0aGF0IGFyZW4ndCBkcml2ZSBsZXR0ZXIgaW5kaWNhdG9yc1xuICAgIGlmICh0aGlzLndpbjMyKSB7XG4gICAgICBjb25zdCB7IHJvb3Q6IGFSb290IH0gPSBwYXRoLndpbjMyLnBhcnNlKGVudHJ5LmFic29sdXRlKVxuICAgICAgZW50cnkuYWJzb2x1dGUgPSBhUm9vdCArIHdjLmVuY29kZShlbnRyeS5hYnNvbHV0ZS5zbGljZShhUm9vdC5sZW5ndGgpKVxuICAgICAgY29uc3QgeyByb290OiBwUm9vdCB9ID0gcGF0aC53aW4zMi5wYXJzZShlbnRyeS5wYXRoKVxuICAgICAgZW50cnkucGF0aCA9IHBSb290ICsgd2MuZW5jb2RlKGVudHJ5LnBhdGguc2xpY2UocFJvb3QubGVuZ3RoKSlcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgW09ORU5UUlldIChlbnRyeSkge1xuICAgIGlmICghdGhpc1tDSEVDS1BBVEhdKGVudHJ5KSkge1xuICAgICAgcmV0dXJuIGVudHJ5LnJlc3VtZSgpXG4gICAgfVxuXG4gICAgYXNzZXJ0LmVxdWFsKHR5cGVvZiBlbnRyeS5hYnNvbHV0ZSwgJ3N0cmluZycpXG5cbiAgICBzd2l0Y2ggKGVudHJ5LnR5cGUpIHtcbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgaWYgKGVudHJ5Lm1vZGUpIHtcbiAgICAgICAgICBlbnRyeS5tb2RlID0gZW50cnkubW9kZSB8IDBvNzAwXG4gICAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnQ29udGlndW91c0ZpbGUnOlxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOlxuICAgICAgICByZXR1cm4gdGhpc1tDSEVDS0ZTXShlbnRyeSlcblxuICAgICAgY2FzZSAnQ2hhcmFjdGVyRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0Jsb2NrRGV2aWNlJzpcbiAgICAgIGNhc2UgJ0ZJRk8nOlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIHRoaXNbVU5TVVBQT1JURURdKGVudHJ5KVxuICAgIH1cbiAgfVxuXG4gIFtPTkVSUk9SXSAoZXIsIGVudHJ5KSB7XG4gICAgLy8gQ3dkIGhhcyB0byBleGlzdCwgb3IgZWxzZSBub3RoaW5nIHdvcmtzLiBUaGF0J3Mgc2VyaW91cy5cbiAgICAvLyBPdGhlciBlcnJvcnMgYXJlIHdhcm5pbmdzLCB3aGljaCByYWlzZSB0aGUgZXJyb3IgaW4gc3RyaWN0XG4gICAgLy8gbW9kZSwgYnV0IG90aGVyd2lzZSBjb250aW51ZSBvbi5cbiAgICBpZiAoZXIubmFtZSA9PT0gJ0N3ZEVycm9yJykge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIGVyKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9FUlJPUicsIGVyLCB7IGVudHJ5IH0pXG4gICAgICB0aGlzW1VOUEVORF0oKVxuICAgICAgZW50cnkucmVzdW1lKClcbiAgICB9XG4gIH1cblxuICBbTUtESVJdIChkaXIsIG1vZGUsIGNiKSB7XG4gICAgbWtkaXIobm9ybVBhdGgoZGlyKSwge1xuICAgICAgdWlkOiB0aGlzLnVpZCxcbiAgICAgIGdpZDogdGhpcy5naWQsXG4gICAgICBwcm9jZXNzVWlkOiB0aGlzLnByb2Nlc3NVaWQsXG4gICAgICBwcm9jZXNzR2lkOiB0aGlzLnByb2Nlc3NHaWQsXG4gICAgICB1bWFzazogdGhpcy5wcm9jZXNzVW1hc2ssXG4gICAgICBwcmVzZXJ2ZTogdGhpcy5wcmVzZXJ2ZVBhdGhzLFxuICAgICAgdW5saW5rOiB0aGlzLnVubGluayxcbiAgICAgIGNhY2hlOiB0aGlzLmRpckNhY2hlLFxuICAgICAgY3dkOiB0aGlzLmN3ZCxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBub0NobW9kOiB0aGlzLm5vQ2htb2QsXG4gICAgfSwgY2IpXG4gIH1cblxuICBbRE9DSE9XTl0gKGVudHJ5KSB7XG4gICAgLy8gaW4gcHJlc2VydmUgb3duZXIgbW9kZSwgY2hvd24gaWYgdGhlIGVudHJ5IGRvZXNuJ3QgbWF0Y2ggcHJvY2Vzc1xuICAgIC8vIGluIHNldCBvd25lciBtb2RlLCBjaG93biBpZiBzZXR0aW5nIGRvZXNuJ3QgbWF0Y2ggcHJvY2Vzc1xuICAgIHJldHVybiB0aGlzLmZvcmNlQ2hvd24gfHxcbiAgICAgIHRoaXMucHJlc2VydmVPd25lciAmJlxuICAgICAgKHR5cGVvZiBlbnRyeS51aWQgPT09ICdudW1iZXInICYmIGVudHJ5LnVpZCAhPT0gdGhpcy5wcm9jZXNzVWlkIHx8XG4gICAgICAgIHR5cGVvZiBlbnRyeS5naWQgPT09ICdudW1iZXInICYmIGVudHJ5LmdpZCAhPT0gdGhpcy5wcm9jZXNzR2lkKVxuICAgICAgfHxcbiAgICAgICh0eXBlb2YgdGhpcy51aWQgPT09ICdudW1iZXInICYmIHRoaXMudWlkICE9PSB0aGlzLnByb2Nlc3NVaWQgfHxcbiAgICAgICAgdHlwZW9mIHRoaXMuZ2lkID09PSAnbnVtYmVyJyAmJiB0aGlzLmdpZCAhPT0gdGhpcy5wcm9jZXNzR2lkKVxuICB9XG5cbiAgW1VJRF0gKGVudHJ5KSB7XG4gICAgcmV0dXJuIHVpbnQzMih0aGlzLnVpZCwgZW50cnkudWlkLCB0aGlzLnByb2Nlc3NVaWQpXG4gIH1cblxuICBbR0lEXSAoZW50cnkpIHtcbiAgICByZXR1cm4gdWludDMyKHRoaXMuZ2lkLCBlbnRyeS5naWQsIHRoaXMucHJvY2Vzc0dpZClcbiAgfVxuXG4gIFtGSUxFXSAoZW50cnksIGZ1bGx5RG9uZSkge1xuICAgIGNvbnN0IG1vZGUgPSBlbnRyeS5tb2RlICYgMG83Nzc3IHx8IHRoaXMuZm1vZGVcbiAgICBjb25zdCBzdHJlYW0gPSBuZXcgZnNtLldyaXRlU3RyZWFtKGVudHJ5LmFic29sdXRlLCB7XG4gICAgICBmbGFnczogZ2V0RmxhZyhlbnRyeS5zaXplKSxcbiAgICAgIG1vZGU6IG1vZGUsXG4gICAgICBhdXRvQ2xvc2U6IGZhbHNlLFxuICAgIH0pXG4gICAgc3RyZWFtLm9uKCdlcnJvcicsIGVyID0+IHtcbiAgICAgIGlmIChzdHJlYW0uZmQpIHtcbiAgICAgICAgZnMuY2xvc2Uoc3RyZWFtLmZkLCAoKSA9PiB7fSlcbiAgICAgIH1cblxuICAgICAgLy8gZmx1c2ggYWxsIHRoZSBkYXRhIG91dCBzbyB0aGF0IHdlIGFyZW4ndCBsZWZ0IGhhbmdpbmdcbiAgICAgIC8vIGlmIHRoZSBlcnJvciB3YXNuJ3QgYWN0dWFsbHkgZmF0YWwuICBvdGhlcndpc2UgdGhlIHBhcnNlXG4gICAgICAvLyBpcyBibG9ja2VkLCBhbmQgd2UgbmV2ZXIgcHJvY2VlZC5cbiAgICAgIHN0cmVhbS53cml0ZSA9ICgpID0+IHRydWVcbiAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgZnVsbHlEb25lKClcbiAgICB9KVxuXG4gICAgbGV0IGFjdGlvbnMgPSAxXG4gICAgY29uc3QgZG9uZSA9IGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAtIHdlIHNob3VsZCBhbHdheXMgaGF2ZSBhIGZkIGJ5IG5vdyAqL1xuICAgICAgICBpZiAoc3RyZWFtLmZkKSB7XG4gICAgICAgICAgZnMuY2xvc2Uoc3RyZWFtLmZkLCAoKSA9PiB7fSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgICBmdWxseURvbmUoKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKC0tYWN0aW9ucyA9PT0gMCkge1xuICAgICAgICBmcy5jbG9zZShzdHJlYW0uZmQsIGVyID0+IHtcbiAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzW1VOUEVORF0oKVxuICAgICAgICAgIH1cbiAgICAgICAgICBmdWxseURvbmUoKVxuICAgICAgICB9KVxuICAgICAgfVxuICAgIH1cblxuICAgIHN0cmVhbS5vbignZmluaXNoJywgXyA9PiB7XG4gICAgICAvLyBpZiBmdXRpbWVzIGZhaWxzLCB0cnkgdXRpbWVzXG4gICAgICAvLyBpZiB1dGltZXMgZmFpbHMsIGZhaWwgd2l0aCB0aGUgb3JpZ2luYWwgZXJyb3JcbiAgICAgIC8vIHNhbWUgZm9yIGZjaG93bi9jaG93blxuICAgICAgY29uc3QgYWJzID0gZW50cnkuYWJzb2x1dGVcbiAgICAgIGNvbnN0IGZkID0gc3RyZWFtLmZkXG5cbiAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgIGFjdGlvbnMrK1xuICAgICAgICBjb25zdCBhdGltZSA9IGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKClcbiAgICAgICAgY29uc3QgbXRpbWUgPSBlbnRyeS5tdGltZVxuICAgICAgICBmcy5mdXRpbWVzKGZkLCBhdGltZSwgbXRpbWUsIGVyID0+XG4gICAgICAgICAgZXIgPyBmcy51dGltZXMoYWJzLCBhdGltZSwgbXRpbWUsIGVyMiA9PiBkb25lKGVyMiAmJiBlcikpXG4gICAgICAgICAgOiBkb25lKCkpXG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzW0RPQ0hPV05dKGVudHJ5KSkge1xuICAgICAgICBhY3Rpb25zKytcbiAgICAgICAgY29uc3QgdWlkID0gdGhpc1tVSURdKGVudHJ5KVxuICAgICAgICBjb25zdCBnaWQgPSB0aGlzW0dJRF0oZW50cnkpXG4gICAgICAgIGZzLmZjaG93bihmZCwgdWlkLCBnaWQsIGVyID0+XG4gICAgICAgICAgZXIgPyBmcy5jaG93bihhYnMsIHVpZCwgZ2lkLCBlcjIgPT4gZG9uZShlcjIgJiYgZXIpKVxuICAgICAgICAgIDogZG9uZSgpKVxuICAgICAgfVxuXG4gICAgICBkb25lKClcbiAgICB9KVxuXG4gICAgY29uc3QgdHggPSB0aGlzLnRyYW5zZm9ybSA/IHRoaXMudHJhbnNmb3JtKGVudHJ5KSB8fCBlbnRyeSA6IGVudHJ5XG4gICAgaWYgKHR4ICE9PSBlbnRyeSkge1xuICAgICAgdHgub24oJ2Vycm9yJywgZXIgPT4ge1xuICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgICAgZnVsbHlEb25lKClcbiAgICAgIH0pXG4gICAgICBlbnRyeS5waXBlKHR4KVxuICAgIH1cbiAgICB0eC5waXBlKHN0cmVhbSlcbiAgfVxuXG4gIFtESVJFQ1RPUlldIChlbnRyeSwgZnVsbHlEb25lKSB7XG4gICAgY29uc3QgbW9kZSA9IGVudHJ5Lm1vZGUgJiAwbzc3NzcgfHwgdGhpcy5kbW9kZVxuICAgIHRoaXNbTUtESVJdKGVudHJ5LmFic29sdXRlLCBtb2RlLCBlciA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgICAgIGZ1bGx5RG9uZSgpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBsZXQgYWN0aW9ucyA9IDFcbiAgICAgIGNvbnN0IGRvbmUgPSBfID0+IHtcbiAgICAgICAgaWYgKC0tYWN0aW9ucyA9PT0gMCkge1xuICAgICAgICAgIGZ1bGx5RG9uZSgpXG4gICAgICAgICAgdGhpc1tVTlBFTkRdKClcbiAgICAgICAgICBlbnRyeS5yZXN1bWUoKVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChlbnRyeS5tdGltZSAmJiAhdGhpcy5ub010aW1lKSB7XG4gICAgICAgIGFjdGlvbnMrK1xuICAgICAgICBmcy51dGltZXMoZW50cnkuYWJzb2x1dGUsIGVudHJ5LmF0aW1lIHx8IG5ldyBEYXRlKCksIGVudHJ5Lm10aW1lLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tET0NIT1dOXShlbnRyeSkpIHtcbiAgICAgICAgYWN0aW9ucysrXG4gICAgICAgIGZzLmNob3duKGVudHJ5LmFic29sdXRlLCB0aGlzW1VJRF0oZW50cnkpLCB0aGlzW0dJRF0oZW50cnkpLCBkb25lKVxuICAgICAgfVxuXG4gICAgICBkb25lKClcbiAgICB9KVxuICB9XG5cbiAgW1VOU1VQUE9SVEVEXSAoZW50cnkpIHtcbiAgICBlbnRyeS51bnN1cHBvcnRlZCA9IHRydWVcbiAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9VTlNVUFBPUlRFRCcsXG4gICAgICBgdW5zdXBwb3J0ZWQgZW50cnkgdHlwZTogJHtlbnRyeS50eXBlfWAsIHsgZW50cnkgfSlcbiAgICBlbnRyeS5yZXN1bWUoKVxuICB9XG5cbiAgW1NZTUxJTktdIChlbnRyeSwgZG9uZSkge1xuICAgIHRoaXNbTElOS10oZW50cnksIGVudHJ5LmxpbmtwYXRoLCAnc3ltbGluaycsIGRvbmUpXG4gIH1cblxuICBbSEFSRExJTktdIChlbnRyeSwgZG9uZSkge1xuICAgIGNvbnN0IGxpbmtwYXRoID0gbm9ybVBhdGgocGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBlbnRyeS5saW5rcGF0aCkpXG4gICAgdGhpc1tMSU5LXShlbnRyeSwgbGlua3BhdGgsICdsaW5rJywgZG9uZSlcbiAgfVxuXG4gIFtQRU5EXSAoKSB7XG4gICAgdGhpc1tQRU5ESU5HXSsrXG4gIH1cblxuICBbVU5QRU5EXSAoKSB7XG4gICAgdGhpc1tQRU5ESU5HXS0tXG4gICAgdGhpc1tNQVlCRUNMT1NFXSgpXG4gIH1cblxuICBbU0tJUF0gKGVudHJ5KSB7XG4gICAgdGhpc1tVTlBFTkRdKClcbiAgICBlbnRyeS5yZXN1bWUoKVxuICB9XG5cbiAgLy8gQ2hlY2sgaWYgd2UgY2FuIHJldXNlIGFuIGV4aXN0aW5nIGZpbGVzeXN0ZW0gZW50cnkgc2FmZWx5IGFuZFxuICAvLyBvdmVyd3JpdGUgaXQsIHJhdGhlciB0aGFuIHVubGlua2luZyBhbmQgcmVjcmVhdGluZ1xuICAvLyBXaW5kb3dzIGRvZXNuJ3QgcmVwb3J0IGEgdXNlZnVsIG5saW5rLCBzbyB3ZSBqdXN0IG5ldmVyIHJldXNlIGVudHJpZXNcbiAgW0lTUkVVU0FCTEVdIChlbnRyeSwgc3QpIHtcbiAgICByZXR1cm4gZW50cnkudHlwZSA9PT0gJ0ZpbGUnICYmXG4gICAgICAhdGhpcy51bmxpbmsgJiZcbiAgICAgIHN0LmlzRmlsZSgpICYmXG4gICAgICBzdC5ubGluayA8PSAxICYmXG4gICAgICAhaXNXaW5kb3dzXG4gIH1cblxuICAvLyBjaGVjayBpZiBhIHRoaW5nIGlzIHRoZXJlLCBhbmQgaWYgc28sIHRyeSB0byBjbG9iYmVyIGl0XG4gIFtDSEVDS0ZTXSAoZW50cnkpIHtcbiAgICB0aGlzW1BFTkRdKClcbiAgICBjb25zdCBwYXRocyA9IFtlbnRyeS5wYXRoXVxuICAgIGlmIChlbnRyeS5saW5rcGF0aCkge1xuICAgICAgcGF0aHMucHVzaChlbnRyeS5saW5rcGF0aClcbiAgICB9XG4gICAgdGhpcy5yZXNlcnZhdGlvbnMucmVzZXJ2ZShwYXRocywgZG9uZSA9PiB0aGlzW0NIRUNLRlMyXShlbnRyeSwgZG9uZSkpXG4gIH1cblxuICBbUFJVTkVDQUNIRV0gKGVudHJ5KSB7XG4gICAgLy8gaWYgd2UgYXJlIG5vdCBjcmVhdGluZyBhIGRpcmVjdG9yeSwgYW5kIHRoZSBwYXRoIGlzIGluIHRoZSBkaXJDYWNoZSxcbiAgICAvLyB0aGVuIHRoYXQgbWVhbnMgd2UgYXJlIGFib3V0IHRvIGRlbGV0ZSB0aGUgZGlyZWN0b3J5IHdlIGNyZWF0ZWRcbiAgICAvLyBwcmV2aW91c2x5LCBhbmQgaXQgaXMgbm8gbG9uZ2VyIGdvaW5nIHRvIGJlIGEgZGlyZWN0b3J5LCBhbmQgbmVpdGhlclxuICAgIC8vIGlzIGFueSBvZiBpdHMgY2hpbGRyZW4uXG4gICAgLy8gSWYgYSBzeW1ib2xpYyBsaW5rIGlzIGVuY291bnRlcmVkLCBhbGwgYmV0cyBhcmUgb2ZmLiAgVGhlcmUgaXMgbm9cbiAgICAvLyByZWFzb25hYmxlIHdheSB0byBzYW5pdGl6ZSB0aGUgY2FjaGUgaW4gc3VjaCBhIHdheSB3ZSB3aWxsIGJlIGFibGUgdG9cbiAgICAvLyBhdm9pZCBoYXZpbmcgZmlsZXN5c3RlbSBjb2xsaXNpb25zLiAgSWYgdGhpcyBoYXBwZW5zIHdpdGggYSBub24tc3ltbGlua1xuICAgIC8vIGVudHJ5LCBpdCdsbCBqdXN0IGZhaWwgdG8gdW5wYWNrLCBidXQgYSBzeW1saW5rIHRvIGEgZGlyZWN0b3J5LCB1c2luZyBhblxuICAgIC8vIDguMyBzaG9ydG5hbWUgb3IgY2VydGFpbiB1bmljb2RlIGF0dGFja3MsIGNhbiBldmFkZSBkZXRlY3Rpb24gYW5kIGxlYWRcbiAgICAvLyB0byBhcmJpdHJhcnkgd3JpdGVzIHRvIGFueXdoZXJlIG9uIHRoZSBzeXN0ZW0uXG4gICAgaWYgKGVudHJ5LnR5cGUgPT09ICdTeW1ib2xpY0xpbmsnKSB7XG4gICAgICBkcm9wQ2FjaGUodGhpcy5kaXJDYWNoZSlcbiAgICB9IGVsc2UgaWYgKGVudHJ5LnR5cGUgIT09ICdEaXJlY3RvcnknKSB7XG4gICAgICBwcnVuZUNhY2hlKHRoaXMuZGlyQ2FjaGUsIGVudHJ5LmFic29sdXRlKVxuICAgIH1cbiAgfVxuXG4gIFtDSEVDS0ZTMl0gKGVudHJ5LCBmdWxseURvbmUpIHtcbiAgICB0aGlzW1BSVU5FQ0FDSEVdKGVudHJ5KVxuXG4gICAgY29uc3QgZG9uZSA9IGVyID0+IHtcbiAgICAgIHRoaXNbUFJVTkVDQUNIRV0oZW50cnkpXG4gICAgICBmdWxseURvbmUoZXIpXG4gICAgfVxuXG4gICAgY29uc3QgY2hlY2tDd2QgPSAoKSA9PiB7XG4gICAgICB0aGlzW01LRElSXSh0aGlzLmN3ZCwgdGhpcy5kbW9kZSwgZXIgPT4ge1xuICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgICAgICBkb25lKClcbiAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICB0aGlzW0NIRUNLRURfQ1dEXSA9IHRydWVcbiAgICAgICAgc3RhcnQoKVxuICAgICAgfSlcbiAgICB9XG5cbiAgICBjb25zdCBzdGFydCA9ICgpID0+IHtcbiAgICAgIGlmIChlbnRyeS5hYnNvbHV0ZSAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgY29uc3QgcGFyZW50ID0gbm9ybVBhdGgocGF0aC5kaXJuYW1lKGVudHJ5LmFic29sdXRlKSlcbiAgICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1tNS0RJUl0ocGFyZW50LCB0aGlzLmRtb2RlLCBlciA9PiB7XG4gICAgICAgICAgICBpZiAoZXIpIHtcbiAgICAgICAgICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgICAgICAgICAgIGRvbmUoKVxuICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFmdGVyTWFrZVBhcmVudCgpXG4gICAgICAgICAgfSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYWZ0ZXJNYWtlUGFyZW50KClcbiAgICB9XG5cbiAgICBjb25zdCBhZnRlck1ha2VQYXJlbnQgPSAoKSA9PiB7XG4gICAgICBmcy5sc3RhdChlbnRyeS5hYnNvbHV0ZSwgKGxzdGF0RXIsIHN0KSA9PiB7XG4gICAgICAgIGlmIChzdCAmJiAodGhpcy5rZWVwIHx8IHRoaXMubmV3ZXIgJiYgc3QubXRpbWUgPiBlbnRyeS5tdGltZSkpIHtcbiAgICAgICAgICB0aGlzW1NLSVBdKGVudHJ5KVxuICAgICAgICAgIGRvbmUoKVxuICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGlmIChsc3RhdEVyIHx8IHRoaXNbSVNSRVVTQUJMRV0oZW50cnksIHN0KSkge1xuICAgICAgICAgIHJldHVybiB0aGlzW01BS0VGU10obnVsbCwgZW50cnksIGRvbmUpXG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgIGlmIChlbnRyeS50eXBlID09PSAnRGlyZWN0b3J5Jykge1xuICAgICAgICAgICAgY29uc3QgbmVlZENobW9kID0gIXRoaXMubm9DaG1vZCAmJlxuICAgICAgICAgICAgICBlbnRyeS5tb2RlICYmXG4gICAgICAgICAgICAgIChzdC5tb2RlICYgMG83Nzc3KSAhPT0gZW50cnkubW9kZVxuICAgICAgICAgICAgY29uc3QgYWZ0ZXJDaG1vZCA9IGVyID0+IHRoaXNbTUFLRUZTXShlciwgZW50cnksIGRvbmUpXG4gICAgICAgICAgICBpZiAoIW5lZWRDaG1vZCkge1xuICAgICAgICAgICAgICByZXR1cm4gYWZ0ZXJDaG1vZCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZnMuY2htb2QoZW50cnkuYWJzb2x1dGUsIGVudHJ5Lm1vZGUsIGFmdGVyQ2htb2QpXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIE5vdCBhIGRpciBlbnRyeSwgaGF2ZSB0byByZW1vdmUgaXQuXG4gICAgICAgICAgLy8gTkI6IHRoZSBvbmx5IHdheSB0byBlbmQgdXAgd2l0aCBhbiBlbnRyeSB0aGF0IGlzIHRoZSBjd2RcbiAgICAgICAgICAvLyBpdHNlbGYsIGluIHN1Y2ggYSB3YXkgdGhhdCA9PSBkb2VzIG5vdCBkZXRlY3QsIGlzIGFcbiAgICAgICAgICAvLyB0cmlja3kgd2luZG93cyBhYnNvbHV0ZSBwYXRoIHdpdGggVU5DIG9yIDguMyBwYXJ0cyAoYW5kXG4gICAgICAgICAgLy8gcHJlc2VydmVQYXRoczp0cnVlLCBvciBlbHNlIGl0IHdpbGwgaGF2ZSBiZWVuIHN0cmlwcGVkKS5cbiAgICAgICAgICAvLyBJbiB0aGF0IGNhc2UsIHRoZSB1c2VyIGhhcyBvcHRlZCBvdXQgb2YgcGF0aCBwcm90ZWN0aW9uc1xuICAgICAgICAgIC8vIGV4cGxpY2l0bHksIHNvIGlmIHRoZXkgYmxvdyBhd2F5IHRoZSBjd2QsIGMnZXN0IGxhIHZpZS5cbiAgICAgICAgICBpZiAoZW50cnkuYWJzb2x1dGUgIT09IHRoaXMuY3dkKSB7XG4gICAgICAgICAgICByZXR1cm4gZnMucm1kaXIoZW50cnkuYWJzb2x1dGUsIGVyID0+XG4gICAgICAgICAgICAgIHRoaXNbTUFLRUZTXShlciwgZW50cnksIGRvbmUpKVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG5vdCBhIGRpciwgYW5kIG5vdCByZXVzYWJsZVxuICAgICAgICAvLyBkb24ndCByZW1vdmUgaWYgdGhlIGN3ZCwgd2Ugd2FudCB0aGF0IGVycm9yXG4gICAgICAgIGlmIChlbnRyeS5hYnNvbHV0ZSA9PT0gdGhpcy5jd2QpIHtcbiAgICAgICAgICByZXR1cm4gdGhpc1tNQUtFRlNdKG51bGwsIGVudHJ5LCBkb25lKVxuICAgICAgICB9XG5cbiAgICAgICAgdW5saW5rRmlsZShlbnRyeS5hYnNvbHV0ZSwgZXIgPT5cbiAgICAgICAgICB0aGlzW01BS0VGU10oZXIsIGVudHJ5LCBkb25lKSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXNbQ0hFQ0tFRF9DV0RdKSB7XG4gICAgICBzdGFydCgpXG4gICAgfSBlbHNlIHtcbiAgICAgIGNoZWNrQ3dkKClcbiAgICB9XG4gIH1cblxuICBbTUFLRUZTXSAoZXIsIGVudHJ5LCBkb25lKSB7XG4gICAgaWYgKGVyKSB7XG4gICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgIGRvbmUoKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgc3dpdGNoIChlbnRyeS50eXBlKSB7XG4gICAgICBjYXNlICdGaWxlJzpcbiAgICAgIGNhc2UgJ09sZEZpbGUnOlxuICAgICAgY2FzZSAnQ29udGlndW91c0ZpbGUnOlxuICAgICAgICByZXR1cm4gdGhpc1tGSUxFXShlbnRyeSwgZG9uZSlcblxuICAgICAgY2FzZSAnTGluayc6XG4gICAgICAgIHJldHVybiB0aGlzW0hBUkRMSU5LXShlbnRyeSwgZG9uZSlcblxuICAgICAgY2FzZSAnU3ltYm9saWNMaW5rJzpcbiAgICAgICAgcmV0dXJuIHRoaXNbU1lNTElOS10oZW50cnksIGRvbmUpXG5cbiAgICAgIGNhc2UgJ0RpcmVjdG9yeSc6XG4gICAgICBjYXNlICdHTlVEdW1wRGlyJzpcbiAgICAgICAgcmV0dXJuIHRoaXNbRElSRUNUT1JZXShlbnRyeSwgZG9uZSlcbiAgICB9XG4gIH1cblxuICBbTElOS10gKGVudHJ5LCBsaW5rcGF0aCwgbGluaywgZG9uZSkge1xuICAgIC8vIFhYWDogZ2V0IHRoZSB0eXBlICgnc3ltbGluaycgb3IgJ2p1bmN0aW9uJykgZm9yIHdpbmRvd3NcbiAgICBmc1tsaW5rXShsaW5rcGF0aCwgZW50cnkuYWJzb2x1dGUsIGVyID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICB0aGlzW09ORVJST1JdKGVyLCBlbnRyeSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXNbVU5QRU5EXSgpXG4gICAgICAgIGVudHJ5LnJlc3VtZSgpXG4gICAgICB9XG4gICAgICBkb25lKClcbiAgICB9KVxuICB9XG59XG5cbmNvbnN0IGNhbGxTeW5jID0gZm4gPT4ge1xuICB0cnkge1xuICAgIHJldHVybiBbbnVsbCwgZm4oKV1cbiAgfSBjYXRjaCAoZXIpIHtcbiAgICByZXR1cm4gW2VyLCBudWxsXVxuICB9XG59XG5jbGFzcyBVbnBhY2tTeW5jIGV4dGVuZHMgVW5wYWNrIHtcbiAgW01BS0VGU10gKGVyLCBlbnRyeSkge1xuICAgIHJldHVybiBzdXBlcltNQUtFRlNdKGVyLCBlbnRyeSwgKCkgPT4ge30pXG4gIH1cblxuICBbQ0hFQ0tGU10gKGVudHJ5KSB7XG4gICAgdGhpc1tQUlVORUNBQ0hFXShlbnRyeSlcblxuICAgIGlmICghdGhpc1tDSEVDS0VEX0NXRF0pIHtcbiAgICAgIGNvbnN0IGVyID0gdGhpc1tNS0RJUl0odGhpcy5jd2QsIHRoaXMuZG1vZGUpXG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbT05FUlJPUl0oZXIsIGVudHJ5KVxuICAgICAgfVxuICAgICAgdGhpc1tDSEVDS0VEX0NXRF0gPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gZG9uJ3QgYm90aGVyIHRvIG1ha2UgdGhlIHBhcmVudCBpZiB0aGUgY3VycmVudCBlbnRyeSBpcyB0aGUgY3dkLFxuICAgIC8vIHdlJ3ZlIGFscmVhZHkgY2hlY2tlZCBpdC5cbiAgICBpZiAoZW50cnkuYWJzb2x1dGUgIT09IHRoaXMuY3dkKSB7XG4gICAgICBjb25zdCBwYXJlbnQgPSBub3JtUGF0aChwYXRoLmRpcm5hbWUoZW50cnkuYWJzb2x1dGUpKVxuICAgICAgaWYgKHBhcmVudCAhPT0gdGhpcy5jd2QpIHtcbiAgICAgICAgY29uc3QgbWtQYXJlbnQgPSB0aGlzW01LRElSXShwYXJlbnQsIHRoaXMuZG1vZGUpXG4gICAgICAgIGlmIChta1BhcmVudCkge1xuICAgICAgICAgIHJldHVybiB0aGlzW09ORVJST1JdKG1rUGFyZW50LCBlbnRyeSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IFtsc3RhdEVyLCBzdF0gPSBjYWxsU3luYygoKSA9PiBmcy5sc3RhdFN5bmMoZW50cnkuYWJzb2x1dGUpKVxuICAgIGlmIChzdCAmJiAodGhpcy5rZWVwIHx8IHRoaXMubmV3ZXIgJiYgc3QubXRpbWUgPiBlbnRyeS5tdGltZSkpIHtcbiAgICAgIHJldHVybiB0aGlzW1NLSVBdKGVudHJ5KVxuICAgIH1cblxuICAgIGlmIChsc3RhdEVyIHx8IHRoaXNbSVNSRVVTQUJMRV0oZW50cnksIHN0KSkge1xuICAgICAgcmV0dXJuIHRoaXNbTUFLRUZTXShudWxsLCBlbnRyeSlcbiAgICB9XG5cbiAgICBpZiAoc3QuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgaWYgKGVudHJ5LnR5cGUgPT09ICdEaXJlY3RvcnknKSB7XG4gICAgICAgIGNvbnN0IG5lZWRDaG1vZCA9ICF0aGlzLm5vQ2htb2QgJiZcbiAgICAgICAgICBlbnRyeS5tb2RlICYmXG4gICAgICAgICAgKHN0Lm1vZGUgJiAwbzc3NzcpICE9PSBlbnRyeS5tb2RlXG4gICAgICAgIGNvbnN0IFtlcl0gPSBuZWVkQ2htb2QgPyBjYWxsU3luYygoKSA9PiB7XG4gICAgICAgICAgZnMuY2htb2RTeW5jKGVudHJ5LmFic29sdXRlLCBlbnRyeS5tb2RlKVxuICAgICAgICB9KSA6IFtdXG4gICAgICAgIHJldHVybiB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICAgICAgfVxuICAgICAgLy8gbm90IGEgZGlyIGVudHJ5LCBoYXZlIHRvIHJlbW92ZSBpdFxuICAgICAgY29uc3QgW2VyXSA9IGNhbGxTeW5jKCgpID0+IGZzLnJtZGlyU3luYyhlbnRyeS5hYnNvbHV0ZSkpXG4gICAgICB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICAgIH1cblxuICAgIC8vIG5vdCBhIGRpciwgYW5kIG5vdCByZXVzYWJsZS5cbiAgICAvLyBkb24ndCByZW1vdmUgaWYgaXQncyB0aGUgY3dkLCBzaW5jZSB3ZSB3YW50IHRoYXQgZXJyb3IuXG4gICAgY29uc3QgW2VyXSA9IGVudHJ5LmFic29sdXRlID09PSB0aGlzLmN3ZCA/IFtdXG4gICAgICA6IGNhbGxTeW5jKCgpID0+IHVubGlua0ZpbGVTeW5jKGVudHJ5LmFic29sdXRlKSlcbiAgICB0aGlzW01BS0VGU10oZXIsIGVudHJ5KVxuICB9XG5cbiAgW0ZJTEVdIChlbnRyeSwgZG9uZSkge1xuICAgIGNvbnN0IG1vZGUgPSBlbnRyeS5tb2RlICYgMG83Nzc3IHx8IHRoaXMuZm1vZGVcblxuICAgIGNvbnN0IG9uZXIgPSBlciA9PiB7XG4gICAgICBsZXQgY2xvc2VFcnJvclxuICAgICAgdHJ5IHtcbiAgICAgICAgZnMuY2xvc2VTeW5jKGZkKVxuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjbG9zZUVycm9yID0gZVxuICAgICAgfVxuICAgICAgaWYgKGVyIHx8IGNsb3NlRXJyb3IpIHtcbiAgICAgICAgdGhpc1tPTkVSUk9SXShlciB8fCBjbG9zZUVycm9yLCBlbnRyeSlcbiAgICAgIH1cbiAgICAgIGRvbmUoKVxuICAgIH1cblxuICAgIGxldCBmZFxuICAgIHRyeSB7XG4gICAgICBmZCA9IGZzLm9wZW5TeW5jKGVudHJ5LmFic29sdXRlLCBnZXRGbGFnKGVudHJ5LnNpemUpLCBtb2RlKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gb25lcihlcilcbiAgICB9XG4gICAgY29uc3QgdHggPSB0aGlzLnRyYW5zZm9ybSA/IHRoaXMudHJhbnNmb3JtKGVudHJ5KSB8fCBlbnRyeSA6IGVudHJ5XG4gICAgaWYgKHR4ICE9PSBlbnRyeSkge1xuICAgICAgdHgub24oJ2Vycm9yJywgZXIgPT4gdGhpc1tPTkVSUk9SXShlciwgZW50cnkpKVxuICAgICAgZW50cnkucGlwZSh0eClcbiAgICB9XG5cbiAgICB0eC5vbignZGF0YScsIGNodW5rID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZzLndyaXRlU3luYyhmZCwgY2h1bmssIDAsIGNodW5rLmxlbmd0aClcbiAgICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICAgIG9uZXIoZXIpXG4gICAgICB9XG4gICAgfSlcblxuICAgIHR4Lm9uKCdlbmQnLCBfID0+IHtcbiAgICAgIGxldCBlciA9IG51bGxcbiAgICAgIC8vIHRyeSBib3RoLCBmYWxsaW5nIGZ1dGltZXMgYmFjayB0byB1dGltZXNcbiAgICAgIC8vIGlmIGVpdGhlciBmYWlscywgaGFuZGxlIHRoZSBmaXJzdCBlcnJvclxuICAgICAgaWYgKGVudHJ5Lm10aW1lICYmICF0aGlzLm5vTXRpbWUpIHtcbiAgICAgICAgY29uc3QgYXRpbWUgPSBlbnRyeS5hdGltZSB8fCBuZXcgRGF0ZSgpXG4gICAgICAgIGNvbnN0IG10aW1lID0gZW50cnkubXRpbWVcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy5mdXRpbWVzU3luYyhmZCwgYXRpbWUsIG10aW1lKVxuICAgICAgICB9IGNhdGNoIChmdXRpbWVzZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMudXRpbWVzU3luYyhlbnRyeS5hYnNvbHV0ZSwgYXRpbWUsIG10aW1lKVxuICAgICAgICAgIH0gY2F0Y2ggKHV0aW1lc2VyKSB7XG4gICAgICAgICAgICBlciA9IGZ1dGltZXNlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpc1tET0NIT1dOXShlbnRyeSkpIHtcbiAgICAgICAgY29uc3QgdWlkID0gdGhpc1tVSURdKGVudHJ5KVxuICAgICAgICBjb25zdCBnaWQgPSB0aGlzW0dJRF0oZW50cnkpXG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBmcy5mY2hvd25TeW5jKGZkLCB1aWQsIGdpZClcbiAgICAgICAgfSBjYXRjaCAoZmNob3duZXIpIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgZnMuY2hvd25TeW5jKGVudHJ5LmFic29sdXRlLCB1aWQsIGdpZClcbiAgICAgICAgICB9IGNhdGNoIChjaG93bmVyKSB7XG4gICAgICAgICAgICBlciA9IGVyIHx8IGZjaG93bmVyXG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIG9uZXIoZXIpXG4gICAgfSlcbiAgfVxuXG4gIFtESVJFQ1RPUlldIChlbnRyeSwgZG9uZSkge1xuICAgIGNvbnN0IG1vZGUgPSBlbnRyeS5tb2RlICYgMG83Nzc3IHx8IHRoaXMuZG1vZGVcbiAgICBjb25zdCBlciA9IHRoaXNbTUtESVJdKGVudHJ5LmFic29sdXRlLCBtb2RlKVxuICAgIGlmIChlcikge1xuICAgICAgdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgICBkb25lKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBpZiAoZW50cnkubXRpbWUgJiYgIXRoaXMubm9NdGltZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZnMudXRpbWVzU3luYyhlbnRyeS5hYnNvbHV0ZSwgZW50cnkuYXRpbWUgfHwgbmV3IERhdGUoKSwgZW50cnkubXRpbWUpXG4gICAgICB9IGNhdGNoIChlcikge31cbiAgICB9XG4gICAgaWYgKHRoaXNbRE9DSE9XTl0oZW50cnkpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBmcy5jaG93blN5bmMoZW50cnkuYWJzb2x1dGUsIHRoaXNbVUlEXShlbnRyeSksIHRoaXNbR0lEXShlbnRyeSkpXG4gICAgICB9IGNhdGNoIChlcikge31cbiAgICB9XG4gICAgZG9uZSgpXG4gICAgZW50cnkucmVzdW1lKClcbiAgfVxuXG4gIFtNS0RJUl0gKGRpciwgbW9kZSkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4gbWtkaXIuc3luYyhub3JtUGF0aChkaXIpLCB7XG4gICAgICAgIHVpZDogdGhpcy51aWQsXG4gICAgICAgIGdpZDogdGhpcy5naWQsXG4gICAgICAgIHByb2Nlc3NVaWQ6IHRoaXMucHJvY2Vzc1VpZCxcbiAgICAgICAgcHJvY2Vzc0dpZDogdGhpcy5wcm9jZXNzR2lkLFxuICAgICAgICB1bWFzazogdGhpcy5wcm9jZXNzVW1hc2ssXG4gICAgICAgIHByZXNlcnZlOiB0aGlzLnByZXNlcnZlUGF0aHMsXG4gICAgICAgIHVubGluazogdGhpcy51bmxpbmssXG4gICAgICAgIGNhY2hlOiB0aGlzLmRpckNhY2hlLFxuICAgICAgICBjd2Q6IHRoaXMuY3dkLFxuICAgICAgICBtb2RlOiBtb2RlLFxuICAgICAgfSlcbiAgICB9IGNhdGNoIChlcikge1xuICAgICAgcmV0dXJuIGVyXG4gICAgfVxuICB9XG5cbiAgW0xJTktdIChlbnRyeSwgbGlua3BhdGgsIGxpbmssIGRvbmUpIHtcbiAgICB0cnkge1xuICAgICAgZnNbbGluayArICdTeW5jJ10obGlua3BhdGgsIGVudHJ5LmFic29sdXRlKVxuICAgICAgZG9uZSgpXG4gICAgICBlbnRyeS5yZXN1bWUoKVxuICAgIH0gY2F0Y2ggKGVyKSB7XG4gICAgICByZXR1cm4gdGhpc1tPTkVSUk9SXShlciwgZW50cnkpXG4gICAgfVxuICB9XG59XG5cblVucGFjay5TeW5jID0gVW5wYWNrU3luY1xubW9kdWxlLmV4cG9ydHMgPSBVbnBhY2tcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/unpack.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/update.js":
/*!****************************************!*\
  !*** ./node_modules/tar/lib/update.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\n// tar -u\n\nconst hlo = __webpack_require__(/*! ./high-level-opt.js */ \"./node_modules/tar/lib/high-level-opt.js\")\nconst r = __webpack_require__(/*! ./replace.js */ \"./node_modules/tar/lib/replace.js\")\n// just call tar.r with the filter and mtimeCache\n\nmodule.exports = (opt_, files, cb) => {\n  const opt = hlo(opt_)\n\n  if (!opt.file) {\n    throw new TypeError('file is required')\n  }\n\n  if (opt.gzip || opt.brotli || opt.file.endsWith('.br') || opt.file.endsWith('.tbr')) {\n    throw new TypeError('cannot append to compressed archives')\n  }\n\n  if (!files || !Array.isArray(files) || !files.length) {\n    throw new TypeError('no files or directories specified')\n  }\n\n  files = Array.from(files)\n\n  mtimeFilter(opt)\n  return r(opt, files, cb)\n}\n\nconst mtimeFilter = opt => {\n  const filter = opt.filter\n\n  if (!opt.mtimeCache) {\n    opt.mtimeCache = new Map()\n  }\n\n  opt.filter = filter ? (path, stat) =>\n    filter(path, stat) && !(opt.mtimeCache.get(path) > stat.mtime)\n    : (path, stat) => !(opt.mtimeCache.get(path) > stat.mtime)\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi91cGRhdGUuanMiLCJtYXBwaW5ncyI6IkFBQVk7O0FBRVo7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLHFFQUFxQjtBQUN6QyxVQUFVLG1CQUFPLENBQUMsdURBQWM7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvdXBkYXRlLmpzPzYzOWMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbi8vIHRhciAtdVxuXG5jb25zdCBobG8gPSByZXF1aXJlKCcuL2hpZ2gtbGV2ZWwtb3B0LmpzJylcbmNvbnN0IHIgPSByZXF1aXJlKCcuL3JlcGxhY2UuanMnKVxuLy8ganVzdCBjYWxsIHRhci5yIHdpdGggdGhlIGZpbHRlciBhbmQgbXRpbWVDYWNoZVxuXG5tb2R1bGUuZXhwb3J0cyA9IChvcHRfLCBmaWxlcywgY2IpID0+IHtcbiAgY29uc3Qgb3B0ID0gaGxvKG9wdF8pXG5cbiAgaWYgKCFvcHQuZmlsZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpbGUgaXMgcmVxdWlyZWQnKVxuICB9XG5cbiAgaWYgKG9wdC5nemlwIHx8IG9wdC5icm90bGkgfHwgb3B0LmZpbGUuZW5kc1dpdGgoJy5icicpIHx8IG9wdC5maWxlLmVuZHNXaXRoKCcudGJyJykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgYXBwZW5kIHRvIGNvbXByZXNzZWQgYXJjaGl2ZXMnKVxuICB9XG5cbiAgaWYgKCFmaWxlcyB8fCAhQXJyYXkuaXNBcnJheShmaWxlcykgfHwgIWZpbGVzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIGZpbGVzIG9yIGRpcmVjdG9yaWVzIHNwZWNpZmllZCcpXG4gIH1cblxuICBmaWxlcyA9IEFycmF5LmZyb20oZmlsZXMpXG5cbiAgbXRpbWVGaWx0ZXIob3B0KVxuICByZXR1cm4gcihvcHQsIGZpbGVzLCBjYilcbn1cblxuY29uc3QgbXRpbWVGaWx0ZXIgPSBvcHQgPT4ge1xuICBjb25zdCBmaWx0ZXIgPSBvcHQuZmlsdGVyXG5cbiAgaWYgKCFvcHQubXRpbWVDYWNoZSkge1xuICAgIG9wdC5tdGltZUNhY2hlID0gbmV3IE1hcCgpXG4gIH1cblxuICBvcHQuZmlsdGVyID0gZmlsdGVyID8gKHBhdGgsIHN0YXQpID0+XG4gICAgZmlsdGVyKHBhdGgsIHN0YXQpICYmICEob3B0Lm10aW1lQ2FjaGUuZ2V0KHBhdGgpID4gc3RhdC5tdGltZSlcbiAgICA6IChwYXRoLCBzdGF0KSA9PiAhKG9wdC5tdGltZUNhY2hlLmdldChwYXRoKSA+IHN0YXQubXRpbWUpXG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/update.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/warn-mixin.js":
/*!********************************************!*\
  !*** ./node_modules/tar/lib/warn-mixin.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = Base => class extends Base {\n  warn (code, message, data = {}) {\n    if (this.file) {\n      data.file = this.file\n    }\n    if (this.cwd) {\n      data.cwd = this.cwd\n    }\n    data.code = message instanceof Error && message.code || code\n    data.tarCode = code\n    if (!this.strict && data.recoverable !== false) {\n      if (message instanceof Error) {\n        data = Object.assign(message, data)\n        message = message.message\n      }\n      this.emit('warn', data.tarCode, message, data)\n    } else if (message instanceof Error) {\n      this.emit('error', Object.assign(message, data))\n    } else {\n      this.emit('error', Object.assign(new Error(`${code}: ${message}`), data))\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi93YXJuLW1peGluLmpzIiwibWFwcGluZ3MiOiJBQUFZO0FBQ1o7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTixvREFBb0QsS0FBSyxJQUFJLFFBQVE7QUFDckU7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy90YXIvbGliL3dhcm4tbWl4aW4uanM/OGUxOSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbm1vZHVsZS5leHBvcnRzID0gQmFzZSA9PiBjbGFzcyBleHRlbmRzIEJhc2Uge1xuICB3YXJuIChjb2RlLCBtZXNzYWdlLCBkYXRhID0ge30pIHtcbiAgICBpZiAodGhpcy5maWxlKSB7XG4gICAgICBkYXRhLmZpbGUgPSB0aGlzLmZpbGVcbiAgICB9XG4gICAgaWYgKHRoaXMuY3dkKSB7XG4gICAgICBkYXRhLmN3ZCA9IHRoaXMuY3dkXG4gICAgfVxuICAgIGRhdGEuY29kZSA9IG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvciAmJiBtZXNzYWdlLmNvZGUgfHwgY29kZVxuICAgIGRhdGEudGFyQ29kZSA9IGNvZGVcbiAgICBpZiAoIXRoaXMuc3RyaWN0ICYmIGRhdGEucmVjb3ZlcmFibGUgIT09IGZhbHNlKSB7XG4gICAgICBpZiAobWVzc2FnZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGRhdGEgPSBPYmplY3QuYXNzaWduKG1lc3NhZ2UsIGRhdGEpXG4gICAgICAgIG1lc3NhZ2UgPSBtZXNzYWdlLm1lc3NhZ2VcbiAgICAgIH1cbiAgICAgIHRoaXMuZW1pdCgnd2FybicsIGRhdGEudGFyQ29kZSwgbWVzc2FnZSwgZGF0YSlcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhpcy5lbWl0KCdlcnJvcicsIE9iamVjdC5hc3NpZ24obWVzc2FnZSwgZGF0YSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBPYmplY3QuYXNzaWduKG5ldyBFcnJvcihgJHtjb2RlfTogJHttZXNzYWdlfWApLCBkYXRhKSlcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/warn-mixin.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/winchars.js":
/*!******************************************!*\
  !*** ./node_modules/tar/lib/winchars.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\n\nconst raw = [\n  '|',\n  '<',\n  '>',\n  '?',\n  ':',\n]\n\nconst win = raw.map(char =>\n  String.fromCharCode(0xf000 + char.charCodeAt(0)))\n\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]))\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]))\n\nmodule.exports = {\n  encode: s => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s),\n  decode: s => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s),\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi93aW5jaGFycy5qcyIsIm1hcHBpbmdzIjoiQUFBWTs7QUFFWjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvdGFyL2xpYi93aW5jaGFycy5qcz83NmU1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xuXG4vLyBXaGVuIHdyaXRpbmcgZmlsZXMgb24gV2luZG93cywgdHJhbnNsYXRlIHRoZSBjaGFyYWN0ZXJzIHRvIHRoZWlyXG4vLyAweGYwMDAgaGlnaGVyLWVuY29kZWQgdmVyc2lvbnMuXG5cbmNvbnN0IHJhdyA9IFtcbiAgJ3wnLFxuICAnPCcsXG4gICc+JyxcbiAgJz8nLFxuICAnOicsXG5dXG5cbmNvbnN0IHdpbiA9IHJhdy5tYXAoY2hhciA9PlxuICBTdHJpbmcuZnJvbUNoYXJDb2RlKDB4ZjAwMCArIGNoYXIuY2hhckNvZGVBdCgwKSkpXG5cbmNvbnN0IHRvV2luID0gbmV3IE1hcChyYXcubWFwKChjaGFyLCBpKSA9PiBbY2hhciwgd2luW2ldXSkpXG5jb25zdCB0b1JhdyA9IG5ldyBNYXAod2luLm1hcCgoY2hhciwgaSkgPT4gW2NoYXIsIHJhd1tpXV0pKVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2RlOiBzID0+IHJhdy5yZWR1Y2UoKHMsIGMpID0+IHMuc3BsaXQoYykuam9pbih0b1dpbi5nZXQoYykpLCBzKSxcbiAgZGVjb2RlOiBzID0+IHdpbi5yZWR1Y2UoKHMsIGMpID0+IHMuc3BsaXQoYykuam9pbih0b1Jhdy5nZXQoYykpLCBzKSxcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/winchars.js\n");

/***/ }),

/***/ "./node_modules/tar/lib/write-entry.js":
/*!*********************************************!*\
  !*** ./node_modules/tar/lib/write-entry.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nconst { Minipass } = __webpack_require__(/*! minipass */ \"./node_modules/tar/node_modules/minipass/index.js\")\nconst Pax = __webpack_require__(/*! ./pax.js */ \"./node_modules/tar/lib/pax.js\")\nconst Header = __webpack_require__(/*! ./header.js */ \"./node_modules/tar/lib/header.js\")\nconst fs = __webpack_require__(/*! fs */ \"fs\")\nconst path = __webpack_require__(/*! path */ \"path\")\nconst normPath = __webpack_require__(/*! ./normalize-windows-path.js */ \"./node_modules/tar/lib/normalize-windows-path.js\")\nconst stripSlash = __webpack_require__(/*! ./strip-trailing-slashes.js */ \"./node_modules/tar/lib/strip-trailing-slashes.js\")\n\nconst prefixPath = (path, prefix) => {\n  if (!prefix) {\n    return normPath(path)\n  }\n  path = normPath(path).replace(/^\\.(\\/|$)/, '')\n  return stripSlash(prefix) + '/' + path\n}\n\nconst maxReadSize = 16 * 1024 * 1024\nconst PROCESS = Symbol('process')\nconst FILE = Symbol('file')\nconst DIRECTORY = Symbol('directory')\nconst SYMLINK = Symbol('symlink')\nconst HARDLINK = Symbol('hardlink')\nconst HEADER = Symbol('header')\nconst READ = Symbol('read')\nconst LSTAT = Symbol('lstat')\nconst ONLSTAT = Symbol('onlstat')\nconst ONREAD = Symbol('onread')\nconst ONREADLINK = Symbol('onreadlink')\nconst OPENFILE = Symbol('openfile')\nconst ONOPENFILE = Symbol('onopenfile')\nconst CLOSE = Symbol('close')\nconst MODE = Symbol('mode')\nconst AWAITDRAIN = Symbol('awaitDrain')\nconst ONDRAIN = Symbol('ondrain')\nconst PREFIX = Symbol('prefix')\nconst HAD_ERROR = Symbol('hadError')\nconst warner = __webpack_require__(/*! ./warn-mixin.js */ \"./node_modules/tar/lib/warn-mixin.js\")\nconst winchars = __webpack_require__(/*! ./winchars.js */ \"./node_modules/tar/lib/winchars.js\")\nconst stripAbsolutePath = __webpack_require__(/*! ./strip-absolute-path.js */ \"./node_modules/tar/lib/strip-absolute-path.js\")\n\nconst modeFix = __webpack_require__(/*! ./mode-fix.js */ \"./node_modules/tar/lib/mode-fix.js\")\n\nconst WriteEntry = warner(class WriteEntry extends Minipass {\n  constructor (p, opt) {\n    opt = opt || {}\n    super(opt)\n    if (typeof p !== 'string') {\n      throw new TypeError('path is required')\n    }\n    this.path = normPath(p)\n    // suppress atime, ctime, uid, gid, uname, gname\n    this.portable = !!opt.portable\n    // until node has builtin pwnam functions, this'll have to do\n    this.myuid = process.getuid && process.getuid() || 0\n    this.myuser = {}.USER || ''\n    this.maxReadSize = opt.maxReadSize || maxReadSize\n    this.linkCache = opt.linkCache || new Map()\n    this.statCache = opt.statCache || new Map()\n    this.preservePaths = !!opt.preservePaths\n    this.cwd = normPath(opt.cwd || process.cwd())\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n    this.mtime = opt.mtime || null\n    this.prefix = opt.prefix ? normPath(opt.prefix) : null\n\n    this.fd = null\n    this.blockLen = null\n    this.blockRemain = null\n    this.buf = null\n    this.offset = null\n    this.length = null\n    this.pos = null\n    this.remain = null\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.win32 = !!opt.win32 || process.platform === 'win32'\n    if (this.win32) {\n      // force the \\ to / normalization, since we might not *actually*\n      // be on windows, but want \\ to be considered a path separator.\n      this.path = winchars.decode(this.path.replace(/\\\\/g, '/'))\n      p = p.replace(/\\\\/g, '/')\n    }\n\n    this.absolute = normPath(opt.absolute || path.resolve(this.cwd, p))\n\n    if (this.path === '') {\n      this.path = './'\n    }\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.statCache.has(this.absolute)) {\n      this[ONLSTAT](this.statCache.get(this.absolute))\n    } else {\n      this[LSTAT]()\n    }\n  }\n\n  emit (ev, ...data) {\n    if (ev === 'error') {\n      this[HAD_ERROR] = true\n    }\n    return super.emit(ev, ...data)\n  }\n\n  [LSTAT] () {\n    fs.lstat(this.absolute, (er, stat) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONLSTAT](stat)\n    })\n  }\n\n  [ONLSTAT] (stat) {\n    this.statCache.set(this.absolute, stat)\n    this.stat = stat\n    if (!stat.isFile()) {\n      stat.size = 0\n    }\n    this.type = getType(stat)\n    this.emit('stat', stat)\n    this[PROCESS]()\n  }\n\n  [PROCESS] () {\n    switch (this.type) {\n      case 'File': return this[FILE]()\n      case 'Directory': return this[DIRECTORY]()\n      case 'SymbolicLink': return this[SYMLINK]()\n      // unsupported types are ignored.\n      default: return this.end()\n    }\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [HEADER] () {\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      // only apply the prefix to hard links.\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this[MODE](this.stat.mode),\n      uid: this.portable ? null : this.stat.uid,\n      gid: this.portable ? null : this.stat.gid,\n      size: this.stat.size,\n      mtime: this.noMtime ? null : this.mtime || this.stat.mtime,\n      type: this.type,\n      uname: this.portable ? null :\n      this.stat.uid === this.myuid ? this.myuser : '',\n      atime: this.portable ? null : this.stat.atime,\n      ctime: this.portable ? null : this.stat.ctime,\n    })\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.header.atime,\n        ctime: this.portable ? null : this.header.ctime,\n        gid: this.portable ? null : this.header.gid,\n        mtime: this.noMtime ? null : this.mtime || this.header.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.header.size,\n        uid: this.portable ? null : this.header.uid,\n        uname: this.portable ? null : this.header.uname,\n        dev: this.portable ? null : this.stat.dev,\n        ino: this.portable ? null : this.stat.ino,\n        nlink: this.portable ? null : this.stat.nlink,\n      }).encode())\n    }\n    super.write(this.header.block)\n  }\n\n  [DIRECTORY] () {\n    if (this.path.slice(-1) !== '/') {\n      this.path += '/'\n    }\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [SYMLINK] () {\n    fs.readlink(this.absolute, (er, linkpath) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONREADLINK](linkpath)\n    })\n  }\n\n  [ONREADLINK] (linkpath) {\n    this.linkpath = normPath(linkpath)\n    this[HEADER]()\n    this.end()\n  }\n\n  [HARDLINK] (linkpath) {\n    this.type = 'Link'\n    this.linkpath = normPath(path.relative(this.cwd, linkpath))\n    this.stat.size = 0\n    this[HEADER]()\n    this.end()\n  }\n\n  [FILE] () {\n    if (this.stat.nlink > 1) {\n      const linkKey = this.stat.dev + ':' + this.stat.ino\n      if (this.linkCache.has(linkKey)) {\n        const linkpath = this.linkCache.get(linkKey)\n        if (linkpath.indexOf(this.cwd) === 0) {\n          return this[HARDLINK](linkpath)\n        }\n      }\n      this.linkCache.set(linkKey, this.absolute)\n    }\n\n    this[HEADER]()\n    if (this.stat.size === 0) {\n      return this.end()\n    }\n\n    this[OPENFILE]()\n  }\n\n  [OPENFILE] () {\n    fs.open(this.absolute, 'r', (er, fd) => {\n      if (er) {\n        return this.emit('error', er)\n      }\n      this[ONOPENFILE](fd)\n    })\n  }\n\n  [ONOPENFILE] (fd) {\n    this.fd = fd\n    if (this[HAD_ERROR]) {\n      return this[CLOSE]()\n    }\n\n    this.blockLen = 512 * Math.ceil(this.stat.size / 512)\n    this.blockRemain = this.blockLen\n    const bufLen = Math.min(this.blockLen, this.maxReadSize)\n    this.buf = Buffer.allocUnsafe(bufLen)\n    this.offset = 0\n    this.pos = 0\n    this.remain = this.stat.size\n    this.length = this.buf.length\n    this[READ]()\n  }\n\n  [READ] () {\n    const { fd, buf, offset, length, pos } = this\n    fs.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n      if (er) {\n        // ignoring the error from close(2) is a bad practice, but at\n        // this point we already have an error, don't need another one\n        return this[CLOSE](() => this.emit('error', er))\n      }\n      this[ONREAD](bytesRead)\n    })\n  }\n\n  [CLOSE] (cb) {\n    fs.close(this.fd, cb)\n  }\n\n  [ONREAD] (bytesRead) {\n    if (bytesRead <= 0 && this.remain > 0) {\n      const er = new Error('encountered unexpected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    if (bytesRead > this.remain) {\n      const er = new Error('did not encounter expected EOF')\n      er.path = this.absolute\n      er.syscall = 'read'\n      er.code = 'EOF'\n      return this[CLOSE](() => this.emit('error', er))\n    }\n\n    // null out the rest of the buffer, if we could fit the block padding\n    // at the end of this loop, we've incremented bytesRead and this.remain\n    // to be incremented up to the blockRemain level, as if we had expected\n    // to get a null-padded file, and read it until the end.  then we will\n    // decrement both remain and blockRemain by bytesRead, and know that we\n    // reached the expected EOF, without any null buffer to append.\n    if (bytesRead === this.remain) {\n      for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n        this.buf[i + this.offset] = 0\n        bytesRead++\n        this.remain++\n      }\n    }\n\n    const writeBuf = this.offset === 0 && bytesRead === this.buf.length ?\n      this.buf : this.buf.slice(this.offset, this.offset + bytesRead)\n\n    const flushed = this.write(writeBuf)\n    if (!flushed) {\n      this[AWAITDRAIN](() => this[ONDRAIN]())\n    } else {\n      this[ONDRAIN]()\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    this.once('drain', cb)\n  }\n\n  write (writeBuf) {\n    if (this.blockRemain < writeBuf.length) {\n      const er = new Error('writing more data than expected')\n      er.path = this.absolute\n      return this.emit('error', er)\n    }\n    this.remain -= writeBuf.length\n    this.blockRemain -= writeBuf.length\n    this.pos += writeBuf.length\n    this.offset += writeBuf.length\n    return super.write(writeBuf)\n  }\n\n  [ONDRAIN] () {\n    if (!this.remain) {\n      if (this.blockRemain) {\n        super.write(Buffer.alloc(this.blockRemain))\n      }\n      return this[CLOSE](er => er ? this.emit('error', er) : this.end())\n    }\n\n    if (this.offset >= this.length) {\n      // if we only have a smaller bit left to read, alloc a smaller buffer\n      // otherwise, keep it the same length it was before.\n      this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length))\n      this.offset = 0\n    }\n    this.length = this.buf.length - this.offset\n    this[READ]()\n  }\n})\n\nclass WriteEntrySync extends WriteEntry {\n  [LSTAT] () {\n    this[ONLSTAT](fs.lstatSync(this.absolute))\n  }\n\n  [SYMLINK] () {\n    this[ONREADLINK](fs.readlinkSync(this.absolute))\n  }\n\n  [OPENFILE] () {\n    this[ONOPENFILE](fs.openSync(this.absolute, 'r'))\n  }\n\n  [READ] () {\n    let threw = true\n    try {\n      const { fd, buf, offset, length, pos } = this\n      const bytesRead = fs.readSync(fd, buf, offset, length, pos)\n      this[ONREAD](bytesRead)\n      threw = false\n    } finally {\n      // ignoring the error from close(2) is a bad practice, but at\n      // this point we already have an error, don't need another one\n      if (threw) {\n        try {\n          this[CLOSE](() => {})\n        } catch (er) {}\n      }\n    }\n  }\n\n  [AWAITDRAIN] (cb) {\n    cb()\n  }\n\n  [CLOSE] (cb) {\n    fs.closeSync(this.fd)\n    cb()\n  }\n}\n\nconst WriteEntryTar = warner(class WriteEntryTar extends Minipass {\n  constructor (readEntry, opt) {\n    opt = opt || {}\n    super(opt)\n    this.preservePaths = !!opt.preservePaths\n    this.portable = !!opt.portable\n    this.strict = !!opt.strict\n    this.noPax = !!opt.noPax\n    this.noMtime = !!opt.noMtime\n\n    this.readEntry = readEntry\n    this.type = readEntry.type\n    if (this.type === 'Directory' && this.portable) {\n      this.noMtime = true\n    }\n\n    this.prefix = opt.prefix || null\n\n    this.path = normPath(readEntry.path)\n    this.mode = this[MODE](readEntry.mode)\n    this.uid = this.portable ? null : readEntry.uid\n    this.gid = this.portable ? null : readEntry.gid\n    this.uname = this.portable ? null : readEntry.uname\n    this.gname = this.portable ? null : readEntry.gname\n    this.size = readEntry.size\n    this.mtime = this.noMtime ? null : opt.mtime || readEntry.mtime\n    this.atime = this.portable ? null : readEntry.atime\n    this.ctime = this.portable ? null : readEntry.ctime\n    this.linkpath = normPath(readEntry.linkpath)\n\n    if (typeof opt.onwarn === 'function') {\n      this.on('warn', opt.onwarn)\n    }\n\n    let pathWarn = false\n    if (!this.preservePaths) {\n      const [root, stripped] = stripAbsolutePath(this.path)\n      if (root) {\n        this.path = stripped\n        pathWarn = root\n      }\n    }\n\n    this.remain = readEntry.size\n    this.blockRemain = readEntry.startBlockSize\n\n    this.header = new Header({\n      path: this[PREFIX](this.path),\n      linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n      : this.linkpath,\n      // only the permissions and setuid/setgid/sticky bitflags\n      // not the higher-order bits that specify file type\n      mode: this.mode,\n      uid: this.portable ? null : this.uid,\n      gid: this.portable ? null : this.gid,\n      size: this.size,\n      mtime: this.noMtime ? null : this.mtime,\n      type: this.type,\n      uname: this.portable ? null : this.uname,\n      atime: this.portable ? null : this.atime,\n      ctime: this.portable ? null : this.ctime,\n    })\n\n    if (pathWarn) {\n      this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n        entry: this,\n        path: pathWarn + this.path,\n      })\n    }\n\n    if (this.header.encode() && !this.noPax) {\n      super.write(new Pax({\n        atime: this.portable ? null : this.atime,\n        ctime: this.portable ? null : this.ctime,\n        gid: this.portable ? null : this.gid,\n        mtime: this.noMtime ? null : this.mtime,\n        path: this[PREFIX](this.path),\n        linkpath: this.type === 'Link' ? this[PREFIX](this.linkpath)\n        : this.linkpath,\n        size: this.size,\n        uid: this.portable ? null : this.uid,\n        uname: this.portable ? null : this.uname,\n        dev: this.portable ? null : this.readEntry.dev,\n        ino: this.portable ? null : this.readEntry.ino,\n        nlink: this.portable ? null : this.readEntry.nlink,\n      }).encode())\n    }\n\n    super.write(this.header.block)\n    readEntry.pipe(this)\n  }\n\n  [PREFIX] (path) {\n    return prefixPath(path, this.prefix)\n  }\n\n  [MODE] (mode) {\n    return modeFix(mode, this.type === 'Directory', this.portable)\n  }\n\n  write (data) {\n    const writeLen = data.length\n    if (writeLen > this.blockRemain) {\n      throw new Error('writing more to entry than is appropriate')\n    }\n    this.blockRemain -= writeLen\n    return super.write(data)\n  }\n\n  end () {\n    if (this.blockRemain) {\n      super.write(Buffer.alloc(this.blockRemain))\n    }\n    return super.end()\n  }\n})\n\nWriteEntry.Sync = WriteEntrySync\nWriteEntry.Tar = WriteEntryTar\n\nconst getType = stat =>\n  stat.isFile() ? 'File'\n  : stat.isDirectory() ? 'Directory'\n  : stat.isSymbolicLink() ? 'SymbolicLink'\n  : 'Unsupported'\n\nmodule.exports = WriteEntry\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL2xpYi93cml0ZS1lbnRyeS5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsbUVBQVU7QUFDdkMsWUFBWSxtQkFBTyxDQUFDLCtDQUFVO0FBQzlCLGVBQWUsbUJBQU8sQ0FBQyxxREFBYTtBQUNwQyxXQUFXLG1CQUFPLENBQUMsY0FBSTtBQUN2QixhQUFhLG1CQUFPLENBQUMsa0JBQU07QUFDM0IsaUJBQWlCLG1CQUFPLENBQUMscUZBQTZCO0FBQ3RELG1CQUFtQixtQkFBTyxDQUFDLHFGQUE2Qjs7QUFFeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyw2REFBaUI7QUFDeEMsaUJBQWlCLG1CQUFPLENBQUMseURBQWU7QUFDeEMsMEJBQTBCLG1CQUFPLENBQUMsK0VBQTBCOztBQUU1RCxnQkFBZ0IsbUJBQU8sQ0FBQyx5REFBZTs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLEVBQVc7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwrQ0FBK0MsVUFBVTtBQUN6RDtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlEQUFpRDtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLCtCQUErQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUIsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLCtDQUErQyxVQUFVO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3Rhci9saWIvd3JpdGUtZW50cnkuanM/YjRkMSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IHsgTWluaXBhc3MgfSA9IHJlcXVpcmUoJ21pbmlwYXNzJylcbmNvbnN0IFBheCA9IHJlcXVpcmUoJy4vcGF4LmpzJylcbmNvbnN0IEhlYWRlciA9IHJlcXVpcmUoJy4vaGVhZGVyLmpzJylcbmNvbnN0IGZzID0gcmVxdWlyZSgnZnMnKVxuY29uc3QgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxuY29uc3Qgbm9ybVBhdGggPSByZXF1aXJlKCcuL25vcm1hbGl6ZS13aW5kb3dzLXBhdGguanMnKVxuY29uc3Qgc3RyaXBTbGFzaCA9IHJlcXVpcmUoJy4vc3RyaXAtdHJhaWxpbmctc2xhc2hlcy5qcycpXG5cbmNvbnN0IHByZWZpeFBhdGggPSAocGF0aCwgcHJlZml4KSA9PiB7XG4gIGlmICghcHJlZml4KSB7XG4gICAgcmV0dXJuIG5vcm1QYXRoKHBhdGgpXG4gIH1cbiAgcGF0aCA9IG5vcm1QYXRoKHBhdGgpLnJlcGxhY2UoL15cXC4oXFwvfCQpLywgJycpXG4gIHJldHVybiBzdHJpcFNsYXNoKHByZWZpeCkgKyAnLycgKyBwYXRoXG59XG5cbmNvbnN0IG1heFJlYWRTaXplID0gMTYgKiAxMDI0ICogMTAyNFxuY29uc3QgUFJPQ0VTUyA9IFN5bWJvbCgncHJvY2VzcycpXG5jb25zdCBGSUxFID0gU3ltYm9sKCdmaWxlJylcbmNvbnN0IERJUkVDVE9SWSA9IFN5bWJvbCgnZGlyZWN0b3J5JylcbmNvbnN0IFNZTUxJTksgPSBTeW1ib2woJ3N5bWxpbmsnKVxuY29uc3QgSEFSRExJTksgPSBTeW1ib2woJ2hhcmRsaW5rJylcbmNvbnN0IEhFQURFUiA9IFN5bWJvbCgnaGVhZGVyJylcbmNvbnN0IFJFQUQgPSBTeW1ib2woJ3JlYWQnKVxuY29uc3QgTFNUQVQgPSBTeW1ib2woJ2xzdGF0JylcbmNvbnN0IE9OTFNUQVQgPSBTeW1ib2woJ29ubHN0YXQnKVxuY29uc3QgT05SRUFEID0gU3ltYm9sKCdvbnJlYWQnKVxuY29uc3QgT05SRUFETElOSyA9IFN5bWJvbCgnb25yZWFkbGluaycpXG5jb25zdCBPUEVORklMRSA9IFN5bWJvbCgnb3BlbmZpbGUnKVxuY29uc3QgT05PUEVORklMRSA9IFN5bWJvbCgnb25vcGVuZmlsZScpXG5jb25zdCBDTE9TRSA9IFN5bWJvbCgnY2xvc2UnKVxuY29uc3QgTU9ERSA9IFN5bWJvbCgnbW9kZScpXG5jb25zdCBBV0FJVERSQUlOID0gU3ltYm9sKCdhd2FpdERyYWluJylcbmNvbnN0IE9ORFJBSU4gPSBTeW1ib2woJ29uZHJhaW4nKVxuY29uc3QgUFJFRklYID0gU3ltYm9sKCdwcmVmaXgnKVxuY29uc3QgSEFEX0VSUk9SID0gU3ltYm9sKCdoYWRFcnJvcicpXG5jb25zdCB3YXJuZXIgPSByZXF1aXJlKCcuL3dhcm4tbWl4aW4uanMnKVxuY29uc3Qgd2luY2hhcnMgPSByZXF1aXJlKCcuL3dpbmNoYXJzLmpzJylcbmNvbnN0IHN0cmlwQWJzb2x1dGVQYXRoID0gcmVxdWlyZSgnLi9zdHJpcC1hYnNvbHV0ZS1wYXRoLmpzJylcblxuY29uc3QgbW9kZUZpeCA9IHJlcXVpcmUoJy4vbW9kZS1maXguanMnKVxuXG5jb25zdCBXcml0ZUVudHJ5ID0gd2FybmVyKGNsYXNzIFdyaXRlRW50cnkgZXh0ZW5kcyBNaW5pcGFzcyB7XG4gIGNvbnN0cnVjdG9yIChwLCBvcHQpIHtcbiAgICBvcHQgPSBvcHQgfHwge31cbiAgICBzdXBlcihvcHQpXG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGF0aCBpcyByZXF1aXJlZCcpXG4gICAgfVxuICAgIHRoaXMucGF0aCA9IG5vcm1QYXRoKHApXG4gICAgLy8gc3VwcHJlc3MgYXRpbWUsIGN0aW1lLCB1aWQsIGdpZCwgdW5hbWUsIGduYW1lXG4gICAgdGhpcy5wb3J0YWJsZSA9ICEhb3B0LnBvcnRhYmxlXG4gICAgLy8gdW50aWwgbm9kZSBoYXMgYnVpbHRpbiBwd25hbSBmdW5jdGlvbnMsIHRoaXMnbGwgaGF2ZSB0byBkb1xuICAgIHRoaXMubXl1aWQgPSBwcm9jZXNzLmdldHVpZCAmJiBwcm9jZXNzLmdldHVpZCgpIHx8IDBcbiAgICB0aGlzLm15dXNlciA9IHByb2Nlc3MuZW52LlVTRVIgfHwgJydcbiAgICB0aGlzLm1heFJlYWRTaXplID0gb3B0Lm1heFJlYWRTaXplIHx8IG1heFJlYWRTaXplXG4gICAgdGhpcy5saW5rQ2FjaGUgPSBvcHQubGlua0NhY2hlIHx8IG5ldyBNYXAoKVxuICAgIHRoaXMuc3RhdENhY2hlID0gb3B0LnN0YXRDYWNoZSB8fCBuZXcgTWFwKClcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG4gICAgdGhpcy5jd2QgPSBub3JtUGF0aChvcHQuY3dkIHx8IHByb2Nlc3MuY3dkKCkpXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm5vUGF4ID0gISFvcHQubm9QYXhcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG4gICAgdGhpcy5tdGltZSA9IG9wdC5tdGltZSB8fCBudWxsXG4gICAgdGhpcy5wcmVmaXggPSBvcHQucHJlZml4ID8gbm9ybVBhdGgob3B0LnByZWZpeCkgOiBudWxsXG5cbiAgICB0aGlzLmZkID0gbnVsbFxuICAgIHRoaXMuYmxvY2tMZW4gPSBudWxsXG4gICAgdGhpcy5ibG9ja1JlbWFpbiA9IG51bGxcbiAgICB0aGlzLmJ1ZiA9IG51bGxcbiAgICB0aGlzLm9mZnNldCA9IG51bGxcbiAgICB0aGlzLmxlbmd0aCA9IG51bGxcbiAgICB0aGlzLnBvcyA9IG51bGxcbiAgICB0aGlzLnJlbWFpbiA9IG51bGxcblxuICAgIGlmICh0eXBlb2Ygb3B0Lm9ud2FybiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpcy5vbignd2FybicsIG9wdC5vbndhcm4pXG4gICAgfVxuXG4gICAgbGV0IHBhdGhXYXJuID0gZmFsc2VcbiAgICBpZiAoIXRoaXMucHJlc2VydmVQYXRocykge1xuICAgICAgY29uc3QgW3Jvb3QsIHN0cmlwcGVkXSA9IHN0cmlwQWJzb2x1dGVQYXRoKHRoaXMucGF0aClcbiAgICAgIGlmIChyb290KSB7XG4gICAgICAgIHRoaXMucGF0aCA9IHN0cmlwcGVkXG4gICAgICAgIHBhdGhXYXJuID0gcm9vdFxuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMud2luMzIgPSAhIW9wdC53aW4zMiB8fCBwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInXG4gICAgaWYgKHRoaXMud2luMzIpIHtcbiAgICAgIC8vIGZvcmNlIHRoZSBcXCB0byAvIG5vcm1hbGl6YXRpb24sIHNpbmNlIHdlIG1pZ2h0IG5vdCAqYWN0dWFsbHkqXG4gICAgICAvLyBiZSBvbiB3aW5kb3dzLCBidXQgd2FudCBcXCB0byBiZSBjb25zaWRlcmVkIGEgcGF0aCBzZXBhcmF0b3IuXG4gICAgICB0aGlzLnBhdGggPSB3aW5jaGFycy5kZWNvZGUodGhpcy5wYXRoLnJlcGxhY2UoL1xcXFwvZywgJy8nKSlcbiAgICAgIHAgPSBwLnJlcGxhY2UoL1xcXFwvZywgJy8nKVxuICAgIH1cblxuICAgIHRoaXMuYWJzb2x1dGUgPSBub3JtUGF0aChvcHQuYWJzb2x1dGUgfHwgcGF0aC5yZXNvbHZlKHRoaXMuY3dkLCBwKSlcblxuICAgIGlmICh0aGlzLnBhdGggPT09ICcnKSB7XG4gICAgICB0aGlzLnBhdGggPSAnLi8nXG4gICAgfVxuXG4gICAgaWYgKHBhdGhXYXJuKSB7XG4gICAgICB0aGlzLndhcm4oJ1RBUl9FTlRSWV9JTkZPJywgYHN0cmlwcGluZyAke3BhdGhXYXJufSBmcm9tIGFic29sdXRlIHBhdGhgLCB7XG4gICAgICAgIGVudHJ5OiB0aGlzLFxuICAgICAgICBwYXRoOiBwYXRoV2FybiArIHRoaXMucGF0aCxcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgaWYgKHRoaXMuc3RhdENhY2hlLmhhcyh0aGlzLmFic29sdXRlKSkge1xuICAgICAgdGhpc1tPTkxTVEFUXSh0aGlzLnN0YXRDYWNoZS5nZXQodGhpcy5hYnNvbHV0ZSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbTFNUQVRdKClcbiAgICB9XG4gIH1cblxuICBlbWl0IChldiwgLi4uZGF0YSkge1xuICAgIGlmIChldiA9PT0gJ2Vycm9yJykge1xuICAgICAgdGhpc1tIQURfRVJST1JdID0gdHJ1ZVxuICAgIH1cbiAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uZGF0YSlcbiAgfVxuXG4gIFtMU1RBVF0gKCkge1xuICAgIGZzLmxzdGF0KHRoaXMuYWJzb2x1dGUsIChlciwgc3RhdCkgPT4ge1xuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICB9XG4gICAgICB0aGlzW09OTFNUQVRdKHN0YXQpXG4gICAgfSlcbiAgfVxuXG4gIFtPTkxTVEFUXSAoc3RhdCkge1xuICAgIHRoaXMuc3RhdENhY2hlLnNldCh0aGlzLmFic29sdXRlLCBzdGF0KVxuICAgIHRoaXMuc3RhdCA9IHN0YXRcbiAgICBpZiAoIXN0YXQuaXNGaWxlKCkpIHtcbiAgICAgIHN0YXQuc2l6ZSA9IDBcbiAgICB9XG4gICAgdGhpcy50eXBlID0gZ2V0VHlwZShzdGF0KVxuICAgIHRoaXMuZW1pdCgnc3RhdCcsIHN0YXQpXG4gICAgdGhpc1tQUk9DRVNTXSgpXG4gIH1cblxuICBbUFJPQ0VTU10gKCkge1xuICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICBjYXNlICdGaWxlJzogcmV0dXJuIHRoaXNbRklMRV0oKVxuICAgICAgY2FzZSAnRGlyZWN0b3J5JzogcmV0dXJuIHRoaXNbRElSRUNUT1JZXSgpXG4gICAgICBjYXNlICdTeW1ib2xpY0xpbmsnOiByZXR1cm4gdGhpc1tTWU1MSU5LXSgpXG4gICAgICAvLyB1bnN1cHBvcnRlZCB0eXBlcyBhcmUgaWdub3JlZC5cbiAgICAgIGRlZmF1bHQ6IHJldHVybiB0aGlzLmVuZCgpXG4gICAgfVxuICB9XG5cbiAgW01PREVdIChtb2RlKSB7XG4gICAgcmV0dXJuIG1vZGVGaXgobW9kZSwgdGhpcy50eXBlID09PSAnRGlyZWN0b3J5JywgdGhpcy5wb3J0YWJsZSlcbiAgfVxuXG4gIFtQUkVGSVhdIChwYXRoKSB7XG4gICAgcmV0dXJuIHByZWZpeFBhdGgocGF0aCwgdGhpcy5wcmVmaXgpXG4gIH1cblxuICBbSEVBREVSXSAoKSB7XG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ0RpcmVjdG9yeScgJiYgdGhpcy5wb3J0YWJsZSkge1xuICAgICAgdGhpcy5ub010aW1lID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMuaGVhZGVyID0gbmV3IEhlYWRlcih7XG4gICAgICBwYXRoOiB0aGlzW1BSRUZJWF0odGhpcy5wYXRoKSxcbiAgICAgIC8vIG9ubHkgYXBwbHkgdGhlIHByZWZpeCB0byBoYXJkIGxpbmtzLlxuICAgICAgbGlua3BhdGg6IHRoaXMudHlwZSA9PT0gJ0xpbmsnID8gdGhpc1tQUkVGSVhdKHRoaXMubGlua3BhdGgpXG4gICAgICA6IHRoaXMubGlua3BhdGgsXG4gICAgICAvLyBvbmx5IHRoZSBwZXJtaXNzaW9ucyBhbmQgc2V0dWlkL3NldGdpZC9zdGlja3kgYml0ZmxhZ3NcbiAgICAgIC8vIG5vdCB0aGUgaGlnaGVyLW9yZGVyIGJpdHMgdGhhdCBzcGVjaWZ5IGZpbGUgdHlwZVxuICAgICAgbW9kZTogdGhpc1tNT0RFXSh0aGlzLnN0YXQubW9kZSksXG4gICAgICB1aWQ6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5zdGF0LnVpZCxcbiAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnN0YXQuZ2lkLFxuICAgICAgc2l6ZTogdGhpcy5zdGF0LnNpemUsXG4gICAgICBtdGltZTogdGhpcy5ub010aW1lID8gbnVsbCA6IHRoaXMubXRpbWUgfHwgdGhpcy5zdGF0Lm10aW1lLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgdW5hbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDpcbiAgICAgIHRoaXMuc3RhdC51aWQgPT09IHRoaXMubXl1aWQgPyB0aGlzLm15dXNlciA6ICcnLFxuICAgICAgYXRpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5zdGF0LmF0aW1lLFxuICAgICAgY3RpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5zdGF0LmN0aW1lLFxuICAgIH0pXG5cbiAgICBpZiAodGhpcy5oZWFkZXIuZW5jb2RlKCkgJiYgIXRoaXMubm9QYXgpIHtcbiAgICAgIHN1cGVyLndyaXRlKG5ldyBQYXgoe1xuICAgICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci5hdGltZSxcbiAgICAgICAgY3RpbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5oZWFkZXIuY3RpbWUsXG4gICAgICAgIGdpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci5naWQsXG4gICAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSB8fCB0aGlzLmhlYWRlci5tdGltZSxcbiAgICAgICAgcGF0aDogdGhpc1tQUkVGSVhdKHRoaXMucGF0aCksXG4gICAgICAgIGxpbmtwYXRoOiB0aGlzLnR5cGUgPT09ICdMaW5rJyA/IHRoaXNbUFJFRklYXSh0aGlzLmxpbmtwYXRoKVxuICAgICAgICA6IHRoaXMubGlua3BhdGgsXG4gICAgICAgIHNpemU6IHRoaXMuaGVhZGVyLnNpemUsXG4gICAgICAgIHVpZDogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmhlYWRlci51aWQsXG4gICAgICAgIHVuYW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuaGVhZGVyLnVuYW1lLFxuICAgICAgICBkZXY6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5zdGF0LmRldixcbiAgICAgICAgaW5vOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5pbm8sXG4gICAgICAgIG5saW5rOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuc3RhdC5ubGluayxcbiAgICAgIH0pLmVuY29kZSgpKVxuICAgIH1cbiAgICBzdXBlci53cml0ZSh0aGlzLmhlYWRlci5ibG9jaylcbiAgfVxuXG4gIFtESVJFQ1RPUlldICgpIHtcbiAgICBpZiAodGhpcy5wYXRoLnNsaWNlKC0xKSAhPT0gJy8nKSB7XG4gICAgICB0aGlzLnBhdGggKz0gJy8nXG4gICAgfVxuICAgIHRoaXMuc3RhdC5zaXplID0gMFxuICAgIHRoaXNbSEVBREVSXSgpXG4gICAgdGhpcy5lbmQoKVxuICB9XG5cbiAgW1NZTUxJTktdICgpIHtcbiAgICBmcy5yZWFkbGluayh0aGlzLmFic29sdXRlLCAoZXIsIGxpbmtwYXRoKSA9PiB7XG4gICAgICBpZiAoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnZXJyb3InLCBlcilcbiAgICAgIH1cbiAgICAgIHRoaXNbT05SRUFETElOS10obGlua3BhdGgpXG4gICAgfSlcbiAgfVxuXG4gIFtPTlJFQURMSU5LXSAobGlua3BhdGgpIHtcbiAgICB0aGlzLmxpbmtwYXRoID0gbm9ybVBhdGgobGlua3BhdGgpXG4gICAgdGhpc1tIRUFERVJdKClcbiAgICB0aGlzLmVuZCgpXG4gIH1cblxuICBbSEFSRExJTktdIChsaW5rcGF0aCkge1xuICAgIHRoaXMudHlwZSA9ICdMaW5rJ1xuICAgIHRoaXMubGlua3BhdGggPSBub3JtUGF0aChwYXRoLnJlbGF0aXZlKHRoaXMuY3dkLCBsaW5rcGF0aCkpXG4gICAgdGhpcy5zdGF0LnNpemUgPSAwXG4gICAgdGhpc1tIRUFERVJdKClcbiAgICB0aGlzLmVuZCgpXG4gIH1cblxuICBbRklMRV0gKCkge1xuICAgIGlmICh0aGlzLnN0YXQubmxpbmsgPiAxKSB7XG4gICAgICBjb25zdCBsaW5rS2V5ID0gdGhpcy5zdGF0LmRldiArICc6JyArIHRoaXMuc3RhdC5pbm9cbiAgICAgIGlmICh0aGlzLmxpbmtDYWNoZS5oYXMobGlua0tleSkpIHtcbiAgICAgICAgY29uc3QgbGlua3BhdGggPSB0aGlzLmxpbmtDYWNoZS5nZXQobGlua0tleSlcbiAgICAgICAgaWYgKGxpbmtwYXRoLmluZGV4T2YodGhpcy5jd2QpID09PSAwKSB7XG4gICAgICAgICAgcmV0dXJuIHRoaXNbSEFSRExJTktdKGxpbmtwYXRoKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLmxpbmtDYWNoZS5zZXQobGlua0tleSwgdGhpcy5hYnNvbHV0ZSlcbiAgICB9XG5cbiAgICB0aGlzW0hFQURFUl0oKVxuICAgIGlmICh0aGlzLnN0YXQuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRoaXMuZW5kKClcbiAgICB9XG5cbiAgICB0aGlzW09QRU5GSUxFXSgpXG4gIH1cblxuICBbT1BFTkZJTEVdICgpIHtcbiAgICBmcy5vcGVuKHRoaXMuYWJzb2x1dGUsICdyJywgKGVyLCBmZCkgPT4ge1xuICAgICAgaWYgKGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICB9XG4gICAgICB0aGlzW09OT1BFTkZJTEVdKGZkKVxuICAgIH0pXG4gIH1cblxuICBbT05PUEVORklMRV0gKGZkKSB7XG4gICAgdGhpcy5mZCA9IGZkXG4gICAgaWYgKHRoaXNbSEFEX0VSUk9SXSkge1xuICAgICAgcmV0dXJuIHRoaXNbQ0xPU0VdKClcbiAgICB9XG5cbiAgICB0aGlzLmJsb2NrTGVuID0gNTEyICogTWF0aC5jZWlsKHRoaXMuc3RhdC5zaXplIC8gNTEyKVxuICAgIHRoaXMuYmxvY2tSZW1haW4gPSB0aGlzLmJsb2NrTGVuXG4gICAgY29uc3QgYnVmTGVuID0gTWF0aC5taW4odGhpcy5ibG9ja0xlbiwgdGhpcy5tYXhSZWFkU2l6ZSlcbiAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShidWZMZW4pXG4gICAgdGhpcy5vZmZzZXQgPSAwXG4gICAgdGhpcy5wb3MgPSAwXG4gICAgdGhpcy5yZW1haW4gPSB0aGlzLnN0YXQuc2l6ZVxuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5idWYubGVuZ3RoXG4gICAgdGhpc1tSRUFEXSgpXG4gIH1cblxuICBbUkVBRF0gKCkge1xuICAgIGNvbnN0IHsgZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvcyB9ID0gdGhpc1xuICAgIGZzLnJlYWQoZmQsIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgsIHBvcywgKGVyLCBieXRlc1JlYWQpID0+IHtcbiAgICAgIGlmIChlcikge1xuICAgICAgICAvLyBpZ25vcmluZyB0aGUgZXJyb3IgZnJvbSBjbG9zZSgyKSBpcyBhIGJhZCBwcmFjdGljZSwgYnV0IGF0XG4gICAgICAgIC8vIHRoaXMgcG9pbnQgd2UgYWxyZWFkeSBoYXZlIGFuIGVycm9yLCBkb24ndCBuZWVkIGFub3RoZXIgb25lXG4gICAgICAgIHJldHVybiB0aGlzW0NMT1NFXSgoKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKVxuICAgICAgfVxuICAgICAgdGhpc1tPTlJFQURdKGJ5dGVzUmVhZClcbiAgICB9KVxuICB9XG5cbiAgW0NMT1NFXSAoY2IpIHtcbiAgICBmcy5jbG9zZSh0aGlzLmZkLCBjYilcbiAgfVxuXG4gIFtPTlJFQURdIChieXRlc1JlYWQpIHtcbiAgICBpZiAoYnl0ZXNSZWFkIDw9IDAgJiYgdGhpcy5yZW1haW4gPiAwKSB7XG4gICAgICBjb25zdCBlciA9IG5ldyBFcnJvcignZW5jb3VudGVyZWQgdW5leHBlY3RlZCBFT0YnKVxuICAgICAgZXIucGF0aCA9IHRoaXMuYWJzb2x1dGVcbiAgICAgIGVyLnN5c2NhbGwgPSAncmVhZCdcbiAgICAgIGVyLmNvZGUgPSAnRU9GJ1xuICAgICAgcmV0dXJuIHRoaXNbQ0xPU0VdKCgpID0+IHRoaXMuZW1pdCgnZXJyb3InLCBlcikpXG4gICAgfVxuXG4gICAgaWYgKGJ5dGVzUmVhZCA+IHRoaXMucmVtYWluKSB7XG4gICAgICBjb25zdCBlciA9IG5ldyBFcnJvcignZGlkIG5vdCBlbmNvdW50ZXIgZXhwZWN0ZWQgRU9GJylcbiAgICAgIGVyLnBhdGggPSB0aGlzLmFic29sdXRlXG4gICAgICBlci5zeXNjYWxsID0gJ3JlYWQnXG4gICAgICBlci5jb2RlID0gJ0VPRidcbiAgICAgIHJldHVybiB0aGlzW0NMT1NFXSgoKSA9PiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpKVxuICAgIH1cblxuICAgIC8vIG51bGwgb3V0IHRoZSByZXN0IG9mIHRoZSBidWZmZXIsIGlmIHdlIGNvdWxkIGZpdCB0aGUgYmxvY2sgcGFkZGluZ1xuICAgIC8vIGF0IHRoZSBlbmQgb2YgdGhpcyBsb29wLCB3ZSd2ZSBpbmNyZW1lbnRlZCBieXRlc1JlYWQgYW5kIHRoaXMucmVtYWluXG4gICAgLy8gdG8gYmUgaW5jcmVtZW50ZWQgdXAgdG8gdGhlIGJsb2NrUmVtYWluIGxldmVsLCBhcyBpZiB3ZSBoYWQgZXhwZWN0ZWRcbiAgICAvLyB0byBnZXQgYSBudWxsLXBhZGRlZCBmaWxlLCBhbmQgcmVhZCBpdCB1bnRpbCB0aGUgZW5kLiAgdGhlbiB3ZSB3aWxsXG4gICAgLy8gZGVjcmVtZW50IGJvdGggcmVtYWluIGFuZCBibG9ja1JlbWFpbiBieSBieXRlc1JlYWQsIGFuZCBrbm93IHRoYXQgd2VcbiAgICAvLyByZWFjaGVkIHRoZSBleHBlY3RlZCBFT0YsIHdpdGhvdXQgYW55IG51bGwgYnVmZmVyIHRvIGFwcGVuZC5cbiAgICBpZiAoYnl0ZXNSZWFkID09PSB0aGlzLnJlbWFpbikge1xuICAgICAgZm9yIChsZXQgaSA9IGJ5dGVzUmVhZDsgaSA8IHRoaXMubGVuZ3RoICYmIGJ5dGVzUmVhZCA8IHRoaXMuYmxvY2tSZW1haW47IGkrKykge1xuICAgICAgICB0aGlzLmJ1ZltpICsgdGhpcy5vZmZzZXRdID0gMFxuICAgICAgICBieXRlc1JlYWQrK1xuICAgICAgICB0aGlzLnJlbWFpbisrXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgd3JpdGVCdWYgPSB0aGlzLm9mZnNldCA9PT0gMCAmJiBieXRlc1JlYWQgPT09IHRoaXMuYnVmLmxlbmd0aCA/XG4gICAgICB0aGlzLmJ1ZiA6IHRoaXMuYnVmLnNsaWNlKHRoaXMub2Zmc2V0LCB0aGlzLm9mZnNldCArIGJ5dGVzUmVhZClcblxuICAgIGNvbnN0IGZsdXNoZWQgPSB0aGlzLndyaXRlKHdyaXRlQnVmKVxuICAgIGlmICghZmx1c2hlZCkge1xuICAgICAgdGhpc1tBV0FJVERSQUlOXSgoKSA9PiB0aGlzW09ORFJBSU5dKCkpXG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXNbT05EUkFJTl0oKVxuICAgIH1cbiAgfVxuXG4gIFtBV0FJVERSQUlOXSAoY2IpIHtcbiAgICB0aGlzLm9uY2UoJ2RyYWluJywgY2IpXG4gIH1cblxuICB3cml0ZSAod3JpdGVCdWYpIHtcbiAgICBpZiAodGhpcy5ibG9ja1JlbWFpbiA8IHdyaXRlQnVmLmxlbmd0aCkge1xuICAgICAgY29uc3QgZXIgPSBuZXcgRXJyb3IoJ3dyaXRpbmcgbW9yZSBkYXRhIHRoYW4gZXhwZWN0ZWQnKVxuICAgICAgZXIucGF0aCA9IHRoaXMuYWJzb2x1dGVcbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgfVxuICAgIHRoaXMucmVtYWluIC09IHdyaXRlQnVmLmxlbmd0aFxuICAgIHRoaXMuYmxvY2tSZW1haW4gLT0gd3JpdGVCdWYubGVuZ3RoXG4gICAgdGhpcy5wb3MgKz0gd3JpdGVCdWYubGVuZ3RoXG4gICAgdGhpcy5vZmZzZXQgKz0gd3JpdGVCdWYubGVuZ3RoXG4gICAgcmV0dXJuIHN1cGVyLndyaXRlKHdyaXRlQnVmKVxuICB9XG5cbiAgW09ORFJBSU5dICgpIHtcbiAgICBpZiAoIXRoaXMucmVtYWluKSB7XG4gICAgICBpZiAodGhpcy5ibG9ja1JlbWFpbikge1xuICAgICAgICBzdXBlci53cml0ZShCdWZmZXIuYWxsb2ModGhpcy5ibG9ja1JlbWFpbikpXG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpc1tDTE9TRV0oZXIgPT4gZXIgPyB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpIDogdGhpcy5lbmQoKSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5vZmZzZXQgPj0gdGhpcy5sZW5ndGgpIHtcbiAgICAgIC8vIGlmIHdlIG9ubHkgaGF2ZSBhIHNtYWxsZXIgYml0IGxlZnQgdG8gcmVhZCwgYWxsb2MgYSBzbWFsbGVyIGJ1ZmZlclxuICAgICAgLy8gb3RoZXJ3aXNlLCBrZWVwIGl0IHRoZSBzYW1lIGxlbmd0aCBpdCB3YXMgYmVmb3JlLlxuICAgICAgdGhpcy5idWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoTWF0aC5taW4odGhpcy5ibG9ja1JlbWFpbiwgdGhpcy5idWYubGVuZ3RoKSlcbiAgICAgIHRoaXMub2Zmc2V0ID0gMFxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMuYnVmLmxlbmd0aCAtIHRoaXMub2Zmc2V0XG4gICAgdGhpc1tSRUFEXSgpXG4gIH1cbn0pXG5cbmNsYXNzIFdyaXRlRW50cnlTeW5jIGV4dGVuZHMgV3JpdGVFbnRyeSB7XG4gIFtMU1RBVF0gKCkge1xuICAgIHRoaXNbT05MU1RBVF0oZnMubHN0YXRTeW5jKHRoaXMuYWJzb2x1dGUpKVxuICB9XG5cbiAgW1NZTUxJTktdICgpIHtcbiAgICB0aGlzW09OUkVBRExJTktdKGZzLnJlYWRsaW5rU3luYyh0aGlzLmFic29sdXRlKSlcbiAgfVxuXG4gIFtPUEVORklMRV0gKCkge1xuICAgIHRoaXNbT05PUEVORklMRV0oZnMub3BlblN5bmModGhpcy5hYnNvbHV0ZSwgJ3InKSlcbiAgfVxuXG4gIFtSRUFEXSAoKSB7XG4gICAgbGV0IHRocmV3ID0gdHJ1ZVxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MgfSA9IHRoaXNcbiAgICAgIGNvbnN0IGJ5dGVzUmVhZCA9IGZzLnJlYWRTeW5jKGZkLCBidWYsIG9mZnNldCwgbGVuZ3RoLCBwb3MpXG4gICAgICB0aGlzW09OUkVBRF0oYnl0ZXNSZWFkKVxuICAgICAgdGhyZXcgPSBmYWxzZVxuICAgIH0gZmluYWxseSB7XG4gICAgICAvLyBpZ25vcmluZyB0aGUgZXJyb3IgZnJvbSBjbG9zZSgyKSBpcyBhIGJhZCBwcmFjdGljZSwgYnV0IGF0XG4gICAgICAvLyB0aGlzIHBvaW50IHdlIGFscmVhZHkgaGF2ZSBhbiBlcnJvciwgZG9uJ3QgbmVlZCBhbm90aGVyIG9uZVxuICAgICAgaWYgKHRocmV3KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdGhpc1tDTE9TRV0oKCkgPT4ge30pXG4gICAgICAgIH0gY2F0Y2ggKGVyKSB7fVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIFtBV0FJVERSQUlOXSAoY2IpIHtcbiAgICBjYigpXG4gIH1cblxuICBbQ0xPU0VdIChjYikge1xuICAgIGZzLmNsb3NlU3luYyh0aGlzLmZkKVxuICAgIGNiKClcbiAgfVxufVxuXG5jb25zdCBXcml0ZUVudHJ5VGFyID0gd2FybmVyKGNsYXNzIFdyaXRlRW50cnlUYXIgZXh0ZW5kcyBNaW5pcGFzcyB7XG4gIGNvbnN0cnVjdG9yIChyZWFkRW50cnksIG9wdCkge1xuICAgIG9wdCA9IG9wdCB8fCB7fVxuICAgIHN1cGVyKG9wdClcbiAgICB0aGlzLnByZXNlcnZlUGF0aHMgPSAhIW9wdC5wcmVzZXJ2ZVBhdGhzXG4gICAgdGhpcy5wb3J0YWJsZSA9ICEhb3B0LnBvcnRhYmxlXG4gICAgdGhpcy5zdHJpY3QgPSAhIW9wdC5zdHJpY3RcbiAgICB0aGlzLm5vUGF4ID0gISFvcHQubm9QYXhcbiAgICB0aGlzLm5vTXRpbWUgPSAhIW9wdC5ub010aW1lXG5cbiAgICB0aGlzLnJlYWRFbnRyeSA9IHJlYWRFbnRyeVxuICAgIHRoaXMudHlwZSA9IHJlYWRFbnRyeS50eXBlXG4gICAgaWYgKHRoaXMudHlwZSA9PT0gJ0RpcmVjdG9yeScgJiYgdGhpcy5wb3J0YWJsZSkge1xuICAgICAgdGhpcy5ub010aW1lID0gdHJ1ZVxuICAgIH1cblxuICAgIHRoaXMucHJlZml4ID0gb3B0LnByZWZpeCB8fCBudWxsXG5cbiAgICB0aGlzLnBhdGggPSBub3JtUGF0aChyZWFkRW50cnkucGF0aClcbiAgICB0aGlzLm1vZGUgPSB0aGlzW01PREVdKHJlYWRFbnRyeS5tb2RlKVxuICAgIHRoaXMudWlkID0gdGhpcy5wb3J0YWJsZSA/IG51bGwgOiByZWFkRW50cnkudWlkXG4gICAgdGhpcy5naWQgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS5naWRcbiAgICB0aGlzLnVuYW1lID0gdGhpcy5wb3J0YWJsZSA/IG51bGwgOiByZWFkRW50cnkudW5hbWVcbiAgICB0aGlzLmduYW1lID0gdGhpcy5wb3J0YWJsZSA/IG51bGwgOiByZWFkRW50cnkuZ25hbWVcbiAgICB0aGlzLnNpemUgPSByZWFkRW50cnkuc2l6ZVxuICAgIHRoaXMubXRpbWUgPSB0aGlzLm5vTXRpbWUgPyBudWxsIDogb3B0Lm10aW1lIHx8IHJlYWRFbnRyeS5tdGltZVxuICAgIHRoaXMuYXRpbWUgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS5hdGltZVxuICAgIHRoaXMuY3RpbWUgPSB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHJlYWRFbnRyeS5jdGltZVxuICAgIHRoaXMubGlua3BhdGggPSBub3JtUGF0aChyZWFkRW50cnkubGlua3BhdGgpXG5cbiAgICBpZiAodHlwZW9mIG9wdC5vbndhcm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXMub24oJ3dhcm4nLCBvcHQub253YXJuKVxuICAgIH1cblxuICAgIGxldCBwYXRoV2FybiA9IGZhbHNlXG4gICAgaWYgKCF0aGlzLnByZXNlcnZlUGF0aHMpIHtcbiAgICAgIGNvbnN0IFtyb290LCBzdHJpcHBlZF0gPSBzdHJpcEFic29sdXRlUGF0aCh0aGlzLnBhdGgpXG4gICAgICBpZiAocm9vdCkge1xuICAgICAgICB0aGlzLnBhdGggPSBzdHJpcHBlZFxuICAgICAgICBwYXRoV2FybiA9IHJvb3RcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnJlbWFpbiA9IHJlYWRFbnRyeS5zaXplXG4gICAgdGhpcy5ibG9ja1JlbWFpbiA9IHJlYWRFbnRyeS5zdGFydEJsb2NrU2l6ZVxuXG4gICAgdGhpcy5oZWFkZXIgPSBuZXcgSGVhZGVyKHtcbiAgICAgIHBhdGg6IHRoaXNbUFJFRklYXSh0aGlzLnBhdGgpLFxuICAgICAgbGlua3BhdGg6IHRoaXMudHlwZSA9PT0gJ0xpbmsnID8gdGhpc1tQUkVGSVhdKHRoaXMubGlua3BhdGgpXG4gICAgICA6IHRoaXMubGlua3BhdGgsXG4gICAgICAvLyBvbmx5IHRoZSBwZXJtaXNzaW9ucyBhbmQgc2V0dWlkL3NldGdpZC9zdGlja3kgYml0ZmxhZ3NcbiAgICAgIC8vIG5vdCB0aGUgaGlnaGVyLW9yZGVyIGJpdHMgdGhhdCBzcGVjaWZ5IGZpbGUgdHlwZVxuICAgICAgbW9kZTogdGhpcy5tb2RlLFxuICAgICAgdWlkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMudWlkLFxuICAgICAgZ2lkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuZ2lkLFxuICAgICAgc2l6ZTogdGhpcy5zaXplLFxuICAgICAgbXRpbWU6IHRoaXMubm9NdGltZSA/IG51bGwgOiB0aGlzLm10aW1lLFxuICAgICAgdHlwZTogdGhpcy50eXBlLFxuICAgICAgdW5hbWU6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy51bmFtZSxcbiAgICAgIGF0aW1lOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMuYXRpbWUsXG4gICAgICBjdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmN0aW1lLFxuICAgIH0pXG5cbiAgICBpZiAocGF0aFdhcm4pIHtcbiAgICAgIHRoaXMud2FybignVEFSX0VOVFJZX0lORk8nLCBgc3RyaXBwaW5nICR7cGF0aFdhcm59IGZyb20gYWJzb2x1dGUgcGF0aGAsIHtcbiAgICAgICAgZW50cnk6IHRoaXMsXG4gICAgICAgIHBhdGg6IHBhdGhXYXJuICsgdGhpcy5wYXRoLFxuICAgICAgfSlcbiAgICB9XG5cbiAgICBpZiAodGhpcy5oZWFkZXIuZW5jb2RlKCkgJiYgIXRoaXMubm9QYXgpIHtcbiAgICAgIHN1cGVyLndyaXRlKG5ldyBQYXgoe1xuICAgICAgICBhdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmF0aW1lLFxuICAgICAgICBjdGltZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLmN0aW1lLFxuICAgICAgICBnaWQ6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5naWQsXG4gICAgICAgIG10aW1lOiB0aGlzLm5vTXRpbWUgPyBudWxsIDogdGhpcy5tdGltZSxcbiAgICAgICAgcGF0aDogdGhpc1tQUkVGSVhdKHRoaXMucGF0aCksXG4gICAgICAgIGxpbmtwYXRoOiB0aGlzLnR5cGUgPT09ICdMaW5rJyA/IHRoaXNbUFJFRklYXSh0aGlzLmxpbmtwYXRoKVxuICAgICAgICA6IHRoaXMubGlua3BhdGgsXG4gICAgICAgIHNpemU6IHRoaXMuc2l6ZSxcbiAgICAgICAgdWlkOiB0aGlzLnBvcnRhYmxlID8gbnVsbCA6IHRoaXMudWlkLFxuICAgICAgICB1bmFtZTogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnVuYW1lLFxuICAgICAgICBkZXY6IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5yZWFkRW50cnkuZGV2LFxuICAgICAgICBpbm86IHRoaXMucG9ydGFibGUgPyBudWxsIDogdGhpcy5yZWFkRW50cnkuaW5vLFxuICAgICAgICBubGluazogdGhpcy5wb3J0YWJsZSA/IG51bGwgOiB0aGlzLnJlYWRFbnRyeS5ubGluayxcbiAgICAgIH0pLmVuY29kZSgpKVxuICAgIH1cblxuICAgIHN1cGVyLndyaXRlKHRoaXMuaGVhZGVyLmJsb2NrKVxuICAgIHJlYWRFbnRyeS5waXBlKHRoaXMpXG4gIH1cblxuICBbUFJFRklYXSAocGF0aCkge1xuICAgIHJldHVybiBwcmVmaXhQYXRoKHBhdGgsIHRoaXMucHJlZml4KVxuICB9XG5cbiAgW01PREVdIChtb2RlKSB7XG4gICAgcmV0dXJuIG1vZGVGaXgobW9kZSwgdGhpcy50eXBlID09PSAnRGlyZWN0b3J5JywgdGhpcy5wb3J0YWJsZSlcbiAgfVxuXG4gIHdyaXRlIChkYXRhKSB7XG4gICAgY29uc3Qgd3JpdGVMZW4gPSBkYXRhLmxlbmd0aFxuICAgIGlmICh3cml0ZUxlbiA+IHRoaXMuYmxvY2tSZW1haW4pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignd3JpdGluZyBtb3JlIHRvIGVudHJ5IHRoYW4gaXMgYXBwcm9wcmlhdGUnKVxuICAgIH1cbiAgICB0aGlzLmJsb2NrUmVtYWluIC09IHdyaXRlTGVuXG4gICAgcmV0dXJuIHN1cGVyLndyaXRlKGRhdGEpXG4gIH1cblxuICBlbmQgKCkge1xuICAgIGlmICh0aGlzLmJsb2NrUmVtYWluKSB7XG4gICAgICBzdXBlci53cml0ZShCdWZmZXIuYWxsb2ModGhpcy5ibG9ja1JlbWFpbikpXG4gICAgfVxuICAgIHJldHVybiBzdXBlci5lbmQoKVxuICB9XG59KVxuXG5Xcml0ZUVudHJ5LlN5bmMgPSBXcml0ZUVudHJ5U3luY1xuV3JpdGVFbnRyeS5UYXIgPSBXcml0ZUVudHJ5VGFyXG5cbmNvbnN0IGdldFR5cGUgPSBzdGF0ID0+XG4gIHN0YXQuaXNGaWxlKCkgPyAnRmlsZSdcbiAgOiBzdGF0LmlzRGlyZWN0b3J5KCkgPyAnRGlyZWN0b3J5J1xuICA6IHN0YXQuaXNTeW1ib2xpY0xpbmsoKSA/ICdTeW1ib2xpY0xpbmsnXG4gIDogJ1Vuc3VwcG9ydGVkJ1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRlRW50cnlcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/lib/write-entry.js\n");

/***/ }),

/***/ "./node_modules/tar/node_modules/minipass/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/tar/node_modules/minipass/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";
eval("\nconst proc =\n  typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n      }\nconst EE = __webpack_require__(/*! events */ \"events\")\nconst Stream = __webpack_require__(/*! stream */ \"stream\")\nconst stringdecoder = __webpack_require__(/*! string_decoder */ \"string_decoder\")\nconst SD = stringdecoder.StringDecoder\n\nconst EOF = Symbol('EOF')\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd')\nconst EMITTED_END = Symbol('emittedEnd')\nconst EMITTING_END = Symbol('emittingEnd')\nconst EMITTED_ERROR = Symbol('emittedError')\nconst CLOSED = Symbol('closed')\nconst READ = Symbol('read')\nconst FLUSH = Symbol('flush')\nconst FLUSHCHUNK = Symbol('flushChunk')\nconst ENCODING = Symbol('encoding')\nconst DECODER = Symbol('decoder')\nconst FLOWING = Symbol('flowing')\nconst PAUSED = Symbol('paused')\nconst RESUME = Symbol('resume')\nconst BUFFER = Symbol('buffer')\nconst PIPES = Symbol('pipes')\nconst BUFFERLENGTH = Symbol('bufferLength')\nconst BUFFERPUSH = Symbol('bufferPush')\nconst BUFFERSHIFT = Symbol('bufferShift')\nconst OBJECTMODE = Symbol('objectMode')\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed')\n// internal event when stream has an error\nconst ERROR = Symbol('error')\nconst EMITDATA = Symbol('emitData')\nconst EMITEND = Symbol('emitEnd')\nconst EMITEND2 = Symbol('emitEnd2')\nconst ASYNC = Symbol('async')\nconst ABORT = Symbol('abort')\nconst ABORTED = Symbol('aborted')\nconst SIGNAL = Symbol('signal')\n\nconst defer = fn => Promise.resolve().then(fn)\n\n// TODO remove when Node v8 support drops\nconst doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== '1'\nconst ASYNCITERATOR =\n  (doIter && Symbol.asyncIterator) || Symbol('asyncIterator not implemented')\nconst ITERATOR =\n  (doIter && Symbol.iterator) || Symbol('iterator not implemented')\n\n// events that mean 'the stream is over'\n// these are treated specially, and re-emitted\n// if they are listened for after emitting.\nconst isEndish = ev => ev === 'end' || ev === 'finish' || ev === 'prefinish'\n\nconst isArrayBuffer = b =>\n  b instanceof ArrayBuffer ||\n  (typeof b === 'object' &&\n    b.constructor &&\n    b.constructor.name === 'ArrayBuffer' &&\n    b.byteLength >= 0)\n\nconst isArrayBufferView = b => !Buffer.isBuffer(b) && ArrayBuffer.isView(b)\n\nclass Pipe {\n  constructor(src, dest, opts) {\n    this.src = src\n    this.dest = dest\n    this.opts = opts\n    this.ondrain = () => src[RESUME]()\n    dest.on('drain', this.ondrain)\n  }\n  unpipe() {\n    this.dest.removeListener('drain', this.ondrain)\n  }\n  // istanbul ignore next - only here for the prototype\n  proxyErrors() {}\n  end() {\n    this.unpipe()\n    if (this.opts.end) this.dest.end()\n  }\n}\n\nclass PipeProxyErrors extends Pipe {\n  unpipe() {\n    this.src.removeListener('error', this.proxyErrors)\n    super.unpipe()\n  }\n  constructor(src, dest, opts) {\n    super(src, dest, opts)\n    this.proxyErrors = er => dest.emit('error', er)\n    src.on('error', this.proxyErrors)\n  }\n}\n\nclass Minipass extends Stream {\n  constructor(options) {\n    super()\n    this[FLOWING] = false\n    // whether we're explicitly paused\n    this[PAUSED] = false\n    this[PIPES] = []\n    this[BUFFER] = []\n    this[OBJECTMODE] = (options && options.objectMode) || false\n    if (this[OBJECTMODE]) this[ENCODING] = null\n    else this[ENCODING] = (options && options.encoding) || null\n    if (this[ENCODING] === 'buffer') this[ENCODING] = null\n    this[ASYNC] = (options && !!options.async) || false\n    this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null\n    this[EOF] = false\n    this[EMITTED_END] = false\n    this[EMITTING_END] = false\n    this[CLOSED] = false\n    this[EMITTED_ERROR] = null\n    this.writable = true\n    this.readable = true\n    this[BUFFERLENGTH] = 0\n    this[DESTROYED] = false\n    if (options && options.debugExposeBuffer === true) {\n      Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] })\n    }\n    if (options && options.debugExposePipes === true) {\n      Object.defineProperty(this, 'pipes', { get: () => this[PIPES] })\n    }\n    this[SIGNAL] = options && options.signal\n    this[ABORTED] = false\n    if (this[SIGNAL]) {\n      this[SIGNAL].addEventListener('abort', () => this[ABORT]())\n      if (this[SIGNAL].aborted) {\n        this[ABORT]()\n      }\n    }\n  }\n\n  get bufferLength() {\n    return this[BUFFERLENGTH]\n  }\n\n  get encoding() {\n    return this[ENCODING]\n  }\n  set encoding(enc) {\n    if (this[OBJECTMODE]) throw new Error('cannot set encoding in objectMode')\n\n    if (\n      this[ENCODING] &&\n      enc !== this[ENCODING] &&\n      ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])\n    )\n      throw new Error('cannot change encoding')\n\n    if (this[ENCODING] !== enc) {\n      this[DECODER] = enc ? new SD(enc) : null\n      if (this[BUFFER].length)\n        this[BUFFER] = this[BUFFER].map(chunk => this[DECODER].write(chunk))\n    }\n\n    this[ENCODING] = enc\n  }\n\n  setEncoding(enc) {\n    this.encoding = enc\n  }\n\n  get objectMode() {\n    return this[OBJECTMODE]\n  }\n  set objectMode(om) {\n    this[OBJECTMODE] = this[OBJECTMODE] || !!om\n  }\n\n  get ['async']() {\n    return this[ASYNC]\n  }\n  set ['async'](a) {\n    this[ASYNC] = this[ASYNC] || !!a\n  }\n\n  // drop everything and get out of the flow completely\n  [ABORT]() {\n    this[ABORTED] = true\n    this.emit('abort', this[SIGNAL].reason)\n    this.destroy(this[SIGNAL].reason)\n  }\n\n  get aborted() {\n    return this[ABORTED]\n  }\n  set aborted(_) {}\n\n  write(chunk, encoding, cb) {\n    if (this[ABORTED]) return false\n    if (this[EOF]) throw new Error('write after end')\n\n    if (this[DESTROYED]) {\n      this.emit(\n        'error',\n        Object.assign(\n          new Error('Cannot call write after a stream was destroyed'),\n          { code: 'ERR_STREAM_DESTROYED' }\n        )\n      )\n      return true\n    }\n\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n\n    if (!encoding) encoding = 'utf8'\n\n    const fn = this[ASYNC] ? defer : f => f()\n\n    // convert array buffers and typed array views into buffers\n    // at some point in the future, we may want to do the opposite!\n    // leave strings and buffers as-is\n    // anything else switches us into object mode\n    if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n      if (isArrayBufferView(chunk))\n        chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength)\n      else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk)\n      else if (typeof chunk !== 'string')\n        // use the setter so we throw if we have encoding set\n        this.objectMode = true\n    }\n\n    // handle object mode up front, since it's simpler\n    // this yields better performance, fewer checks later.\n    if (this[OBJECTMODE]) {\n      /* istanbul ignore if - maybe impossible? */\n      if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n      if (this.flowing) this.emit('data', chunk)\n      else this[BUFFERPUSH](chunk)\n\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n      if (cb) fn(cb)\n\n      return this.flowing\n    }\n\n    // at this point the chunk is a buffer or string\n    // don't buffer it up or send it to the decoder\n    if (!chunk.length) {\n      if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n      if (cb) fn(cb)\n      return this.flowing\n    }\n\n    // fast-path writing strings of same encoding to a stream with\n    // an empty buffer, skipping the buffer/decoder dance\n    if (\n      typeof chunk === 'string' &&\n      // unless it is a string already ready for us to use\n      !(encoding === this[ENCODING] && !this[DECODER].lastNeed)\n    ) {\n      chunk = Buffer.from(chunk, encoding)\n    }\n\n    if (Buffer.isBuffer(chunk) && this[ENCODING])\n      chunk = this[DECODER].write(chunk)\n\n    // Note: flushing CAN potentially switch us into not-flowing mode\n    if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true)\n\n    if (this.flowing) this.emit('data', chunk)\n    else this[BUFFERPUSH](chunk)\n\n    if (this[BUFFERLENGTH] !== 0) this.emit('readable')\n\n    if (cb) fn(cb)\n\n    return this.flowing\n  }\n\n  read(n) {\n    if (this[DESTROYED]) return null\n\n    if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {\n      this[MAYBE_EMIT_END]()\n      return null\n    }\n\n    if (this[OBJECTMODE]) n = null\n\n    if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n      if (this.encoding) this[BUFFER] = [this[BUFFER].join('')]\n      else this[BUFFER] = [Buffer.concat(this[BUFFER], this[BUFFERLENGTH])]\n    }\n\n    const ret = this[READ](n || null, this[BUFFER][0])\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [READ](n, chunk) {\n    if (n === chunk.length || n === null) this[BUFFERSHIFT]()\n    else {\n      this[BUFFER][0] = chunk.slice(n)\n      chunk = chunk.slice(0, n)\n      this[BUFFERLENGTH] -= n\n    }\n\n    this.emit('data', chunk)\n\n    if (!this[BUFFER].length && !this[EOF]) this.emit('drain')\n\n    return chunk\n  }\n\n  end(chunk, encoding, cb) {\n    if (typeof chunk === 'function') (cb = chunk), (chunk = null)\n    if (typeof encoding === 'function') (cb = encoding), (encoding = 'utf8')\n    if (chunk) this.write(chunk, encoding)\n    if (cb) this.once('end', cb)\n    this[EOF] = true\n    this.writable = false\n\n    // if we haven't written anything, then go ahead and emit,\n    // even if we're not reading.\n    // we'll re-emit if a new 'end' listener is added anyway.\n    // This makes MP more suitable to write-only use cases.\n    if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]()\n    return this\n  }\n\n  // don't let the internal resume be overwritten\n  [RESUME]() {\n    if (this[DESTROYED]) return\n\n    this[PAUSED] = false\n    this[FLOWING] = true\n    this.emit('resume')\n    if (this[BUFFER].length) this[FLUSH]()\n    else if (this[EOF]) this[MAYBE_EMIT_END]()\n    else this.emit('drain')\n  }\n\n  resume() {\n    return this[RESUME]()\n  }\n\n  pause() {\n    this[FLOWING] = false\n    this[PAUSED] = true\n  }\n\n  get destroyed() {\n    return this[DESTROYED]\n  }\n\n  get flowing() {\n    return this[FLOWING]\n  }\n\n  get paused() {\n    return this[PAUSED]\n  }\n\n  [BUFFERPUSH](chunk) {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1\n    else this[BUFFERLENGTH] += chunk.length\n    this[BUFFER].push(chunk)\n  }\n\n  [BUFFERSHIFT]() {\n    if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1\n    else this[BUFFERLENGTH] -= this[BUFFER][0].length\n    return this[BUFFER].shift()\n  }\n\n  [FLUSH](noDrain) {\n    do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) && this[BUFFER].length)\n\n    if (!noDrain && !this[BUFFER].length && !this[EOF]) this.emit('drain')\n  }\n\n  [FLUSHCHUNK](chunk) {\n    this.emit('data', chunk)\n    return this.flowing\n  }\n\n  pipe(dest, opts) {\n    if (this[DESTROYED]) return\n\n    const ended = this[EMITTED_END]\n    opts = opts || {}\n    if (dest === proc.stdout || dest === proc.stderr) opts.end = false\n    else opts.end = opts.end !== false\n    opts.proxyErrors = !!opts.proxyErrors\n\n    // piping an ended stream ends immediately\n    if (ended) {\n      if (opts.end) dest.end()\n    } else {\n      this[PIPES].push(\n        !opts.proxyErrors\n          ? new Pipe(this, dest, opts)\n          : new PipeProxyErrors(this, dest, opts)\n      )\n      if (this[ASYNC]) defer(() => this[RESUME]())\n      else this[RESUME]()\n    }\n\n    return dest\n  }\n\n  unpipe(dest) {\n    const p = this[PIPES].find(p => p.dest === dest)\n    if (p) {\n      this[PIPES].splice(this[PIPES].indexOf(p), 1)\n      p.unpipe()\n    }\n  }\n\n  addListener(ev, fn) {\n    return this.on(ev, fn)\n  }\n\n  on(ev, fn) {\n    const ret = super.on(ev, fn)\n    if (ev === 'data' && !this[PIPES].length && !this.flowing) this[RESUME]()\n    else if (ev === 'readable' && this[BUFFERLENGTH] !== 0)\n      super.emit('readable')\n    else if (isEndish(ev) && this[EMITTED_END]) {\n      super.emit(ev)\n      this.removeAllListeners(ev)\n    } else if (ev === 'error' && this[EMITTED_ERROR]) {\n      if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]))\n      else fn.call(this, this[EMITTED_ERROR])\n    }\n    return ret\n  }\n\n  get emittedEnd() {\n    return this[EMITTED_END]\n  }\n\n  [MAYBE_EMIT_END]() {\n    if (\n      !this[EMITTING_END] &&\n      !this[EMITTED_END] &&\n      !this[DESTROYED] &&\n      this[BUFFER].length === 0 &&\n      this[EOF]\n    ) {\n      this[EMITTING_END] = true\n      this.emit('end')\n      this.emit('prefinish')\n      this.emit('finish')\n      if (this[CLOSED]) this.emit('close')\n      this[EMITTING_END] = false\n    }\n  }\n\n  emit(ev, data, ...extra) {\n    // error and close are only events allowed after calling destroy()\n    if (ev !== 'error' && ev !== 'close' && ev !== DESTROYED && this[DESTROYED])\n      return\n    else if (ev === 'data') {\n      return !this[OBJECTMODE] && !data\n        ? false\n        : this[ASYNC]\n        ? defer(() => this[EMITDATA](data))\n        : this[EMITDATA](data)\n    } else if (ev === 'end') {\n      return this[EMITEND]()\n    } else if (ev === 'close') {\n      this[CLOSED] = true\n      // don't emit close before 'end' and 'finish'\n      if (!this[EMITTED_END] && !this[DESTROYED]) return\n      const ret = super.emit('close')\n      this.removeAllListeners('close')\n      return ret\n    } else if (ev === 'error') {\n      this[EMITTED_ERROR] = data\n      super.emit(ERROR, data)\n      const ret =\n        !this[SIGNAL] || this.listeners('error').length\n          ? super.emit('error', data)\n          : false\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'resume') {\n      const ret = super.emit('resume')\n      this[MAYBE_EMIT_END]()\n      return ret\n    } else if (ev === 'finish' || ev === 'prefinish') {\n      const ret = super.emit(ev)\n      this.removeAllListeners(ev)\n      return ret\n    }\n\n    // Some other unknown event\n    const ret = super.emit(ev, data, ...extra)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITDATA](data) {\n    for (const p of this[PIPES]) {\n      if (p.dest.write(data) === false) this.pause()\n    }\n    const ret = super.emit('data', data)\n    this[MAYBE_EMIT_END]()\n    return ret\n  }\n\n  [EMITEND]() {\n    if (this[EMITTED_END]) return\n\n    this[EMITTED_END] = true\n    this.readable = false\n    if (this[ASYNC]) defer(() => this[EMITEND2]())\n    else this[EMITEND2]()\n  }\n\n  [EMITEND2]() {\n    if (this[DECODER]) {\n      const data = this[DECODER].end()\n      if (data) {\n        for (const p of this[PIPES]) {\n          p.dest.write(data)\n        }\n        super.emit('data', data)\n      }\n    }\n\n    for (const p of this[PIPES]) {\n      p.end()\n    }\n    const ret = super.emit('end')\n    this.removeAllListeners('end')\n    return ret\n  }\n\n  // const all = await stream.collect()\n  collect() {\n    const buf = []\n    if (!this[OBJECTMODE]) buf.dataLength = 0\n    // set the promise first, in case an error is raised\n    // by triggering the flow here.\n    const p = this.promise()\n    this.on('data', c => {\n      buf.push(c)\n      if (!this[OBJECTMODE]) buf.dataLength += c.length\n    })\n    return p.then(() => buf)\n  }\n\n  // const data = await stream.concat()\n  concat() {\n    return this[OBJECTMODE]\n      ? Promise.reject(new Error('cannot concat in objectMode'))\n      : this.collect().then(buf =>\n          this[OBJECTMODE]\n            ? Promise.reject(new Error('cannot concat in objectMode'))\n            : this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength)\n        )\n  }\n\n  // stream.promise().then(() => done, er => emitted error)\n  promise() {\n    return new Promise((resolve, reject) => {\n      this.on(DESTROYED, () => reject(new Error('stream destroyed')))\n      this.on('error', er => reject(er))\n      this.on('end', () => resolve())\n    })\n  }\n\n  // for await (let chunk of stream)\n  [ASYNCITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      stopped = true\n      return Promise.resolve({ done: true })\n    }\n    const next = () => {\n      if (stopped) return stop()\n      const res = this.read()\n      if (res !== null) return Promise.resolve({ done: false, value: res })\n\n      if (this[EOF]) return stop()\n\n      let resolve = null\n      let reject = null\n      const onerr = er => {\n        this.removeListener('data', ondata)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        reject(er)\n      }\n      const ondata = value => {\n        this.removeListener('error', onerr)\n        this.removeListener('end', onend)\n        this.removeListener(DESTROYED, ondestroy)\n        this.pause()\n        resolve({ value: value, done: !!this[EOF] })\n      }\n      const onend = () => {\n        this.removeListener('error', onerr)\n        this.removeListener('data', ondata)\n        this.removeListener(DESTROYED, ondestroy)\n        stop()\n        resolve({ done: true })\n      }\n      const ondestroy = () => onerr(new Error('stream destroyed'))\n      return new Promise((res, rej) => {\n        reject = rej\n        resolve = res\n        this.once(DESTROYED, ondestroy)\n        this.once('error', onerr)\n        this.once('end', onend)\n        this.once('data', ondata)\n      })\n    }\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ASYNCITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  // for (let chunk of stream)\n  [ITERATOR]() {\n    let stopped = false\n    const stop = () => {\n      this.pause()\n      this.removeListener(ERROR, stop)\n      this.removeListener(DESTROYED, stop)\n      this.removeListener('end', stop)\n      stopped = true\n      return { done: true }\n    }\n\n    const next = () => {\n      if (stopped) return stop()\n      const value = this.read()\n      return value === null ? stop() : { value }\n    }\n    this.once('end', stop)\n    this.once(ERROR, stop)\n    this.once(DESTROYED, stop)\n\n    return {\n      next,\n      throw: stop,\n      return: stop,\n      [ITERATOR]() {\n        return this\n      },\n    }\n  }\n\n  destroy(er) {\n    if (this[DESTROYED]) {\n      if (er) this.emit('error', er)\n      else this.emit(DESTROYED)\n      return this\n    }\n\n    this[DESTROYED] = true\n\n    // throw away all buffered data, it's never coming out\n    this[BUFFER].length = 0\n    this[BUFFERLENGTH] = 0\n\n    if (typeof this.close === 'function' && !this[CLOSED]) this.close()\n\n    if (er) this.emit('error', er)\n    // if no error to emit, still reject pending promises\n    else this.emit(DESTROYED)\n\n    return this\n  }\n\n  static isStream(s) {\n    return (\n      !!s &&\n      (s instanceof Minipass ||\n        s instanceof Stream ||\n        (s instanceof EE &&\n          // readable\n          (typeof s.pipe === 'function' ||\n            // writable\n            (typeof s.write === 'function' && typeof s.end === 'function'))))\n    )\n  }\n}\n\nexports.Minipass = Minipass\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFyL25vZGVfbW9kdWxlcy9taW5pcGFzcy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxtQkFBTyxDQUFDLHNCQUFRO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxzQkFBUTtBQUMvQixzQkFBc0IsbUJBQU8sQ0FBQyxzQ0FBZ0I7QUFDOUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMseUJBQXlCO0FBQ3ZFO0FBQ0E7QUFDQSw2Q0FBNkMsd0JBQXdCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVOztBQUVWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixZQUFZO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHlCQUF5Qjs7QUFFMUU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixpQ0FBaUM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3Rhci9ub2RlX21vZHVsZXMvbWluaXBhc3MvaW5kZXguanM/YmY2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcbmNvbnN0IHByb2MgPVxuICB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzc1xuICAgID8gcHJvY2Vzc1xuICAgIDoge1xuICAgICAgICBzdGRvdXQ6IG51bGwsXG4gICAgICAgIHN0ZGVycjogbnVsbCxcbiAgICAgIH1cbmNvbnN0IEVFID0gcmVxdWlyZSgnZXZlbnRzJylcbmNvbnN0IFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpXG5jb25zdCBzdHJpbmdkZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXInKVxuY29uc3QgU0QgPSBzdHJpbmdkZWNvZGVyLlN0cmluZ0RlY29kZXJcblxuY29uc3QgRU9GID0gU3ltYm9sKCdFT0YnKVxuY29uc3QgTUFZQkVfRU1JVF9FTkQgPSBTeW1ib2woJ21heWJlRW1pdEVuZCcpXG5jb25zdCBFTUlUVEVEX0VORCA9IFN5bWJvbCgnZW1pdHRlZEVuZCcpXG5jb25zdCBFTUlUVElOR19FTkQgPSBTeW1ib2woJ2VtaXR0aW5nRW5kJylcbmNvbnN0IEVNSVRURURfRVJST1IgPSBTeW1ib2woJ2VtaXR0ZWRFcnJvcicpXG5jb25zdCBDTE9TRUQgPSBTeW1ib2woJ2Nsb3NlZCcpXG5jb25zdCBSRUFEID0gU3ltYm9sKCdyZWFkJylcbmNvbnN0IEZMVVNIID0gU3ltYm9sKCdmbHVzaCcpXG5jb25zdCBGTFVTSENIVU5LID0gU3ltYm9sKCdmbHVzaENodW5rJylcbmNvbnN0IEVOQ09ESU5HID0gU3ltYm9sKCdlbmNvZGluZycpXG5jb25zdCBERUNPREVSID0gU3ltYm9sKCdkZWNvZGVyJylcbmNvbnN0IEZMT1dJTkcgPSBTeW1ib2woJ2Zsb3dpbmcnKVxuY29uc3QgUEFVU0VEID0gU3ltYm9sKCdwYXVzZWQnKVxuY29uc3QgUkVTVU1FID0gU3ltYm9sKCdyZXN1bWUnKVxuY29uc3QgQlVGRkVSID0gU3ltYm9sKCdidWZmZXInKVxuY29uc3QgUElQRVMgPSBTeW1ib2woJ3BpcGVzJylcbmNvbnN0IEJVRkZFUkxFTkdUSCA9IFN5bWJvbCgnYnVmZmVyTGVuZ3RoJylcbmNvbnN0IEJVRkZFUlBVU0ggPSBTeW1ib2woJ2J1ZmZlclB1c2gnKVxuY29uc3QgQlVGRkVSU0hJRlQgPSBTeW1ib2woJ2J1ZmZlclNoaWZ0JylcbmNvbnN0IE9CSkVDVE1PREUgPSBTeW1ib2woJ29iamVjdE1vZGUnKVxuLy8gaW50ZXJuYWwgZXZlbnQgd2hlbiBzdHJlYW0gaXMgZGVzdHJveWVkXG5jb25zdCBERVNUUk9ZRUQgPSBTeW1ib2woJ2Rlc3Ryb3llZCcpXG4vLyBpbnRlcm5hbCBldmVudCB3aGVuIHN0cmVhbSBoYXMgYW4gZXJyb3JcbmNvbnN0IEVSUk9SID0gU3ltYm9sKCdlcnJvcicpXG5jb25zdCBFTUlUREFUQSA9IFN5bWJvbCgnZW1pdERhdGEnKVxuY29uc3QgRU1JVEVORCA9IFN5bWJvbCgnZW1pdEVuZCcpXG5jb25zdCBFTUlURU5EMiA9IFN5bWJvbCgnZW1pdEVuZDInKVxuY29uc3QgQVNZTkMgPSBTeW1ib2woJ2FzeW5jJylcbmNvbnN0IEFCT1JUID0gU3ltYm9sKCdhYm9ydCcpXG5jb25zdCBBQk9SVEVEID0gU3ltYm9sKCdhYm9ydGVkJylcbmNvbnN0IFNJR05BTCA9IFN5bWJvbCgnc2lnbmFsJylcblxuY29uc3QgZGVmZXIgPSBmbiA9PiBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZuKVxuXG4vLyBUT0RPIHJlbW92ZSB3aGVuIE5vZGUgdjggc3VwcG9ydCBkcm9wc1xuY29uc3QgZG9JdGVyID0gZ2xvYmFsLl9NUF9OT19JVEVSQVRPUl9TWU1CT0xTXyAhPT0gJzEnXG5jb25zdCBBU1lOQ0lURVJBVE9SID1cbiAgKGRvSXRlciAmJiBTeW1ib2wuYXN5bmNJdGVyYXRvcikgfHwgU3ltYm9sKCdhc3luY0l0ZXJhdG9yIG5vdCBpbXBsZW1lbnRlZCcpXG5jb25zdCBJVEVSQVRPUiA9XG4gIChkb0l0ZXIgJiYgU3ltYm9sLml0ZXJhdG9yKSB8fCBTeW1ib2woJ2l0ZXJhdG9yIG5vdCBpbXBsZW1lbnRlZCcpXG5cbi8vIGV2ZW50cyB0aGF0IG1lYW4gJ3RoZSBzdHJlYW0gaXMgb3Zlcidcbi8vIHRoZXNlIGFyZSB0cmVhdGVkIHNwZWNpYWxseSwgYW5kIHJlLWVtaXR0ZWRcbi8vIGlmIHRoZXkgYXJlIGxpc3RlbmVkIGZvciBhZnRlciBlbWl0dGluZy5cbmNvbnN0IGlzRW5kaXNoID0gZXYgPT4gZXYgPT09ICdlbmQnIHx8IGV2ID09PSAnZmluaXNoJyB8fCBldiA9PT0gJ3ByZWZpbmlzaCdcblxuY29uc3QgaXNBcnJheUJ1ZmZlciA9IGIgPT5cbiAgYiBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8XG4gICh0eXBlb2YgYiA9PT0gJ29iamVjdCcgJiZcbiAgICBiLmNvbnN0cnVjdG9yICYmXG4gICAgYi5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXG4gICAgYi5ieXRlTGVuZ3RoID49IDApXG5cbmNvbnN0IGlzQXJyYXlCdWZmZXJWaWV3ID0gYiA9PiAhQnVmZmVyLmlzQnVmZmVyKGIpICYmIEFycmF5QnVmZmVyLmlzVmlldyhiKVxuXG5jbGFzcyBQaXBlIHtcbiAgY29uc3RydWN0b3Ioc3JjLCBkZXN0LCBvcHRzKSB7XG4gICAgdGhpcy5zcmMgPSBzcmNcbiAgICB0aGlzLmRlc3QgPSBkZXN0XG4gICAgdGhpcy5vcHRzID0gb3B0c1xuICAgIHRoaXMub25kcmFpbiA9ICgpID0+IHNyY1tSRVNVTUVdKClcbiAgICBkZXN0Lm9uKCdkcmFpbicsIHRoaXMub25kcmFpbilcbiAgfVxuICB1bnBpcGUoKSB7XG4gICAgdGhpcy5kZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIHRoaXMub25kcmFpbilcbiAgfVxuICAvLyBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAtIG9ubHkgaGVyZSBmb3IgdGhlIHByb3RvdHlwZVxuICBwcm94eUVycm9ycygpIHt9XG4gIGVuZCgpIHtcbiAgICB0aGlzLnVucGlwZSgpXG4gICAgaWYgKHRoaXMub3B0cy5lbmQpIHRoaXMuZGVzdC5lbmQoKVxuICB9XG59XG5cbmNsYXNzIFBpcGVQcm94eUVycm9ycyBleHRlbmRzIFBpcGUge1xuICB1bnBpcGUoKSB7XG4gICAgdGhpcy5zcmMucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgdGhpcy5wcm94eUVycm9ycylcbiAgICBzdXBlci51bnBpcGUoKVxuICB9XG4gIGNvbnN0cnVjdG9yKHNyYywgZGVzdCwgb3B0cykge1xuICAgIHN1cGVyKHNyYywgZGVzdCwgb3B0cylcbiAgICB0aGlzLnByb3h5RXJyb3JzID0gZXIgPT4gZGVzdC5lbWl0KCdlcnJvcicsIGVyKVxuICAgIHNyYy5vbignZXJyb3InLCB0aGlzLnByb3h5RXJyb3JzKVxuICB9XG59XG5cbmNsYXNzIE1pbmlwYXNzIGV4dGVuZHMgU3RyZWFtIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKClcbiAgICB0aGlzW0ZMT1dJTkddID0gZmFsc2VcbiAgICAvLyB3aGV0aGVyIHdlJ3JlIGV4cGxpY2l0bHkgcGF1c2VkXG4gICAgdGhpc1tQQVVTRURdID0gZmFsc2VcbiAgICB0aGlzW1BJUEVTXSA9IFtdXG4gICAgdGhpc1tCVUZGRVJdID0gW11cbiAgICB0aGlzW09CSkVDVE1PREVdID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5vYmplY3RNb2RlKSB8fCBmYWxzZVxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB0aGlzW0VOQ09ESU5HXSA9IG51bGxcbiAgICBlbHNlIHRoaXNbRU5DT0RJTkddID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5lbmNvZGluZykgfHwgbnVsbFxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSA9PT0gJ2J1ZmZlcicpIHRoaXNbRU5DT0RJTkddID0gbnVsbFxuICAgIHRoaXNbQVNZTkNdID0gKG9wdGlvbnMgJiYgISFvcHRpb25zLmFzeW5jKSB8fCBmYWxzZVxuICAgIHRoaXNbREVDT0RFUl0gPSB0aGlzW0VOQ09ESU5HXSA/IG5ldyBTRCh0aGlzW0VOQ09ESU5HXSkgOiBudWxsXG4gICAgdGhpc1tFT0ZdID0gZmFsc2VcbiAgICB0aGlzW0VNSVRURURfRU5EXSA9IGZhbHNlXG4gICAgdGhpc1tFTUlUVElOR19FTkRdID0gZmFsc2VcbiAgICB0aGlzW0NMT1NFRF0gPSBmYWxzZVxuICAgIHRoaXNbRU1JVFRFRF9FUlJPUl0gPSBudWxsXG4gICAgdGhpcy53cml0YWJsZSA9IHRydWVcbiAgICB0aGlzLnJlYWRhYmxlID0gdHJ1ZVxuICAgIHRoaXNbQlVGRkVSTEVOR1RIXSA9IDBcbiAgICB0aGlzW0RFU1RST1lFRF0gPSBmYWxzZVxuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZGVidWdFeHBvc2VCdWZmZXIgPT09IHRydWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnYnVmZmVyJywgeyBnZXQ6ICgpID0+IHRoaXNbQlVGRkVSXSB9KVxuICAgIH1cbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnRXhwb3NlUGlwZXMgPT09IHRydWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAncGlwZXMnLCB7IGdldDogKCkgPT4gdGhpc1tQSVBFU10gfSlcbiAgICB9XG4gICAgdGhpc1tTSUdOQUxdID0gb3B0aW9ucyAmJiBvcHRpb25zLnNpZ25hbFxuICAgIHRoaXNbQUJPUlRFRF0gPSBmYWxzZVxuICAgIGlmICh0aGlzW1NJR05BTF0pIHtcbiAgICAgIHRoaXNbU0lHTkFMXS5hZGRFdmVudExpc3RlbmVyKCdhYm9ydCcsICgpID0+IHRoaXNbQUJPUlRdKCkpXG4gICAgICBpZiAodGhpc1tTSUdOQUxdLmFib3J0ZWQpIHtcbiAgICAgICAgdGhpc1tBQk9SVF0oKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGdldCBidWZmZXJMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXNbQlVGRkVSTEVOR1RIXVxuICB9XG5cbiAgZ2V0IGVuY29kaW5nKCkge1xuICAgIHJldHVybiB0aGlzW0VOQ09ESU5HXVxuICB9XG4gIHNldCBlbmNvZGluZyhlbmMpIHtcbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSkgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgc2V0IGVuY29kaW5nIGluIG9iamVjdE1vZGUnKVxuXG4gICAgaWYgKFxuICAgICAgdGhpc1tFTkNPRElOR10gJiZcbiAgICAgIGVuYyAhPT0gdGhpc1tFTkNPRElOR10gJiZcbiAgICAgICgodGhpc1tERUNPREVSXSAmJiB0aGlzW0RFQ09ERVJdLmxhc3ROZWVkKSB8fCB0aGlzW0JVRkZFUkxFTkdUSF0pXG4gICAgKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3QgY2hhbmdlIGVuY29kaW5nJylcblxuICAgIGlmICh0aGlzW0VOQ09ESU5HXSAhPT0gZW5jKSB7XG4gICAgICB0aGlzW0RFQ09ERVJdID0gZW5jID8gbmV3IFNEKGVuYykgOiBudWxsXG4gICAgICBpZiAodGhpc1tCVUZGRVJdLmxlbmd0aClcbiAgICAgICAgdGhpc1tCVUZGRVJdID0gdGhpc1tCVUZGRVJdLm1hcChjaHVuayA9PiB0aGlzW0RFQ09ERVJdLndyaXRlKGNodW5rKSlcbiAgICB9XG5cbiAgICB0aGlzW0VOQ09ESU5HXSA9IGVuY1xuICB9XG5cbiAgc2V0RW5jb2RpbmcoZW5jKSB7XG4gICAgdGhpcy5lbmNvZGluZyA9IGVuY1xuICB9XG5cbiAgZ2V0IG9iamVjdE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXNbT0JKRUNUTU9ERV1cbiAgfVxuICBzZXQgb2JqZWN0TW9kZShvbSkge1xuICAgIHRoaXNbT0JKRUNUTU9ERV0gPSB0aGlzW09CSkVDVE1PREVdIHx8ICEhb21cbiAgfVxuXG4gIGdldCBbJ2FzeW5jJ10oKSB7XG4gICAgcmV0dXJuIHRoaXNbQVNZTkNdXG4gIH1cbiAgc2V0IFsnYXN5bmMnXShhKSB7XG4gICAgdGhpc1tBU1lOQ10gPSB0aGlzW0FTWU5DXSB8fCAhIWFcbiAgfVxuXG4gIC8vIGRyb3AgZXZlcnl0aGluZyBhbmQgZ2V0IG91dCBvZiB0aGUgZmxvdyBjb21wbGV0ZWx5XG4gIFtBQk9SVF0oKSB7XG4gICAgdGhpc1tBQk9SVEVEXSA9IHRydWVcbiAgICB0aGlzLmVtaXQoJ2Fib3J0JywgdGhpc1tTSUdOQUxdLnJlYXNvbilcbiAgICB0aGlzLmRlc3Ryb3kodGhpc1tTSUdOQUxdLnJlYXNvbilcbiAgfVxuXG4gIGdldCBhYm9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzW0FCT1JURURdXG4gIH1cbiAgc2V0IGFib3J0ZWQoXykge31cblxuICB3cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXNbQUJPUlRFRF0pIHJldHVybiBmYWxzZVxuICAgIGlmICh0aGlzW0VPRl0pIHRocm93IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJylcblxuICAgIGlmICh0aGlzW0RFU1RST1lFRF0pIHtcbiAgICAgIHRoaXMuZW1pdChcbiAgICAgICAgJ2Vycm9yJyxcbiAgICAgICAgT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICBuZXcgRXJyb3IoJ0Nhbm5vdCBjYWxsIHdyaXRlIGFmdGVyIGEgc3RyZWFtIHdhcyBkZXN0cm95ZWQnKSxcbiAgICAgICAgICB7IGNvZGU6ICdFUlJfU1RSRUFNX0RFU1RST1lFRCcgfVxuICAgICAgICApXG4gICAgICApXG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIChjYiA9IGVuY29kaW5nKSwgKGVuY29kaW5nID0gJ3V0ZjgnKVxuXG4gICAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICAgIGNvbnN0IGZuID0gdGhpc1tBU1lOQ10gPyBkZWZlciA6IGYgPT4gZigpXG5cbiAgICAvLyBjb252ZXJ0IGFycmF5IGJ1ZmZlcnMgYW5kIHR5cGVkIGFycmF5IHZpZXdzIGludG8gYnVmZmVyc1xuICAgIC8vIGF0IHNvbWUgcG9pbnQgaW4gdGhlIGZ1dHVyZSwgd2UgbWF5IHdhbnQgdG8gZG8gdGhlIG9wcG9zaXRlIVxuICAgIC8vIGxlYXZlIHN0cmluZ3MgYW5kIGJ1ZmZlcnMgYXMtaXNcbiAgICAvLyBhbnl0aGluZyBlbHNlIHN3aXRjaGVzIHVzIGludG8gb2JqZWN0IG1vZGVcbiAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0gJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhjaHVuaykpXG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmsuYnVmZmVyLCBjaHVuay5ieXRlT2Zmc2V0LCBjaHVuay5ieXRlTGVuZ3RoKVxuICAgICAgZWxzZSBpZiAoaXNBcnJheUJ1ZmZlcihjaHVuaykpIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmspXG4gICAgICBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnKVxuICAgICAgICAvLyB1c2UgdGhlIHNldHRlciBzbyB3ZSB0aHJvdyBpZiB3ZSBoYXZlIGVuY29kaW5nIHNldFxuICAgICAgICB0aGlzLm9iamVjdE1vZGUgPSB0cnVlXG4gICAgfVxuXG4gICAgLy8gaGFuZGxlIG9iamVjdCBtb2RlIHVwIGZyb250LCBzaW5jZSBpdCdzIHNpbXBsZXJcbiAgICAvLyB0aGlzIHlpZWxkcyBiZXR0ZXIgcGVyZm9ybWFuY2UsIGZld2VyIGNoZWNrcyBsYXRlci5cbiAgICBpZiAodGhpc1tPQkpFQ1RNT0RFXSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmIC0gbWF5YmUgaW1wb3NzaWJsZT8gKi9cbiAgICAgIGlmICh0aGlzLmZsb3dpbmcgJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKSB0aGlzW0ZMVVNIXSh0cnVlKVxuXG4gICAgICBpZiAodGhpcy5mbG93aW5nKSB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuaylcbiAgICAgIGVsc2UgdGhpc1tCVUZGRVJQVVNIXShjaHVuaylcblxuICAgICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMCkgdGhpcy5lbWl0KCdyZWFkYWJsZScpXG5cbiAgICAgIGlmIChjYikgZm4oY2IpXG5cbiAgICAgIHJldHVybiB0aGlzLmZsb3dpbmdcbiAgICB9XG5cbiAgICAvLyBhdCB0aGlzIHBvaW50IHRoZSBjaHVuayBpcyBhIGJ1ZmZlciBvciBzdHJpbmdcbiAgICAvLyBkb24ndCBidWZmZXIgaXQgdXAgb3Igc2VuZCBpdCB0byB0aGUgZGVjb2RlclxuICAgIGlmICghY2h1bmsubGVuZ3RoKSB7XG4gICAgICBpZiAodGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKSB0aGlzLmVtaXQoJ3JlYWRhYmxlJylcbiAgICAgIGlmIChjYikgZm4oY2IpXG4gICAgICByZXR1cm4gdGhpcy5mbG93aW5nXG4gICAgfVxuXG4gICAgLy8gZmFzdC1wYXRoIHdyaXRpbmcgc3RyaW5ncyBvZiBzYW1lIGVuY29kaW5nIHRvIGEgc3RyZWFtIHdpdGhcbiAgICAvLyBhbiBlbXB0eSBidWZmZXIsIHNraXBwaW5nIHRoZSBidWZmZXIvZGVjb2RlciBkYW5jZVxuICAgIGlmIChcbiAgICAgIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycgJiZcbiAgICAgIC8vIHVubGVzcyBpdCBpcyBhIHN0cmluZyBhbHJlYWR5IHJlYWR5IGZvciB1cyB0byB1c2VcbiAgICAgICEoZW5jb2RpbmcgPT09IHRoaXNbRU5DT0RJTkddICYmICF0aGlzW0RFQ09ERVJdLmxhc3ROZWVkKVxuICAgICkge1xuICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpXG4gICAgfVxuXG4gICAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihjaHVuaykgJiYgdGhpc1tFTkNPRElOR10pXG4gICAgICBjaHVuayA9IHRoaXNbREVDT0RFUl0ud3JpdGUoY2h1bmspXG5cbiAgICAvLyBOb3RlOiBmbHVzaGluZyBDQU4gcG90ZW50aWFsbHkgc3dpdGNoIHVzIGludG8gbm90LWZsb3dpbmcgbW9kZVxuICAgIGlmICh0aGlzLmZsb3dpbmcgJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKSB0aGlzW0ZMVVNIXSh0cnVlKVxuXG4gICAgaWYgKHRoaXMuZmxvd2luZykgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspXG4gICAgZWxzZSB0aGlzW0JVRkZFUlBVU0hdKGNodW5rKVxuXG4gICAgaWYgKHRoaXNbQlVGRkVSTEVOR1RIXSAhPT0gMCkgdGhpcy5lbWl0KCdyZWFkYWJsZScpXG5cbiAgICBpZiAoY2IpIGZuKGNiKVxuXG4gICAgcmV0dXJuIHRoaXMuZmxvd2luZ1xuICB9XG5cbiAgcmVhZChuKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSkgcmV0dXJuIG51bGxcblxuICAgIGlmICh0aGlzW0JVRkZFUkxFTkdUSF0gPT09IDAgfHwgbiA9PT0gMCB8fCBuID4gdGhpc1tCVUZGRVJMRU5HVEhdKSB7XG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gbnVsbFxuICAgIH1cblxuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSBuID0gbnVsbFxuXG4gICAgaWYgKHRoaXNbQlVGRkVSXS5sZW5ndGggPiAxICYmICF0aGlzW09CSkVDVE1PREVdKSB7XG4gICAgICBpZiAodGhpcy5lbmNvZGluZykgdGhpc1tCVUZGRVJdID0gW3RoaXNbQlVGRkVSXS5qb2luKCcnKV1cbiAgICAgIGVsc2UgdGhpc1tCVUZGRVJdID0gW0J1ZmZlci5jb25jYXQodGhpc1tCVUZGRVJdLCB0aGlzW0JVRkZFUkxFTkdUSF0pXVxuICAgIH1cblxuICAgIGNvbnN0IHJldCA9IHRoaXNbUkVBRF0obiB8fCBudWxsLCB0aGlzW0JVRkZFUl1bMF0pXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtSRUFEXShuLCBjaHVuaykge1xuICAgIGlmIChuID09PSBjaHVuay5sZW5ndGggfHwgbiA9PT0gbnVsbCkgdGhpc1tCVUZGRVJTSElGVF0oKVxuICAgIGVsc2Uge1xuICAgICAgdGhpc1tCVUZGRVJdWzBdID0gY2h1bmsuc2xpY2UobilcbiAgICAgIGNodW5rID0gY2h1bmsuc2xpY2UoMCwgbilcbiAgICAgIHRoaXNbQlVGRkVSTEVOR1RIXSAtPSBuXG4gICAgfVxuXG4gICAgdGhpcy5lbWl0KCdkYXRhJywgY2h1bmspXG5cbiAgICBpZiAoIXRoaXNbQlVGRkVSXS5sZW5ndGggJiYgIXRoaXNbRU9GXSkgdGhpcy5lbWl0KCdkcmFpbicpXG5cbiAgICByZXR1cm4gY2h1bmtcbiAgfVxuXG4gIGVuZChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykgKGNiID0gY2h1bmspLCAoY2h1bmsgPSBudWxsKVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIChjYiA9IGVuY29kaW5nKSwgKGVuY29kaW5nID0gJ3V0ZjgnKVxuICAgIGlmIChjaHVuaykgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpXG4gICAgaWYgKGNiKSB0aGlzLm9uY2UoJ2VuZCcsIGNiKVxuICAgIHRoaXNbRU9GXSA9IHRydWVcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2VcblxuICAgIC8vIGlmIHdlIGhhdmVuJ3Qgd3JpdHRlbiBhbnl0aGluZywgdGhlbiBnbyBhaGVhZCBhbmQgZW1pdCxcbiAgICAvLyBldmVuIGlmIHdlJ3JlIG5vdCByZWFkaW5nLlxuICAgIC8vIHdlJ2xsIHJlLWVtaXQgaWYgYSBuZXcgJ2VuZCcgbGlzdGVuZXIgaXMgYWRkZWQgYW55d2F5LlxuICAgIC8vIFRoaXMgbWFrZXMgTVAgbW9yZSBzdWl0YWJsZSB0byB3cml0ZS1vbmx5IHVzZSBjYXNlcy5cbiAgICBpZiAodGhpcy5mbG93aW5nIHx8ICF0aGlzW1BBVVNFRF0pIHRoaXNbTUFZQkVfRU1JVF9FTkRdKClcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgLy8gZG9uJ3QgbGV0IHRoZSBpbnRlcm5hbCByZXN1bWUgYmUgb3ZlcndyaXR0ZW5cbiAgW1JFU1VNRV0oKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSkgcmV0dXJuXG5cbiAgICB0aGlzW1BBVVNFRF0gPSBmYWxzZVxuICAgIHRoaXNbRkxPV0lOR10gPSB0cnVlXG4gICAgdGhpcy5lbWl0KCdyZXN1bWUnKVxuICAgIGlmICh0aGlzW0JVRkZFUl0ubGVuZ3RoKSB0aGlzW0ZMVVNIXSgpXG4gICAgZWxzZSBpZiAodGhpc1tFT0ZdKSB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgZWxzZSB0aGlzLmVtaXQoJ2RyYWluJylcbiAgfVxuXG4gIHJlc3VtZSgpIHtcbiAgICByZXR1cm4gdGhpc1tSRVNVTUVdKClcbiAgfVxuXG4gIHBhdXNlKCkge1xuICAgIHRoaXNbRkxPV0lOR10gPSBmYWxzZVxuICAgIHRoaXNbUEFVU0VEXSA9IHRydWVcbiAgfVxuXG4gIGdldCBkZXN0cm95ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXNbREVTVFJPWUVEXVxuICB9XG5cbiAgZ2V0IGZsb3dpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXNbRkxPV0lOR11cbiAgfVxuXG4gIGdldCBwYXVzZWQoKSB7XG4gICAgcmV0dXJuIHRoaXNbUEFVU0VEXVxuICB9XG5cbiAgW0JVRkZFUlBVU0hdKGNodW5rKSB7XG4gICAgaWYgKHRoaXNbT0JKRUNUTU9ERV0pIHRoaXNbQlVGRkVSTEVOR1RIXSArPSAxXG4gICAgZWxzZSB0aGlzW0JVRkZFUkxFTkdUSF0gKz0gY2h1bmsubGVuZ3RoXG4gICAgdGhpc1tCVUZGRVJdLnB1c2goY2h1bmspXG4gIH1cblxuICBbQlVGRkVSU0hJRlRdKCkge1xuICAgIGlmICh0aGlzW09CSkVDVE1PREVdKSB0aGlzW0JVRkZFUkxFTkdUSF0gLT0gMVxuICAgIGVsc2UgdGhpc1tCVUZGRVJMRU5HVEhdIC09IHRoaXNbQlVGRkVSXVswXS5sZW5ndGhcbiAgICByZXR1cm4gdGhpc1tCVUZGRVJdLnNoaWZ0KClcbiAgfVxuXG4gIFtGTFVTSF0obm9EcmFpbikge1xuICAgIGRvIHt9IHdoaWxlICh0aGlzW0ZMVVNIQ0hVTktdKHRoaXNbQlVGRkVSU0hJRlRdKCkpICYmIHRoaXNbQlVGRkVSXS5sZW5ndGgpXG5cbiAgICBpZiAoIW5vRHJhaW4gJiYgIXRoaXNbQlVGRkVSXS5sZW5ndGggJiYgIXRoaXNbRU9GXSkgdGhpcy5lbWl0KCdkcmFpbicpXG4gIH1cblxuICBbRkxVU0hDSFVOS10oY2h1bmspIHtcbiAgICB0aGlzLmVtaXQoJ2RhdGEnLCBjaHVuaylcbiAgICByZXR1cm4gdGhpcy5mbG93aW5nXG4gIH1cblxuICBwaXBlKGRlc3QsIG9wdHMpIHtcbiAgICBpZiAodGhpc1tERVNUUk9ZRURdKSByZXR1cm5cblxuICAgIGNvbnN0IGVuZGVkID0gdGhpc1tFTUlUVEVEX0VORF1cbiAgICBvcHRzID0gb3B0cyB8fCB7fVxuICAgIGlmIChkZXN0ID09PSBwcm9jLnN0ZG91dCB8fCBkZXN0ID09PSBwcm9jLnN0ZGVycikgb3B0cy5lbmQgPSBmYWxzZVxuICAgIGVsc2Ugb3B0cy5lbmQgPSBvcHRzLmVuZCAhPT0gZmFsc2VcbiAgICBvcHRzLnByb3h5RXJyb3JzID0gISFvcHRzLnByb3h5RXJyb3JzXG5cbiAgICAvLyBwaXBpbmcgYW4gZW5kZWQgc3RyZWFtIGVuZHMgaW1tZWRpYXRlbHlcbiAgICBpZiAoZW5kZWQpIHtcbiAgICAgIGlmIChvcHRzLmVuZCkgZGVzdC5lbmQoKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzW1BJUEVTXS5wdXNoKFxuICAgICAgICAhb3B0cy5wcm94eUVycm9yc1xuICAgICAgICAgID8gbmV3IFBpcGUodGhpcywgZGVzdCwgb3B0cylcbiAgICAgICAgICA6IG5ldyBQaXBlUHJveHlFcnJvcnModGhpcywgZGVzdCwgb3B0cylcbiAgICAgIClcbiAgICAgIGlmICh0aGlzW0FTWU5DXSkgZGVmZXIoKCkgPT4gdGhpc1tSRVNVTUVdKCkpXG4gICAgICBlbHNlIHRoaXNbUkVTVU1FXSgpXG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3RcbiAgfVxuXG4gIHVucGlwZShkZXN0KSB7XG4gICAgY29uc3QgcCA9IHRoaXNbUElQRVNdLmZpbmQocCA9PiBwLmRlc3QgPT09IGRlc3QpXG4gICAgaWYgKHApIHtcbiAgICAgIHRoaXNbUElQRVNdLnNwbGljZSh0aGlzW1BJUEVTXS5pbmRleE9mKHApLCAxKVxuICAgICAgcC51bnBpcGUoKVxuICAgIH1cbiAgfVxuXG4gIGFkZExpc3RlbmVyKGV2LCBmbikge1xuICAgIHJldHVybiB0aGlzLm9uKGV2LCBmbilcbiAgfVxuXG4gIG9uKGV2LCBmbikge1xuICAgIGNvbnN0IHJldCA9IHN1cGVyLm9uKGV2LCBmbilcbiAgICBpZiAoZXYgPT09ICdkYXRhJyAmJiAhdGhpc1tQSVBFU10ubGVuZ3RoICYmICF0aGlzLmZsb3dpbmcpIHRoaXNbUkVTVU1FXSgpXG4gICAgZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScgJiYgdGhpc1tCVUZGRVJMRU5HVEhdICE9PSAwKVxuICAgICAgc3VwZXIuZW1pdCgncmVhZGFibGUnKVxuICAgIGVsc2UgaWYgKGlzRW5kaXNoKGV2KSAmJiB0aGlzW0VNSVRURURfRU5EXSkge1xuICAgICAgc3VwZXIuZW1pdChldilcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2KVxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdlcnJvcicgJiYgdGhpc1tFTUlUVEVEX0VSUk9SXSkge1xuICAgICAgaWYgKHRoaXNbQVNZTkNdKSBkZWZlcigoKSA9PiBmbi5jYWxsKHRoaXMsIHRoaXNbRU1JVFRFRF9FUlJPUl0pKVxuICAgICAgZWxzZSBmbi5jYWxsKHRoaXMsIHRoaXNbRU1JVFRFRF9FUlJPUl0pXG4gICAgfVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIGdldCBlbWl0dGVkRW5kKCkge1xuICAgIHJldHVybiB0aGlzW0VNSVRURURfRU5EXVxuICB9XG5cbiAgW01BWUJFX0VNSVRfRU5EXSgpIHtcbiAgICBpZiAoXG4gICAgICAhdGhpc1tFTUlUVElOR19FTkRdICYmXG4gICAgICAhdGhpc1tFTUlUVEVEX0VORF0gJiZcbiAgICAgICF0aGlzW0RFU1RST1lFRF0gJiZcbiAgICAgIHRoaXNbQlVGRkVSXS5sZW5ndGggPT09IDAgJiZcbiAgICAgIHRoaXNbRU9GXVxuICAgICkge1xuICAgICAgdGhpc1tFTUlUVElOR19FTkRdID0gdHJ1ZVxuICAgICAgdGhpcy5lbWl0KCdlbmQnKVxuICAgICAgdGhpcy5lbWl0KCdwcmVmaW5pc2gnKVxuICAgICAgdGhpcy5lbWl0KCdmaW5pc2gnKVxuICAgICAgaWYgKHRoaXNbQ0xPU0VEXSkgdGhpcy5lbWl0KCdjbG9zZScpXG4gICAgICB0aGlzW0VNSVRUSU5HX0VORF0gPSBmYWxzZVxuICAgIH1cbiAgfVxuXG4gIGVtaXQoZXYsIGRhdGEsIC4uLmV4dHJhKSB7XG4gICAgLy8gZXJyb3IgYW5kIGNsb3NlIGFyZSBvbmx5IGV2ZW50cyBhbGxvd2VkIGFmdGVyIGNhbGxpbmcgZGVzdHJveSgpXG4gICAgaWYgKGV2ICE9PSAnZXJyb3InICYmIGV2ICE9PSAnY2xvc2UnICYmIGV2ICE9PSBERVNUUk9ZRUQgJiYgdGhpc1tERVNUUk9ZRURdKVxuICAgICAgcmV0dXJuXG4gICAgZWxzZSBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgICAgcmV0dXJuICF0aGlzW09CSkVDVE1PREVdICYmICFkYXRhXG4gICAgICAgID8gZmFsc2VcbiAgICAgICAgOiB0aGlzW0FTWU5DXVxuICAgICAgICA/IGRlZmVyKCgpID0+IHRoaXNbRU1JVERBVEFdKGRhdGEpKVxuICAgICAgICA6IHRoaXNbRU1JVERBVEFdKGRhdGEpXG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2VuZCcpIHtcbiAgICAgIHJldHVybiB0aGlzW0VNSVRFTkRdKClcbiAgICB9IGVsc2UgaWYgKGV2ID09PSAnY2xvc2UnKSB7XG4gICAgICB0aGlzW0NMT1NFRF0gPSB0cnVlXG4gICAgICAvLyBkb24ndCBlbWl0IGNsb3NlIGJlZm9yZSAnZW5kJyBhbmQgJ2ZpbmlzaCdcbiAgICAgIGlmICghdGhpc1tFTUlUVEVEX0VORF0gJiYgIXRoaXNbREVTVFJPWUVEXSkgcmV0dXJuXG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdjbG9zZScpXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygnY2xvc2UnKVxuICAgICAgcmV0dXJuIHJldFxuICAgIH0gZWxzZSBpZiAoZXYgPT09ICdlcnJvcicpIHtcbiAgICAgIHRoaXNbRU1JVFRFRF9FUlJPUl0gPSBkYXRhXG4gICAgICBzdXBlci5lbWl0KEVSUk9SLCBkYXRhKVxuICAgICAgY29uc3QgcmV0ID1cbiAgICAgICAgIXRoaXNbU0lHTkFMXSB8fCB0aGlzLmxpc3RlbmVycygnZXJyb3InKS5sZW5ndGhcbiAgICAgICAgICA/IHN1cGVyLmVtaXQoJ2Vycm9yJywgZGF0YSlcbiAgICAgICAgICA6IGZhbHNlXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ3Jlc3VtZScpIHtcbiAgICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ3Jlc3VtZScpXG4gICAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfSBlbHNlIGlmIChldiA9PT0gJ2ZpbmlzaCcgfHwgZXYgPT09ICdwcmVmaW5pc2gnKSB7XG4gICAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KGV2KVxuICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoZXYpXG4gICAgICByZXR1cm4gcmV0XG4gICAgfVxuXG4gICAgLy8gU29tZSBvdGhlciB1bmtub3duIGV2ZW50XG4gICAgY29uc3QgcmV0ID0gc3VwZXIuZW1pdChldiwgZGF0YSwgLi4uZXh0cmEpXG4gICAgdGhpc1tNQVlCRV9FTUlUX0VORF0oKVxuICAgIHJldHVybiByZXRcbiAgfVxuXG4gIFtFTUlUREFUQV0oZGF0YSkge1xuICAgIGZvciAoY29uc3QgcCBvZiB0aGlzW1BJUEVTXSkge1xuICAgICAgaWYgKHAuZGVzdC53cml0ZShkYXRhKSA9PT0gZmFsc2UpIHRoaXMucGF1c2UoKVxuICAgIH1cbiAgICBjb25zdCByZXQgPSBzdXBlci5lbWl0KCdkYXRhJywgZGF0YSlcbiAgICB0aGlzW01BWUJFX0VNSVRfRU5EXSgpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgW0VNSVRFTkRdKCkge1xuICAgIGlmICh0aGlzW0VNSVRURURfRU5EXSkgcmV0dXJuXG5cbiAgICB0aGlzW0VNSVRURURfRU5EXSA9IHRydWVcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2VcbiAgICBpZiAodGhpc1tBU1lOQ10pIGRlZmVyKCgpID0+IHRoaXNbRU1JVEVORDJdKCkpXG4gICAgZWxzZSB0aGlzW0VNSVRFTkQyXSgpXG4gIH1cblxuICBbRU1JVEVORDJdKCkge1xuICAgIGlmICh0aGlzW0RFQ09ERVJdKSB7XG4gICAgICBjb25zdCBkYXRhID0gdGhpc1tERUNPREVSXS5lbmQoKVxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgZm9yIChjb25zdCBwIG9mIHRoaXNbUElQRVNdKSB7XG4gICAgICAgICAgcC5kZXN0LndyaXRlKGRhdGEpXG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuZW1pdCgnZGF0YScsIGRhdGEpXG4gICAgICB9XG4gICAgfVxuXG4gICAgZm9yIChjb25zdCBwIG9mIHRoaXNbUElQRVNdKSB7XG4gICAgICBwLmVuZCgpXG4gICAgfVxuICAgIGNvbnN0IHJldCA9IHN1cGVyLmVtaXQoJ2VuZCcpXG4gICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2VuZCcpXG4gICAgcmV0dXJuIHJldFxuICB9XG5cbiAgLy8gY29uc3QgYWxsID0gYXdhaXQgc3RyZWFtLmNvbGxlY3QoKVxuICBjb2xsZWN0KCkge1xuICAgIGNvbnN0IGJ1ZiA9IFtdXG4gICAgaWYgKCF0aGlzW09CSkVDVE1PREVdKSBidWYuZGF0YUxlbmd0aCA9IDBcbiAgICAvLyBzZXQgdGhlIHByb21pc2UgZmlyc3QsIGluIGNhc2UgYW4gZXJyb3IgaXMgcmFpc2VkXG4gICAgLy8gYnkgdHJpZ2dlcmluZyB0aGUgZmxvdyBoZXJlLlxuICAgIGNvbnN0IHAgPSB0aGlzLnByb21pc2UoKVxuICAgIHRoaXMub24oJ2RhdGEnLCBjID0+IHtcbiAgICAgIGJ1Zi5wdXNoKGMpXG4gICAgICBpZiAoIXRoaXNbT0JKRUNUTU9ERV0pIGJ1Zi5kYXRhTGVuZ3RoICs9IGMubGVuZ3RoXG4gICAgfSlcbiAgICByZXR1cm4gcC50aGVuKCgpID0+IGJ1ZilcbiAgfVxuXG4gIC8vIGNvbnN0IGRhdGEgPSBhd2FpdCBzdHJlYW0uY29uY2F0KClcbiAgY29uY2F0KCkge1xuICAgIHJldHVybiB0aGlzW09CSkVDVE1PREVdXG4gICAgICA/IFByb21pc2UucmVqZWN0KG5ldyBFcnJvcignY2Fubm90IGNvbmNhdCBpbiBvYmplY3RNb2RlJykpXG4gICAgICA6IHRoaXMuY29sbGVjdCgpLnRoZW4oYnVmID0+XG4gICAgICAgICAgdGhpc1tPQkpFQ1RNT0RFXVxuICAgICAgICAgICAgPyBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoJ2Nhbm5vdCBjb25jYXQgaW4gb2JqZWN0TW9kZScpKVxuICAgICAgICAgICAgOiB0aGlzW0VOQ09ESU5HXVxuICAgICAgICAgICAgPyBidWYuam9pbignJylcbiAgICAgICAgICAgIDogQnVmZmVyLmNvbmNhdChidWYsIGJ1Zi5kYXRhTGVuZ3RoKVxuICAgICAgICApXG4gIH1cblxuICAvLyBzdHJlYW0ucHJvbWlzZSgpLnRoZW4oKCkgPT4gZG9uZSwgZXIgPT4gZW1pdHRlZCBlcnJvcilcbiAgcHJvbWlzZSgpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5vbihERVNUUk9ZRUQsICgpID0+IHJlamVjdChuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSkpXG4gICAgICB0aGlzLm9uKCdlcnJvcicsIGVyID0+IHJlamVjdChlcikpXG4gICAgICB0aGlzLm9uKCdlbmQnLCAoKSA9PiByZXNvbHZlKCkpXG4gICAgfSlcbiAgfVxuXG4gIC8vIGZvciBhd2FpdCAobGV0IGNodW5rIG9mIHN0cmVhbSlcbiAgW0FTWU5DSVRFUkFUT1JdKCkge1xuICAgIGxldCBzdG9wcGVkID0gZmFsc2VcbiAgICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICBzdG9wcGVkID0gdHJ1ZVxuICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IHRydWUgfSlcbiAgICB9XG4gICAgY29uc3QgbmV4dCA9ICgpID0+IHtcbiAgICAgIGlmIChzdG9wcGVkKSByZXR1cm4gc3RvcCgpXG4gICAgICBjb25zdCByZXMgPSB0aGlzLnJlYWQoKVxuICAgICAgaWYgKHJlcyAhPT0gbnVsbCkgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh7IGRvbmU6IGZhbHNlLCB2YWx1ZTogcmVzIH0pXG5cbiAgICAgIGlmICh0aGlzW0VPRl0pIHJldHVybiBzdG9wKClcblxuICAgICAgbGV0IHJlc29sdmUgPSBudWxsXG4gICAgICBsZXQgcmVqZWN0ID0gbnVsbFxuICAgICAgY29uc3Qgb25lcnIgPSBlciA9PiB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpXG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKERFU1RST1lFRCwgb25kZXN0cm95KVxuICAgICAgICBzdG9wKClcbiAgICAgICAgcmVqZWN0KGVyKVxuICAgICAgfVxuICAgICAgY29uc3Qgb25kYXRhID0gdmFsdWUgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyKVxuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZClcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihERVNUUk9ZRUQsIG9uZGVzdHJveSlcbiAgICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICAgIHJlc29sdmUoeyB2YWx1ZTogdmFsdWUsIGRvbmU6ICEhdGhpc1tFT0ZdIH0pXG4gICAgICB9XG4gICAgICBjb25zdCBvbmVuZCA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycilcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSlcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihERVNUUk9ZRUQsIG9uZGVzdHJveSlcbiAgICAgICAgc3RvcCgpXG4gICAgICAgIHJlc29sdmUoeyBkb25lOiB0cnVlIH0pXG4gICAgICB9XG4gICAgICBjb25zdCBvbmRlc3Ryb3kgPSAoKSA9PiBvbmVycihuZXcgRXJyb3IoJ3N0cmVhbSBkZXN0cm95ZWQnKSlcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgICAgcmVqZWN0ID0gcmVqXG4gICAgICAgIHJlc29sdmUgPSByZXNcbiAgICAgICAgdGhpcy5vbmNlKERFU1RST1lFRCwgb25kZXN0cm95KVxuICAgICAgICB0aGlzLm9uY2UoJ2Vycm9yJywgb25lcnIpXG4gICAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpXG4gICAgICAgIHRoaXMub25jZSgnZGF0YScsIG9uZGF0YSlcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG5leHQsXG4gICAgICB0aHJvdzogc3RvcCxcbiAgICAgIHJldHVybjogc3RvcCxcbiAgICAgIFtBU1lOQ0lURVJBVE9SXSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH0sXG4gICAgfVxuICB9XG5cbiAgLy8gZm9yIChsZXQgY2h1bmsgb2Ygc3RyZWFtKVxuICBbSVRFUkFUT1JdKCkge1xuICAgIGxldCBzdG9wcGVkID0gZmFsc2VcbiAgICBjb25zdCBzdG9wID0gKCkgPT4ge1xuICAgICAgdGhpcy5wYXVzZSgpXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKEVSUk9SLCBzdG9wKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihERVNUUk9ZRUQsIHN0b3ApXG4gICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBzdG9wKVxuICAgICAgc3RvcHBlZCA9IHRydWVcbiAgICAgIHJldHVybiB7IGRvbmU6IHRydWUgfVxuICAgIH1cblxuICAgIGNvbnN0IG5leHQgPSAoKSA9PiB7XG4gICAgICBpZiAoc3RvcHBlZCkgcmV0dXJuIHN0b3AoKVxuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLnJlYWQoKVxuICAgICAgcmV0dXJuIHZhbHVlID09PSBudWxsID8gc3RvcCgpIDogeyB2YWx1ZSB9XG4gICAgfVxuICAgIHRoaXMub25jZSgnZW5kJywgc3RvcClcbiAgICB0aGlzLm9uY2UoRVJST1IsIHN0b3ApXG4gICAgdGhpcy5vbmNlKERFU1RST1lFRCwgc3RvcClcblxuICAgIHJldHVybiB7XG4gICAgICBuZXh0LFxuICAgICAgdGhyb3c6IHN0b3AsXG4gICAgICByZXR1cm46IHN0b3AsXG4gICAgICBbSVRFUkFUT1JdKCkge1xuICAgICAgICByZXR1cm4gdGhpc1xuICAgICAgfSxcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KGVyKSB7XG4gICAgaWYgKHRoaXNbREVTVFJPWUVEXSkge1xuICAgICAgaWYgKGVyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgICBlbHNlIHRoaXMuZW1pdChERVNUUk9ZRUQpXG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIHRoaXNbREVTVFJPWUVEXSA9IHRydWVcblxuICAgIC8vIHRocm93IGF3YXkgYWxsIGJ1ZmZlcmVkIGRhdGEsIGl0J3MgbmV2ZXIgY29taW5nIG91dFxuICAgIHRoaXNbQlVGRkVSXS5sZW5ndGggPSAwXG4gICAgdGhpc1tCVUZGRVJMRU5HVEhdID0gMFxuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmNsb3NlID09PSAnZnVuY3Rpb24nICYmICF0aGlzW0NMT1NFRF0pIHRoaXMuY2xvc2UoKVxuXG4gICAgaWYgKGVyKSB0aGlzLmVtaXQoJ2Vycm9yJywgZXIpXG4gICAgLy8gaWYgbm8gZXJyb3IgdG8gZW1pdCwgc3RpbGwgcmVqZWN0IHBlbmRpbmcgcHJvbWlzZXNcbiAgICBlbHNlIHRoaXMuZW1pdChERVNUUk9ZRUQpXG5cbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhdGljIGlzU3RyZWFtKHMpIHtcbiAgICByZXR1cm4gKFxuICAgICAgISFzICYmXG4gICAgICAocyBpbnN0YW5jZW9mIE1pbmlwYXNzIHx8XG4gICAgICAgIHMgaW5zdGFuY2VvZiBTdHJlYW0gfHxcbiAgICAgICAgKHMgaW5zdGFuY2VvZiBFRSAmJlxuICAgICAgICAgIC8vIHJlYWRhYmxlXG4gICAgICAgICAgKHR5cGVvZiBzLnBpcGUgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIC8vIHdyaXRhYmxlXG4gICAgICAgICAgICAodHlwZW9mIHMud3JpdGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHMuZW5kID09PSAnZnVuY3Rpb24nKSkpKVxuICAgIClcbiAgfVxufVxuXG5leHBvcnRzLk1pbmlwYXNzID0gTWluaXBhc3NcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/tar/node_modules/minipass/index.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\n\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */\nfunction concat(list, totalLength) {\n  if (list.length === 0) return EMPTY_BUFFER;\n  if (list.length === 1) return list[0];\n\n  const target = Buffer.allocUnsafe(totalLength);\n  let offset = 0;\n\n  for (let i = 0; i < list.length; i++) {\n    const buf = list[i];\n    target.set(buf, offset);\n    offset += buf.length;\n  }\n\n  if (offset < totalLength) {\n    return new FastBuffer(target.buffer, target.byteOffset, offset);\n  }\n\n  return target;\n}\n\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */\nfunction _mask(source, mask, output, offset, length) {\n  for (let i = 0; i < length; i++) {\n    output[offset + i] = source[i] ^ mask[i & 3];\n  }\n}\n\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */\nfunction _unmask(buffer, mask) {\n  for (let i = 0; i < buffer.length; i++) {\n    buffer[i] ^= mask[i & 3];\n  }\n}\n\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */\nfunction toArrayBuffer(buf) {\n  if (buf.length === buf.buffer.byteLength) {\n    return buf.buffer;\n  }\n\n  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */\nfunction toBuffer(data) {\n  toBuffer.readOnly = true;\n\n  if (Buffer.isBuffer(data)) return data;\n\n  let buf;\n\n  if (data instanceof ArrayBuffer) {\n    buf = new FastBuffer(data);\n  } else if (ArrayBuffer.isView(data)) {\n    buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n  } else {\n    buf = Buffer.from(data);\n    toBuffer.readOnly = false;\n  }\n\n  return buf;\n}\n\nmodule.exports = {\n  concat,\n  mask: _mask,\n  toArrayBuffer,\n  toBuffer,\n  unmask: _unmask\n};\n\n/* istanbul ignore else  */\nif (!{}.WS_NO_BUFFER_UTIL) {\n  try {\n    const bufferUtil = __webpack_require__(/*! bufferutil */ \"bufferutil\");\n\n    module.exports.mask = function (source, mask, output, offset, length) {\n      if (length < 48) _mask(source, mask, output, offset, length);\n      else bufferUtil.mask(source, mask, output, offset, length);\n    };\n\n    module.exports.unmask = function (buffer, mask) {\n      if (buffer.length < 32) _unmask(buffer, mask);\n      else bufferUtil.unmask(buffer, mask);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsZUFBZSxFQUFFLG1CQUFPLENBQUMsdURBQWE7O0FBRTlDOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQixXQUFXLFFBQVE7QUFDbkIsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFlBQVk7QUFDOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksYUFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFFBQVE7QUFDcEIsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLLEVBQVc7QUFDaEI7QUFDQSx1QkFBdUIsbUJBQU8sQ0FBQyw4QkFBWTs7QUFFM0MsSUFBSSxtQkFBbUI7QUFDdkI7QUFDQTtBQUNBOztBQUVBLElBQUkscUJBQXFCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcz9iYjA5Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBFTVBUWV9CVUZGRVIgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkge1xuICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcih0YXJnZXQuYnVmZmVyLCB0YXJnZXQuYnl0ZU9mZnNldCwgb2Zmc2V0KTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IGJ1Zi5idWZmZXIuYnl0ZUxlbmd0aCkge1xuICAgIHJldHVybiBidWYuYnVmZmVyO1xuICB9XG5cbiAgcmV0dXJuIGJ1Zi5idWZmZXIuc2xpY2UoYnVmLmJ5dGVPZmZzZXQsIGJ1Zi5ieXRlT2Zmc2V0ICsgYnVmLmxlbmd0aCk7XG59XG5cbi8qKlxuICogQ29udmVydHMgYGRhdGFgIHRvIGEgYEJ1ZmZlcmAuXG4gKlxuICogQHBhcmFtIHsqfSBkYXRhIFRoZSBkYXRhIHRvIGNvbnZlcnRcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGJ1ZmZlclxuICogQHRocm93cyB7VHlwZUVycm9yfVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0J1ZmZlcihkYXRhKSB7XG4gIHRvQnVmZmVyLnJlYWRPbmx5ID0gdHJ1ZTtcblxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKGRhdGEpKSByZXR1cm4gZGF0YTtcblxuICBsZXQgYnVmO1xuXG4gIGlmIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhKTtcbiAgfSBlbHNlIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcbiAgICBidWYgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmJ5dGVMZW5ndGgpO1xuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICAgIHRvQnVmZmVyLnJlYWRPbmx5ID0gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gYnVmO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uY2F0LFxuICBtYXNrOiBfbWFzayxcbiAgdG9BcnJheUJ1ZmZlcixcbiAgdG9CdWZmZXIsXG4gIHVubWFzazogX3VubWFza1xufTtcblxuLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovXG5pZiAoIXByb2Nlc3MuZW52LldTX05PX0JVRkZFUl9VVElMKSB7XG4gIHRyeSB7XG4gICAgY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJ2J1ZmZlcnV0aWwnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLm1hc2sgPSBmdW5jdGlvbiAoc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH07XG5cbiAgICBtb2R1bGUuZXhwb3J0cy51bm1hc2sgPSBmdW5jdGlvbiAoYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIC8vIENvbnRpbnVlIHJlZ2FyZGxlc3Mgb2YgdGhlIGVycm9yLlxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst BINARY_TYPES = ['nodebuffer', 'arraybuffer', 'fragments'];\nconst hasBlob = typeof Blob !== 'undefined';\n\nif (hasBlob) BINARY_TYPES.push('blob');\n\nmodule.exports = {\n  BINARY_TYPES,\n  EMPTY_BUFFER: Buffer.alloc(0),\n  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',\n  hasBlob,\n  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),\n  kListener: Symbol('kListener'),\n  kStatusCode: Symbol('status-code'),\n  kWebSocket: Symbol('websocket'),\n  NOOP: () => {}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanM/YmYzMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IEJJTkFSWV9UWVBFUyA9IFsnbm9kZWJ1ZmZlcicsICdhcnJheWJ1ZmZlcicsICdmcmFnbWVudHMnXTtcbmNvbnN0IGhhc0Jsb2IgPSB0eXBlb2YgQmxvYiAhPT0gJ3VuZGVmaW5lZCc7XG5cbmlmIChoYXNCbG9iKSBCSU5BUllfVFlQRVMucHVzaCgnYmxvYicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGhhc0Jsb2IsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlOiBTeW1ib2woJ2tJc0Zvck9uRXZlbnRBdHRyaWJ1dGUnKSxcbiAga0xpc3RlbmVyOiBTeW1ib2woJ2tMaXN0ZW5lcicpLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst kCode = Symbol('kCode');\nconst kData = Symbol('kData');\nconst kError = Symbol('kError');\nconst kMessage = Symbol('kMessage');\nconst kReason = Symbol('kReason');\nconst kTarget = Symbol('kTarget');\nconst kType = Symbol('kType');\nconst kWasClean = Symbol('kWasClean');\n\n/**\n * Class representing an event.\n */\nclass Event {\n  /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */\n  constructor(type) {\n    this[kTarget] = null;\n    this[kType] = type;\n  }\n\n  /**\n   * @type {*}\n   */\n  get target() {\n    return this[kTarget];\n  }\n\n  /**\n   * @type {String}\n   */\n  get type() {\n    return this[kType];\n  }\n}\n\nObject.defineProperty(Event.prototype, 'target', { enumerable: true });\nObject.defineProperty(Event.prototype, 'type', { enumerable: true });\n\n/**\n * Class representing a close event.\n *\n * @extends Event\n */\nclass CloseEvent extends Event {\n  /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kCode] = options.code === undefined ? 0 : options.code;\n    this[kReason] = options.reason === undefined ? '' : options.reason;\n    this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get code() {\n    return this[kCode];\n  }\n\n  /**\n   * @type {String}\n   */\n  get reason() {\n    return this[kReason];\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get wasClean() {\n    return this[kWasClean];\n  }\n}\n\nObject.defineProperty(CloseEvent.prototype, 'code', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'reason', { enumerable: true });\nObject.defineProperty(CloseEvent.prototype, 'wasClean', { enumerable: true });\n\n/**\n * Class representing an error event.\n *\n * @extends Event\n */\nclass ErrorEvent extends Event {\n  /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kError] = options.error === undefined ? null : options.error;\n    this[kMessage] = options.message === undefined ? '' : options.message;\n  }\n\n  /**\n   * @type {*}\n   */\n  get error() {\n    return this[kError];\n  }\n\n  /**\n   * @type {String}\n   */\n  get message() {\n    return this[kMessage];\n  }\n}\n\nObject.defineProperty(ErrorEvent.prototype, 'error', { enumerable: true });\nObject.defineProperty(ErrorEvent.prototype, 'message', { enumerable: true });\n\n/**\n * Class representing a message event.\n *\n * @extends Event\n */\nclass MessageEvent extends Event {\n  /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */\n  constructor(type, options = {}) {\n    super(type);\n\n    this[kData] = options.data === undefined ? null : options.data;\n  }\n\n  /**\n   * @type {*}\n   */\n  get data() {\n    return this[kData];\n  }\n}\n\nObject.defineProperty(MessageEvent.prototype, 'data', { enumerable: true });\n\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */\nconst EventTarget = {\n  /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */\n  addEventListener(type, handler, options = {}) {\n    for (const listener of this.listeners(type)) {\n      if (\n        !options[kForOnEventAttribute] &&\n        listener[kListener] === handler &&\n        !listener[kForOnEventAttribute]\n      ) {\n        return;\n      }\n    }\n\n    let wrapper;\n\n    if (type === 'message') {\n      wrapper = function onMessage(data, isBinary) {\n        const event = new MessageEvent('message', {\n          data: isBinary ? data : data.toString()\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'close') {\n      wrapper = function onClose(code, message) {\n        const event = new CloseEvent('close', {\n          code,\n          reason: message.toString(),\n          wasClean: this._closeFrameReceived && this._closeFrameSent\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'error') {\n      wrapper = function onError(error) {\n        const event = new ErrorEvent('error', {\n          error,\n          message: error.message\n        });\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else if (type === 'open') {\n      wrapper = function onOpen() {\n        const event = new Event('open');\n\n        event[kTarget] = this;\n        callListener(handler, this, event);\n      };\n    } else {\n      return;\n    }\n\n    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n    wrapper[kListener] = handler;\n\n    if (options.once) {\n      this.once(type, wrapper);\n    } else {\n      this.on(type, wrapper);\n    }\n  },\n\n  /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */\n  removeEventListener(type, handler) {\n    for (const listener of this.listeners(type)) {\n      if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n        this.removeListener(type, listener);\n        break;\n      }\n    }\n  }\n};\n\nmodule.exports = {\n  CloseEvent,\n  ErrorEvent,\n  Event,\n  EventTarget,\n  MessageEvent\n};\n\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */\nfunction callListener(listener, thisArg, event) {\n  if (typeof listener === 'object' && listener.handleEvent) {\n    listener.handleEvent.call(listener, event);\n  } else {\n    listener.call(thisArg, event);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLGtDQUFrQyxFQUFFLG1CQUFPLENBQUMsdURBQWE7O0FBRWpFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxXQUFXO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxtREFBbUQsa0JBQWtCO0FBQ3JFLGlEQUFpRCxrQkFBa0I7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNEQUFzRCxrQkFBa0I7QUFDeEUsd0RBQXdELGtCQUFrQjtBQUMxRSwwREFBMEQsa0JBQWtCOztBQUU1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGdDQUFnQztBQUNoQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx1REFBdUQsa0JBQWtCO0FBQ3pFLHlEQUF5RCxrQkFBa0I7O0FBRTNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLEdBQUc7QUFDaEI7QUFDQSxnQ0FBZ0M7QUFDaEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHdEQUF3RCxrQkFBa0I7O0FBRTFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsbUJBQW1CO0FBQ2hDLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxtQkFBbUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLG1CQUFtQjtBQUM5QixXQUFXLEdBQUc7QUFDZCxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanM/MDg2MyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsga0Zvck9uRXZlbnRBdHRyaWJ1dGUsIGtMaXN0ZW5lciB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3Qga0NvZGUgPSBTeW1ib2woJ2tDb2RlJyk7XG5jb25zdCBrRGF0YSA9IFN5bWJvbCgna0RhdGEnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgna0Vycm9yJyk7XG5jb25zdCBrTWVzc2FnZSA9IFN5bWJvbCgna01lc3NhZ2UnKTtcbmNvbnN0IGtSZWFzb24gPSBTeW1ib2woJ2tSZWFzb24nKTtcbmNvbnN0IGtUYXJnZXQgPSBTeW1ib2woJ2tUYXJnZXQnKTtcbmNvbnN0IGtUeXBlID0gU3ltYm9sKCdrVHlwZScpO1xuY29uc3Qga1dhc0NsZWFuID0gU3ltYm9sKCdrV2FzQ2xlYW4nKTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXZlbnQuXG4gKi9cbmNsYXNzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHRocm93cyB7VHlwZUVycm9yfSBJZiB0aGUgYHR5cGVgIGFyZ3VtZW50IGlzIG5vdCBzcGVjaWZpZWRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICB0aGlzW2tUYXJnZXRdID0gbnVsbDtcbiAgICB0aGlzW2tUeXBlXSA9IHR5cGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgdGFyZ2V0KCkge1xuICAgIHJldHVybiB0aGlzW2tUYXJnZXRdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpc1trVHlwZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3RhcmdldCcsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudC5wcm90b3R5cGUsICd0eXBlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIGNsb3NlIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIENsb3NlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYENsb3NlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb2RlPTBdIFRoZSBzdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucmVhc29uPScnXSBBIGh1bWFuLXJlYWRhYmxlIHN0cmluZyBleHBsYWluaW5nIHdoeVxuICAgKiAgICAgdGhlIGNvbm5lY3Rpb24gd2FzIGNsb3NlZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLndhc0NsZWFuPWZhbHNlXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlXG4gICAqICAgICBjb25uZWN0aW9uIHdhcyBjbGVhbmx5IGNsb3NlZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgc3VwZXIodHlwZSk7XG5cbiAgICB0aGlzW2tDb2RlXSA9IG9wdGlvbnMuY29kZSA9PT0gdW5kZWZpbmVkID8gMCA6IG9wdGlvbnMuY29kZTtcbiAgICB0aGlzW2tSZWFzb25dID0gb3B0aW9ucy5yZWFzb24gPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5yZWFzb247XG4gICAgdGhpc1trV2FzQ2xlYW5dID0gb3B0aW9ucy53YXNDbGVhbiA9PT0gdW5kZWZpbmVkID8gZmFsc2UgOiBvcHRpb25zLndhc0NsZWFuO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgY29kZSgpIHtcbiAgICByZXR1cm4gdGhpc1trQ29kZV07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCByZWFzb24oKSB7XG4gICAgcmV0dXJuIHRoaXNba1JlYXNvbl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Jvb2xlYW59XG4gICAqL1xuICBnZXQgd2FzQ2xlYW4oKSB7XG4gICAgcmV0dXJuIHRoaXNba1dhc0NsZWFuXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdjb2RlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAncmVhc29uJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KENsb3NlRXZlbnQucHJvdG90eXBlLCAnd2FzQ2xlYW4nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGFuIGVycm9yIGV2ZW50LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50XG4gKi9cbmNsYXNzIEVycm9yRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYEVycm9yRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZXJyb3I9bnVsbF0gVGhlIGVycm9yIHRoYXQgZ2VuZXJhdGVkIHRoaXMgZXZlbnRcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm1lc3NhZ2U9JyddIFRoZSBlcnJvciBtZXNzYWdlXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0Vycm9yXSA9IG9wdGlvbnMuZXJyb3IgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmVycm9yO1xuICAgIHRoaXNba01lc3NhZ2VdID0gb3B0aW9ucy5tZXNzYWdlID09PSB1bmRlZmluZWQgPyAnJyA6IG9wdGlvbnMubWVzc2FnZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCBlcnJvcigpIHtcbiAgICByZXR1cm4gdGhpc1trRXJyb3JdO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgbWVzc2FnZSgpIHtcbiAgICByZXR1cm4gdGhpc1trTWVzc2FnZV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEVycm9yRXZlbnQucHJvdG90eXBlLCAnZXJyb3InLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdtZXNzYWdlJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIG1lc3NhZ2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgTWVzc2FnZUV2ZW50IGV4dGVuZHMgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBNZXNzYWdlRXZlbnRgLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBIGRpY3Rpb25hcnkgb2JqZWN0IHRoYXQgYWxsb3dzIGZvciBzZXR0aW5nXG4gICAqICAgICBhdHRyaWJ1dGVzIHZpYSBvYmplY3QgbWVtYmVycyBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIEBwYXJhbSB7Kn0gW29wdGlvbnMuZGF0YT1udWxsXSBUaGUgbWVzc2FnZSBjb250ZW50XG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0RhdGFdID0gb3B0aW9ucy5kYXRhID09PSB1bmRlZmluZWQgPyBudWxsIDogb3B0aW9ucy5kYXRhO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXNba0RhdGFdO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShNZXNzYWdlRXZlbnQucHJvdG90eXBlLCAnZGF0YScsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBUaGlzIHByb3ZpZGVzIG1ldGhvZHMgZm9yIGVtdWxhdGluZyB0aGUgYEV2ZW50VGFyZ2V0YCBpbnRlcmZhY2UuIEl0J3Mgbm90XG4gKiBtZWFudCB0byBiZSB1c2VkIGRpcmVjdGx5LlxuICpcbiAqIEBtaXhpblxuICovXG5jb25zdCBFdmVudFRhcmdldCA9IHtcbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGFuIGV2ZW50IGxpc3RlbmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGV2ZW50IHR5cGUgdG8gbGlzdGVuIGZvclxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChcbiAgICAgICAgIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdICYmXG4gICAgICAgIGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiZcbiAgICAgICAgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Nsb3NlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uQ2xvc2UoY29kZSwgbWVzc2FnZSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBDbG9zZUV2ZW50KCdjbG9zZScsIHtcbiAgICAgICAgICBjb2RlLFxuICAgICAgICAgIHJlYXNvbjogbWVzc2FnZS50b1N0cmluZygpLFxuICAgICAgICAgIHdhc0NsZWFuOiB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgJiYgdGhpcy5fY2xvc2VGcmFtZVNlbnRcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkVycm9yKGVycm9yKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEVycm9yRXZlbnQoJ2Vycm9yJywge1xuICAgICAgICAgIGVycm9yLFxuICAgICAgICAgIG1lc3NhZ2U6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgfSk7XG5cbiAgICAgICAgZXZlbnRba1RhcmdldF0gPSB0aGlzO1xuICAgICAgICBjYWxsTGlzdGVuZXIoaGFuZGxlciwgdGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3JhcHBlcltrRm9yT25FdmVudEF0dHJpYnV0ZV0gPSAhIW9wdGlvbnNba0Zvck9uRXZlbnRBdHRyaWJ1dGVdO1xuICAgIHdyYXBwZXJba0xpc3RlbmVyXSA9IGhhbmRsZXI7XG5cbiAgICBpZiAob3B0aW9ucy5vbmNlKSB7XG4gICAgICB0aGlzLm9uY2UodHlwZSwgd3JhcHBlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub24odHlwZSwgd3JhcHBlcik7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxuICAgKiBSZW1vdmUgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byByZW1vdmVcbiAgICogQHBhcmFtIHsoRnVuY3Rpb258T2JqZWN0KX0gaGFuZGxlciBUaGUgbGlzdGVuZXIgdG8gcmVtb3ZlXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlcikge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnModHlwZSkpIHtcbiAgICAgIGlmIChsaXN0ZW5lcltrTGlzdGVuZXJdID09PSBoYW5kbGVyICYmICFsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENsb3NlRXZlbnQsXG4gIEVycm9yRXZlbnQsXG4gIEV2ZW50LFxuICBFdmVudFRhcmdldCxcbiAgTWVzc2FnZUV2ZW50XG59O1xuXG4vKipcbiAqIENhbGwgYW4gZXZlbnQgbGlzdGVuZXJcbiAqXG4gKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBsaXN0ZW5lciBUaGUgbGlzdGVuZXIgdG8gY2FsbFxuICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSB2YWx1ZSB0byB1c2UgYXMgYHRoaXNgYCB3aGVuIGNhbGxpbmcgdGhlIGxpc3RlbmVyXG4gKiBAcGFyYW0ge0V2ZW50fSBldmVudCBUaGUgZXZlbnQgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihsaXN0ZW5lciwgdGhpc0FyZywgZXZlbnQpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciA9PT0gJ29iamVjdCcgJiYgbGlzdGVuZXIuaGFuZGxlRXZlbnQpIHtcbiAgICBsaXN0ZW5lci5oYW5kbGVFdmVudC5jYWxsKGxpc3RlbmVyLCBldmVudCk7XG4gIH0gZWxzZSB7XG4gICAgbGlzdGVuZXIuY2FsbCh0aGlzQXJnLCBldmVudCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */\nfunction push(dest, name, elem) {\n  if (dest[name] === undefined) dest[name] = [elem];\n  else dest[name].push(elem);\n}\n\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */\nfunction parse(header) {\n  const offers = Object.create(null);\n  let params = Object.create(null);\n  let mustUnescape = false;\n  let isEscaping = false;\n  let inQuotes = false;\n  let extensionName;\n  let paramName;\n  let start = -1;\n  let code = -1;\n  let end = -1;\n  let i = 0;\n\n  for (; i < header.length; i++) {\n    code = header.charCodeAt(i);\n\n    if (extensionName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (\n        i !== 0 &&\n        (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n      ) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b /* ';' */ || code === 0x2c /* ',' */) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        const name = header.slice(start, end);\n        if (code === 0x2c) {\n          push(offers, name, params);\n          params = Object.create(null);\n        } else {\n          extensionName = name;\n        }\n\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else if (paramName === undefined) {\n      if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (code === 0x20 || code === 0x09) {\n        if (end === -1 && start !== -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        push(params, header.slice(start, end), true);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        start = end = -1;\n      } else if (code === 0x3d /* '=' */ && start !== -1 && end === -1) {\n        paramName = header.slice(start, i);\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    } else {\n      //\n      // The value of a quoted-string after unescaping must conform to the\n      // token ABNF, so only token characters are valid.\n      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n      //\n      if (isEscaping) {\n        if (tokenChars[code] !== 1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n        if (start === -1) start = i;\n        else if (!mustUnescape) mustUnescape = true;\n        isEscaping = false;\n      } else if (inQuotes) {\n        if (tokenChars[code] === 1) {\n          if (start === -1) start = i;\n        } else if (code === 0x22 /* '\"' */ && start !== -1) {\n          inQuotes = false;\n          end = i;\n        } else if (code === 0x5c /* '\\' */) {\n          isEscaping = true;\n        } else {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n        inQuotes = true;\n      } else if (end === -1 && tokenChars[code] === 1) {\n        if (start === -1) start = i;\n      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n        if (end === -1) end = i;\n      } else if (code === 0x3b || code === 0x2c) {\n        if (start === -1) {\n          throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n\n        if (end === -1) end = i;\n        let value = header.slice(start, end);\n        if (mustUnescape) {\n          value = value.replace(/\\\\/g, '');\n          mustUnescape = false;\n        }\n        push(params, paramName, value);\n        if (code === 0x2c) {\n          push(offers, extensionName, params);\n          params = Object.create(null);\n          extensionName = undefined;\n        }\n\n        paramName = undefined;\n        start = end = -1;\n      } else {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n    }\n  }\n\n  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  if (end === -1) end = i;\n  const token = header.slice(start, end);\n  if (extensionName === undefined) {\n    push(offers, token, params);\n  } else {\n    if (paramName === undefined) {\n      push(params, token, true);\n    } else if (mustUnescape) {\n      push(params, paramName, token.replace(/\\\\/g, ''));\n    } else {\n      push(params, paramName, token);\n    }\n    push(offers, extensionName, params);\n  }\n\n  return offers;\n}\n\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */\nfunction format(extensions) {\n  return Object.keys(extensions)\n    .map((extension) => {\n      let configurations = extensions[extension];\n      if (!Array.isArray(configurations)) configurations = [configurations];\n      return configurations\n        .map((params) => {\n          return [extension]\n            .concat(\n              Object.keys(params).map((k) => {\n                let values = params[k];\n                if (!Array.isArray(values)) values = [values];\n                return values\n                  .map((v) => (v === true ? k : `${k}=${v}`))\n                  .join('; ');\n              })\n            )\n            .join('; ');\n        })\n        .join(', ');\n    })\n    .join(', ');\n}\n\nmodule.exports = { format, parse };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixRQUFRLGFBQWEsRUFBRSxtQkFBTyxDQUFDLHlEQUFjOztBQUU3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyx5QkFBeUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsbUJBQW1CO0FBQzVCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsNEJBQTRCO0FBQ3BDO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQSxpRUFBaUUsRUFBRTtBQUNuRTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTtBQUNSLCtEQUErRCxFQUFFO0FBQ2pFO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWLGlFQUFpRSxFQUFFO0FBQ25FO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsaUVBQWlFLEVBQUU7QUFDbkU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsK0RBQStELEVBQUU7QUFDakU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsRUFBRSxHQUFHLEVBQUU7QUFDMUQsMkJBQTJCO0FBQzNCLGVBQWU7QUFDZjtBQUNBLHFCQUFxQjtBQUNyQixTQUFTO0FBQ1Q7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanM/Yjc3NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {

"use strict";
eval("\n\nconst kDone = Symbol('kDone');\nconst kRun = Symbol('kRun');\n\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */\nclass Limiter {\n  /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */\n  constructor(concurrency) {\n    this[kDone] = () => {\n      this.pending--;\n      this[kRun]();\n    };\n    this.concurrency = concurrency || Infinity;\n    this.jobs = [];\n    this.pending = 0;\n  }\n\n  /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */\n  add(job) {\n    this.jobs.push(job);\n    this[kRun]();\n  }\n\n  /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */\n  [kRun]() {\n    if (this.pending === this.concurrency) return;\n\n    if (this.jobs.length) {\n      const job = this.jobs.shift();\n\n      this.pending++;\n      job(this[kDone]);\n    }\n  }\n}\n\nmodule.exports = Limiter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9saW1pdGVyLmpzP2IzNjQiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBrRG9uZSA9IFN5bWJvbCgna0RvbmUnKTtcbmNvbnN0IGtSdW4gPSBTeW1ib2woJ2tSdW4nKTtcblxuLyoqXG4gKiBBIHZlcnkgc2ltcGxlIGpvYiBxdWV1ZSB3aXRoIGFkanVzdGFibGUgY29uY3VycmVuY3kuIEFkYXB0ZWQgZnJvbVxuICogaHR0cHM6Ly9naXRodWIuY29tL1NUUk1ML2FzeW5jLWxpbWl0ZXJcbiAqL1xuY2xhc3MgTGltaXRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGBMaW1pdGVyYC5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb25jdXJyZW5jeT1JbmZpbml0eV0gVGhlIG1heGltdW0gbnVtYmVyIG9mIGpvYnMgYWxsb3dlZFxuICAgKiAgICAgdG8gcnVuIGNvbmN1cnJlbnRseVxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uY3VycmVuY3kpIHtcbiAgICB0aGlzW2tEb25lXSA9ICgpID0+IHtcbiAgICAgIHRoaXMucGVuZGluZy0tO1xuICAgICAgdGhpc1trUnVuXSgpO1xuICAgIH07XG4gICAgdGhpcy5jb25jdXJyZW5jeSA9IGNvbmN1cnJlbmN5IHx8IEluZmluaXR5O1xuICAgIHRoaXMuam9icyA9IFtdO1xuICAgIHRoaXMucGVuZGluZyA9IDA7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIGpvYiB0byB0aGUgcXVldWUuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGpvYiBUaGUgam9iIHRvIHJ1blxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGQoam9iKSB7XG4gICAgdGhpcy5qb2JzLnB1c2goam9iKTtcbiAgICB0aGlzW2tSdW5dKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyBhIGpvYiBmcm9tIHRoZSBxdWV1ZSBhbmQgcnVucyBpdCBpZiBwb3NzaWJsZS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIFtrUnVuXSgpIHtcbiAgICBpZiAodGhpcy5wZW5kaW5nID09PSB0aGlzLmNvbmN1cnJlbmN5KSByZXR1cm47XG5cbiAgICBpZiAodGhpcy5qb2JzLmxlbmd0aCkge1xuICAgICAgY29uc3Qgam9iID0gdGhpcy5qb2JzLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgam9iKHRoaXNba0RvbmVdKTtcbiAgICB9XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBMaW1pdGVyO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\n\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"./node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);\nconst kPerMessageDeflate = Symbol('permessage-deflate');\nconst kTotalLength = Symbol('total-length');\nconst kCallback = Symbol('callback');\nconst kBuffers = Symbol('buffers');\nconst kError = Symbol('error');\n\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n\n/**\n * permessage-deflate implementation.\n */\nclass PerMessageDeflate {\n  /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */\n  constructor(options, isServer, maxPayload) {\n    this._maxPayload = maxPayload | 0;\n    this._options = options || {};\n    this._threshold =\n      this._options.threshold !== undefined ? this._options.threshold : 1024;\n    this._isServer = !!isServer;\n    this._deflate = null;\n    this._inflate = null;\n\n    this.params = null;\n\n    if (!zlibLimiter) {\n      const concurrency =\n        this._options.concurrencyLimit !== undefined\n          ? this._options.concurrencyLimit\n          : 10;\n      zlibLimiter = new Limiter(concurrency);\n    }\n  }\n\n  /**\n   * @type {String}\n   */\n  static get extensionName() {\n    return 'permessage-deflate';\n  }\n\n  /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */\n  offer() {\n    const params = {};\n\n    if (this._options.serverNoContextTakeover) {\n      params.server_no_context_takeover = true;\n    }\n    if (this._options.clientNoContextTakeover) {\n      params.client_no_context_takeover = true;\n    }\n    if (this._options.serverMaxWindowBits) {\n      params.server_max_window_bits = this._options.serverMaxWindowBits;\n    }\n    if (this._options.clientMaxWindowBits) {\n      params.client_max_window_bits = this._options.clientMaxWindowBits;\n    } else if (this._options.clientMaxWindowBits == null) {\n      params.client_max_window_bits = true;\n    }\n\n    return params;\n  }\n\n  /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */\n  accept(configurations) {\n    configurations = this.normalizeParams(configurations);\n\n    this.params = this._isServer\n      ? this.acceptAsServer(configurations)\n      : this.acceptAsClient(configurations);\n\n    return this.params;\n  }\n\n  /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */\n  cleanup() {\n    if (this._inflate) {\n      this._inflate.close();\n      this._inflate = null;\n    }\n\n    if (this._deflate) {\n      const callback = this._deflate[kCallback];\n\n      this._deflate.close();\n      this._deflate = null;\n\n      if (callback) {\n        callback(\n          new Error(\n            'The deflate stream was closed while data was being processed'\n          )\n        );\n      }\n    }\n  }\n\n  /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsServer(offers) {\n    const opts = this._options;\n    const accepted = offers.find((params) => {\n      if (\n        (opts.serverNoContextTakeover === false &&\n          params.server_no_context_takeover) ||\n        (params.server_max_window_bits &&\n          (opts.serverMaxWindowBits === false ||\n            (typeof opts.serverMaxWindowBits === 'number' &&\n              opts.serverMaxWindowBits > params.server_max_window_bits))) ||\n        (typeof opts.clientMaxWindowBits === 'number' &&\n          !params.client_max_window_bits)\n      ) {\n        return false;\n      }\n\n      return true;\n    });\n\n    if (!accepted) {\n      throw new Error('None of the extension offers can be accepted');\n    }\n\n    if (opts.serverNoContextTakeover) {\n      accepted.server_no_context_takeover = true;\n    }\n    if (opts.clientNoContextTakeover) {\n      accepted.client_no_context_takeover = true;\n    }\n    if (typeof opts.serverMaxWindowBits === 'number') {\n      accepted.server_max_window_bits = opts.serverMaxWindowBits;\n    }\n    if (typeof opts.clientMaxWindowBits === 'number') {\n      accepted.client_max_window_bits = opts.clientMaxWindowBits;\n    } else if (\n      accepted.client_max_window_bits === true ||\n      opts.clientMaxWindowBits === false\n    ) {\n      delete accepted.client_max_window_bits;\n    }\n\n    return accepted;\n  }\n\n  /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */\n  acceptAsClient(response) {\n    const params = response[0];\n\n    if (\n      this._options.clientNoContextTakeover === false &&\n      params.client_no_context_takeover\n    ) {\n      throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n    }\n\n    if (!params.client_max_window_bits) {\n      if (typeof this._options.clientMaxWindowBits === 'number') {\n        params.client_max_window_bits = this._options.clientMaxWindowBits;\n      }\n    } else if (\n      this._options.clientMaxWindowBits === false ||\n      (typeof this._options.clientMaxWindowBits === 'number' &&\n        params.client_max_window_bits > this._options.clientMaxWindowBits)\n    ) {\n      throw new Error(\n        'Unexpected or invalid parameter \"client_max_window_bits\"'\n      );\n    }\n\n    return params;\n  }\n\n  /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */\n  normalizeParams(configurations) {\n    configurations.forEach((params) => {\n      Object.keys(params).forEach((key) => {\n        let value = params[key];\n\n        if (value.length > 1) {\n          throw new Error(`Parameter \"${key}\" must have only a single value`);\n        }\n\n        value = value[0];\n\n        if (key === 'client_max_window_bits') {\n          if (value !== true) {\n            const num = +value;\n            if (!Number.isInteger(num) || num < 8 || num > 15) {\n              throw new TypeError(\n                `Invalid value for parameter \"${key}\": ${value}`\n              );\n            }\n            value = num;\n          } else if (!this._isServer) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else if (key === 'server_max_window_bits') {\n          const num = +value;\n          if (!Number.isInteger(num) || num < 8 || num > 15) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n          value = num;\n        } else if (\n          key === 'client_no_context_takeover' ||\n          key === 'server_no_context_takeover'\n        ) {\n          if (value !== true) {\n            throw new TypeError(\n              `Invalid value for parameter \"${key}\": ${value}`\n            );\n          }\n        } else {\n          throw new Error(`Unknown parameter \"${key}\"`);\n        }\n\n        params[key] = value;\n      });\n    });\n\n    return configurations;\n  }\n\n  /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  decompress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._decompress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */\n  compress(data, fin, callback) {\n    zlibLimiter.add((done) => {\n      this._compress(data, fin, (err, result) => {\n        done();\n        callback(err, result);\n      });\n    });\n  }\n\n  /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _decompress(data, fin, callback) {\n    const endpoint = this._isServer ? 'client' : 'server';\n\n    if (!this._inflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._inflate = zlib.createInflateRaw({\n        ...this._options.zlibInflateOptions,\n        windowBits\n      });\n      this._inflate[kPerMessageDeflate] = this;\n      this._inflate[kTotalLength] = 0;\n      this._inflate[kBuffers] = [];\n      this._inflate.on('error', inflateOnError);\n      this._inflate.on('data', inflateOnData);\n    }\n\n    this._inflate[kCallback] = callback;\n\n    this._inflate.write(data);\n    if (fin) this._inflate.write(TRAILER);\n\n    this._inflate.flush(() => {\n      const err = this._inflate[kError];\n\n      if (err) {\n        this._inflate.close();\n        this._inflate = null;\n        callback(err);\n        return;\n      }\n\n      const data = bufferUtil.concat(\n        this._inflate[kBuffers],\n        this._inflate[kTotalLength]\n      );\n\n      if (this._inflate._readableState.endEmitted) {\n        this._inflate.close();\n        this._inflate = null;\n      } else {\n        this._inflate[kTotalLength] = 0;\n        this._inflate[kBuffers] = [];\n\n        if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n          this._inflate.reset();\n        }\n      }\n\n      callback(null, data);\n    });\n  }\n\n  /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */\n  _compress(data, fin, callback) {\n    const endpoint = this._isServer ? 'server' : 'client';\n\n    if (!this._deflate) {\n      const key = `${endpoint}_max_window_bits`;\n      const windowBits =\n        typeof this.params[key] !== 'number'\n          ? zlib.Z_DEFAULT_WINDOWBITS\n          : this.params[key];\n\n      this._deflate = zlib.createDeflateRaw({\n        ...this._options.zlibDeflateOptions,\n        windowBits\n      });\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      this._deflate.on('data', deflateOnData);\n    }\n\n    this._deflate[kCallback] = callback;\n\n    this._deflate.write(data);\n    this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {\n      if (!this._deflate) {\n        //\n        // The deflate stream was closed while data was being processed.\n        //\n        return;\n      }\n\n      let data = bufferUtil.concat(\n        this._deflate[kBuffers],\n        this._deflate[kTotalLength]\n      );\n\n      if (fin) {\n        data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n      }\n\n      //\n      // Ensure that the callback will not be called again in\n      // `PerMessageDeflate#cleanup()`.\n      //\n      this._deflate[kCallback] = null;\n\n      this._deflate[kTotalLength] = 0;\n      this._deflate[kBuffers] = [];\n\n      if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n        this._deflate.reset();\n      }\n\n      callback(null, data);\n    });\n  }\n}\n\nmodule.exports = PerMessageDeflate;\n\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction deflateOnData(chunk) {\n  this[kBuffers].push(chunk);\n  this[kTotalLength] += chunk.length;\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction inflateOnData(chunk) {\n  this[kTotalLength] += chunk.length;\n\n  if (\n    this[kPerMessageDeflate]._maxPayload < 1 ||\n    this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload\n  ) {\n    this[kBuffers].push(chunk);\n    return;\n  }\n\n  this[kError] = new RangeError('Max payload size exceeded');\n  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';\n  this[kError][kStatusCode] = 1009;\n  this.removeListener('data', inflateOnData);\n  this.reset();\n}\n\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */\nfunction inflateOnError(err) {\n  //\n  // There is no need to call `Zlib#close()` as the handle is automatically\n  // closed when an error is emitted.\n  //\n  this[kPerMessageDeflate]._inflate = null;\n  err[kStatusCode] = 1007;\n  this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIm1hcHBpbmdzIjoiQUFBYTs7QUFFYixhQUFhLG1CQUFPLENBQUMsa0JBQU07O0FBRTNCLG1CQUFtQixtQkFBTyxDQUFDLDJEQUFlO0FBQzFDLGdCQUFnQixtQkFBTyxDQUFDLG1EQUFXO0FBQ25DLFFBQVEsY0FBYyxFQUFFLG1CQUFPLENBQUMsdURBQWE7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FB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QUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdDQUFnQyxTQUFTO0FBQ3pDO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanM/M2U1YyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBGYXN0QnVmZmVyID0gQnVmZmVyW1N5bWJvbC5zcGVjaWVzXTtcbmNvbnN0IFRSQUlMRVIgPSBCdWZmZXIuZnJvbShbMHgwMCwgMHgwMCwgMHhmZiwgMHhmZl0pO1xuY29uc3Qga1Blck1lc3NhZ2VEZWZsYXRlID0gU3ltYm9sKCdwZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IGtUb3RhbExlbmd0aCA9IFN5bWJvbCgndG90YWwtbGVuZ3RoJyk7XG5jb25zdCBrQ2FsbGJhY2sgPSBTeW1ib2woJ2NhbGxiYWNrJyk7XG5jb25zdCBrQnVmZmVycyA9IFN5bWJvbCgnYnVmZmVycycpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xuXG4vL1xuLy8gV2UgbGltaXQgemxpYiBjb25jdXJyZW5jeSwgd2hpY2ggcHJldmVudHMgc2V2ZXJlIG1lbW9yeSBmcmFnbWVudGF0aW9uXG4vLyBhcyBkb2N1bWVudGVkIGluIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvODg3MSNpc3N1ZWNvbW1lbnQtMjUwOTE1OTEzXG4vLyBhbmQgaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzEyMDJcbi8vXG4vLyBJbnRlbnRpb25hbGx5IGdsb2JhbDsgaXQncyB0aGUgZ2xvYmFsIHRocmVhZCBwb29sIHRoYXQncyBhbiBpc3N1ZS5cbi8vXG5sZXQgemxpYkxpbWl0ZXI7XG5cbi8qKlxuICogcGVybWVzc2FnZS1kZWZsYXRlIGltcGxlbWVudGF0aW9uLlxuICovXG5jbGFzcyBQZXJNZXNzYWdlRGVmbGF0ZSB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgUGVyTWVzc2FnZURlZmxhdGUgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0c10gQWR2ZXJ0aXNlIHN1cHBvcnRcbiAgICogICAgIGZvciwgb3IgcmVxdWVzdCwgYSBjdXN0b20gY2xpZW50IHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIEFkdmVydGlzZS9cbiAgICogICAgIGFja25vd2xlZGdlIGRpc2FibGluZyBvZiBjbGllbnQgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuY29uY3VycmVuY3lMaW1pdD0xMF0gVGhlIG51bWJlciBvZiBjb25jdXJyZW50XG4gICAqICAgICBjYWxscyB0byB6bGliXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58TnVtYmVyKX0gW29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0c10gUmVxdWVzdC9jb25maXJtIHRoZVxuICAgKiAgICAgdXNlIG9mIGEgY3VzdG9tIHNlcnZlciB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBSZXF1ZXN0L2FjY2VwdFxuICAgKiAgICAgZGlzYWJsaW5nIG9mIHNlcnZlciBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy50aHJlc2hvbGQ9MTAyNF0gU2l6ZSAoaW4gYnl0ZXMpIGJlbG93IHdoaWNoXG4gICAqICAgICBtZXNzYWdlcyBzaG91bGQgbm90IGJlIGNvbXByZXNzZWQgaWYgY29udGV4dCB0YWtlb3ZlciBpcyBkaXNhYmxlZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgZGVmbGF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zXSBPcHRpb25zIHRvIHBhc3MgdG8gemxpYiBvblxuICAgKiAgICAgaW5mbGF0ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtpc1NlcnZlcj1mYWxzZV0gQ3JlYXRlIHRoZSBpbnN0YW5jZSBpbiBlaXRoZXIgc2VydmVyIG9yXG4gICAqICAgICBjbGllbnQgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKi9cbiAgY29uc3RydWN0b3Iob3B0aW9ucywgaXNTZXJ2ZXIsIG1heFBheWxvYWQpIHtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gbWF4UGF5bG9hZCB8IDA7XG4gICAgdGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgdGhpcy5fdGhyZXNob2xkID1cbiAgICAgIHRoaXMuX29wdGlvbnMudGhyZXNob2xkICE9PSB1bmRlZmluZWQgPyB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCA6IDEwMjQ7XG4gICAgdGhpcy5faXNTZXJ2ZXIgPSAhIWlzU2VydmVyO1xuICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuXG4gICAgdGhpcy5wYXJhbXMgPSBudWxsO1xuXG4gICAgaWYgKCF6bGliTGltaXRlcikge1xuICAgICAgY29uc3QgY29uY3VycmVuY3kgPVxuICAgICAgICB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXQgIT09IHVuZGVmaW5lZFxuICAgICAgICAgID8gdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0XG4gICAgICAgICAgOiAxMDtcbiAgICAgIHpsaWJMaW1pdGVyID0gbmV3IExpbWl0ZXIoY29uY3VycmVuY3kpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgc3RhdGljIGdldCBleHRlbnNpb25OYW1lKCkge1xuICAgIHJldHVybiAncGVybWVzc2FnZS1kZWZsYXRlJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEV4dGVuc2lvbiBwYXJhbWV0ZXJzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIG9mZmVyKCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHt9O1xuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT0gbnVsbCkge1xuICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0cnVlO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci9yZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWNjZXB0KGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMgPSB0aGlzLm5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucyk7XG5cbiAgICB0aGlzLnBhcmFtcyA9IHRoaXMuX2lzU2VydmVyXG4gICAgICA/IHRoaXMuYWNjZXB0QXNTZXJ2ZXIoY29uZmlndXJhdGlvbnMpXG4gICAgICA6IHRoaXMuYWNjZXB0QXNDbGllbnQoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgcmV0dXJuIHRoaXMucGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbGVhc2VzIGFsbCByZXNvdXJjZXMgdXNlZCBieSB0aGUgZXh0ZW5zaW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBjbGVhbnVwKCkge1xuICAgIGlmICh0aGlzLl9pbmZsYXRlKSB7XG4gICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2RlZmxhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgbmV3IEVycm9yKFxuICAgICAgICAgICAgJ1RoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZCdcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqICBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBvZmZlcnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnNcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc1NlcnZlcihvZmZlcnMpIHtcbiAgICBjb25zdCBvcHRzID0gdGhpcy5fb3B0aW9ucztcbiAgICBjb25zdCBhY2NlcHRlZCA9IG9mZmVycy5maW5kKChwYXJhbXMpID0+IHtcbiAgICAgIGlmIChcbiAgICAgICAgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyKSB8fFxuICAgICAgICAocGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgJiZcbiAgICAgICAgICAob3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgICAgIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA+IHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzKSkpIHx8XG4gICAgICAgICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cylcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgaWYgKCFhY2NlcHRlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb25lIG9mIHRoZSBleHRlbnNpb24gb2ZmZXJzIGNhbiBiZSBhY2NlcHRlZCcpO1xuICAgIH1cblxuICAgIGlmIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRzLmNsaWVudE5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX21heF93aW5kb3dfYml0cyA9IG9wdHMuc2VydmVyTWF4V2luZG93Qml0cztcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzID09PSB0cnVlIHx8XG4gICAgICBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlXG4gICAgKSB7XG4gICAgICBkZWxldGUgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cztcbiAgICB9XG5cbiAgICByZXR1cm4gYWNjZXB0ZWQ7XG4gIH1cblxuICAvKipcbiAgICogQWNjZXB0IHRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHJlc3BvbnNlIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gcmVzcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhY2NlcHRBc0NsaWVudChyZXNwb25zZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJlc3BvbnNlWzBdO1xuXG4gICAgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmV4cGVjdGVkIHBhcmFtZXRlciBcImNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXCInKTtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA+IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cylcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1VuZXhwZWN0ZWQgb3IgaW52YWxpZCBwYXJhbWV0ZXIgXCJjbGllbnRfbWF4X3dpbmRvd19iaXRzXCInXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBwYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogTm9ybWFsaXplIHBhcmFtZXRlcnMuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7QXJyYXl9IFRoZSBvZmZlcnMvcmVzcG9uc2Ugd2l0aCBub3JtYWxpemVkIHBhcmFtZXRlcnNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIG5vcm1hbGl6ZVBhcmFtcyhjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zLmZvckVhY2goKHBhcmFtcykgPT4ge1xuICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgbGV0IHZhbHVlID0gcGFyYW1zW2tleV07XG5cbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFBhcmFtZXRlciBcIiR7a2V5fVwiIG11c3QgaGF2ZSBvbmx5IGEgc2luZ2xlIHZhbHVlYCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YWx1ZSA9IHZhbHVlWzBdO1xuXG4gICAgICAgIGlmIChrZXkgPT09ICdjbGllbnRfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLl9pc1NlcnZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGtleSA9PT0gJ3NlcnZlcl9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgY29uc3QgbnVtID0gK3ZhbHVlO1xuICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YWx1ZSA9IG51bTtcbiAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBrZXkgPT09ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcicgfHxcbiAgICAgICAgICBrZXkgPT09ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBhcmFtZXRlciBcIiR7a2V5fVwiYCk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gY29uZmlndXJhdGlvbnM7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9kZWNvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgemxpYkxpbWl0ZXIuYWRkKChkb25lKSA9PiB7XG4gICAgICB0aGlzLl9jb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZGVjb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdjbGllbnQnIDogJ3NlcnZlcic7XG5cbiAgICBpZiAoIXRoaXMuX2luZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5faW5mbGF0ZSA9IHpsaWIuY3JlYXRlSW5mbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkluZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2luZmxhdGVba1Blck1lc3NhZ2VEZWZsYXRlXSA9IHRoaXM7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2Vycm9yJywgaW5mbGF0ZU9uRXJyb3IpO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2luZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5faW5mbGF0ZS53cml0ZShkYXRhKTtcbiAgICBpZiAoZmluKSB0aGlzLl9pbmZsYXRlLndyaXRlKFRSQUlMRVIpO1xuXG4gICAgdGhpcy5faW5mbGF0ZS5mbHVzaCgoKSA9PiB7XG4gICAgICBjb25zdCBlcnIgPSB0aGlzLl9pbmZsYXRlW2tFcnJvcl07XG5cbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmICh0aGlzLl9pbmZsYXRlLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgICAgdGhpcy5faW5mbGF0ZS5yZXNldCgpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9jb21wcmVzcyhkYXRhLCBmaW4sIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSB0aGlzLl9pc1NlcnZlciA/ICdzZXJ2ZXInIDogJ2NsaWVudCc7XG5cbiAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGtleSA9IGAke2VuZHBvaW50fV9tYXhfd2luZG93X2JpdHNgO1xuICAgICAgY29uc3Qgd2luZG93Qml0cyA9XG4gICAgICAgIHR5cGVvZiB0aGlzLnBhcmFtc1trZXldICE9PSAnbnVtYmVyJ1xuICAgICAgICAgID8gemxpYi5aX0RFRkFVTFRfV0lORE9XQklUU1xuICAgICAgICAgIDogdGhpcy5wYXJhbXNba2V5XTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZSA9IHpsaWIuY3JlYXRlRGVmbGF0ZVJhdyh7XG4gICAgICAgIC4uLnRoaXMuX29wdGlvbnMuemxpYkRlZmxhdGVPcHRpb25zLFxuICAgICAgICB3aW5kb3dCaXRzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUub24oJ2RhdGEnLCBkZWZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2RlZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgdGhpcy5fZGVmbGF0ZS5mbHVzaCh6bGliLlpfU1lOQ19GTFVTSCwgKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICAgIC8vXG4gICAgICAgIC8vIFRoZSBkZWZsYXRlIHN0cmVhbSB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIHByb2Nlc3NlZC5cbiAgICAgICAgLy9cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBsZXQgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAoZmluKSB7XG4gICAgICAgIGRhdGEgPSBuZXcgRmFzdEJ1ZmZlcihkYXRhLmJ1ZmZlciwgZGF0YS5ieXRlT2Zmc2V0LCBkYXRhLmxlbmd0aCAtIDQpO1xuICAgICAgfVxuXG4gICAgICAvL1xuICAgICAgLy8gRW5zdXJlIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgbm90IGJlIGNhbGxlZCBhZ2FpbiBpblxuICAgICAgLy8gYFBlck1lc3NhZ2VEZWZsYXRlI2NsZWFudXAoKWAuXG4gICAgICAvL1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gbnVsbDtcblxuICAgICAgdGhpcy5fZGVmbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdID0gW107XG5cbiAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICB0aGlzLl9kZWZsYXRlLnJlc2V0KCk7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGRhdGEpO1xuICAgIH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gUGVyTWVzc2FnZURlZmxhdGU7XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5EZWZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVmbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG5cbiAgaWYgKFxuICAgIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZCA8IDEgfHxcbiAgICB0aGlzW2tUb3RhbExlbmd0aF0gPD0gdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkXG4gICkge1xuICAgIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIHRoaXNba0Vycm9yXSA9IG5ldyBSYW5nZUVycm9yKCdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyk7XG4gIHRoaXNba0Vycm9yXS5jb2RlID0gJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCc7XG4gIHRoaXNba0Vycm9yXVtrU3RhdHVzQ29kZV0gPSAxMDA5O1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gIHRoaXMucmVzZXQoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkluZmxhdGVSYXdgIHN0cmVhbSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlbWl0dGVkIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBpbmZsYXRlT25FcnJvcihlcnIpIHtcbiAgLy9cbiAgLy8gVGhlcmUgaXMgbm8gbmVlZCB0byBjYWxsIGBabGliI2Nsb3NlKClgIGFzIHRoZSBoYW5kbGUgaXMgYXV0b21hdGljYWxseVxuICAvLyBjbG9zZWQgd2hlbiBhbiBlcnJvciBpcyBlbWl0dGVkLlxuICAvL1xuICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX2luZmxhdGUgPSBudWxsO1xuICBlcnJba1N0YXR1c0NvZGVdID0gMTAwNztcbiAgdGhpc1trQ2FsbGJhY2tdKGVycik7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  kStatusCode,\n  kWebSocket\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\nconst FastBuffer = Buffer[Symbol.species];\n\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */\nclass Receiver extends Writable {\n  /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */\n  constructor(options = {}) {\n    super();\n\n    this._allowSynchronousEvents =\n      options.allowSynchronousEvents !== undefined\n        ? options.allowSynchronousEvents\n        : true;\n    this._binaryType = options.binaryType || BINARY_TYPES[0];\n    this._extensions = options.extensions || {};\n    this._isServer = !!options.isServer;\n    this._maxPayload = options.maxPayload | 0;\n    this._skipUTF8Validation = !!options.skipUTF8Validation;\n    this[kWebSocket] = undefined;\n\n    this._bufferedBytes = 0;\n    this._buffers = [];\n\n    this._compressed = false;\n    this._payloadLength = 0;\n    this._mask = undefined;\n    this._fragmented = 0;\n    this._masked = false;\n    this._fin = false;\n    this._opcode = 0;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragments = [];\n\n    this._errored = false;\n    this._loop = false;\n    this._state = GET_INFO;\n  }\n\n  /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */\n  _write(chunk, encoding, cb) {\n    if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n\n    this._bufferedBytes += chunk.length;\n    this._buffers.push(chunk);\n    this.startLoop(cb);\n  }\n\n  /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */\n  consume(n) {\n    this._bufferedBytes -= n;\n\n    if (n === this._buffers[0].length) return this._buffers.shift();\n\n    if (n < this._buffers[0].length) {\n      const buf = this._buffers[0];\n      this._buffers[0] = new FastBuffer(\n        buf.buffer,\n        buf.byteOffset + n,\n        buf.length - n\n      );\n\n      return new FastBuffer(buf.buffer, buf.byteOffset, n);\n    }\n\n    const dst = Buffer.allocUnsafe(n);\n\n    do {\n      const buf = this._buffers[0];\n      const offset = dst.length - n;\n\n      if (n >= buf.length) {\n        dst.set(this._buffers.shift(), offset);\n      } else {\n        dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n        this._buffers[0] = new FastBuffer(\n          buf.buffer,\n          buf.byteOffset + n,\n          buf.length - n\n        );\n      }\n\n      n -= buf.length;\n    } while (n > 0);\n\n    return dst;\n  }\n\n  /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  startLoop(cb) {\n    this._loop = true;\n\n    do {\n      switch (this._state) {\n        case GET_INFO:\n          this.getInfo(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_16:\n          this.getPayloadLength16(cb);\n          break;\n        case GET_PAYLOAD_LENGTH_64:\n          this.getPayloadLength64(cb);\n          break;\n        case GET_MASK:\n          this.getMask();\n          break;\n        case GET_DATA:\n          this.getData(cb);\n          break;\n        case INFLATING:\n        case DEFER_EVENT:\n          this._loop = false;\n          return;\n      }\n    } while (this._loop);\n\n    if (!this._errored) cb();\n  }\n\n  /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getInfo(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(2);\n\n    if ((buf[0] & 0x30) !== 0x00) {\n      const error = this.createError(\n        RangeError,\n        'RSV2 and RSV3 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_2_3'\n      );\n\n      cb(error);\n      return;\n    }\n\n    const compressed = (buf[0] & 0x40) === 0x40;\n\n    if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n      const error = this.createError(\n        RangeError,\n        'RSV1 must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_RSV_1'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._fin = (buf[0] & 0x80) === 0x80;\n    this._opcode = buf[0] & 0x0f;\n    this._payloadLength = buf[1] & 0x7f;\n\n    if (this._opcode === 0x00) {\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (!this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          'invalid opcode 0',\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._opcode = this._fragmented;\n    } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n      if (this._fragmented) {\n        const error = this.createError(\n          RangeError,\n          `invalid opcode ${this._opcode}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_OPCODE'\n        );\n\n        cb(error);\n        return;\n      }\n\n      this._compressed = compressed;\n    } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n      if (!this._fin) {\n        const error = this.createError(\n          RangeError,\n          'FIN must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_FIN'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (compressed) {\n        const error = this.createError(\n          RangeError,\n          'RSV1 must be clear',\n          true,\n          1002,\n          'WS_ERR_UNEXPECTED_RSV_1'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (\n        this._payloadLength > 0x7d ||\n        (this._opcode === 0x08 && this._payloadLength === 1)\n      ) {\n        const error = this.createError(\n          RangeError,\n          `invalid payload length ${this._payloadLength}`,\n          true,\n          1002,\n          'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    } else {\n      const error = this.createError(\n        RangeError,\n        `invalid opcode ${this._opcode}`,\n        true,\n        1002,\n        'WS_ERR_INVALID_OPCODE'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n    this._masked = (buf[1] & 0x80) === 0x80;\n\n    if (this._isServer) {\n      if (!this._masked) {\n        const error = this.createError(\n          RangeError,\n          'MASK must be set',\n          true,\n          1002,\n          'WS_ERR_EXPECTED_MASK'\n        );\n\n        cb(error);\n        return;\n      }\n    } else if (this._masked) {\n      const error = this.createError(\n        RangeError,\n        'MASK must be clear',\n        true,\n        1002,\n        'WS_ERR_UNEXPECTED_MASK'\n      );\n\n      cb(error);\n      return;\n    }\n\n    if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n    else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n    else this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength16(cb) {\n    if (this._bufferedBytes < 2) {\n      this._loop = false;\n      return;\n    }\n\n    this._payloadLength = this.consume(2).readUInt16BE(0);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getPayloadLength64(cb) {\n    if (this._bufferedBytes < 8) {\n      this._loop = false;\n      return;\n    }\n\n    const buf = this.consume(8);\n    const num = buf.readUInt32BE(0);\n\n    //\n    // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n    // if payload length is greater than this number.\n    //\n    if (num > Math.pow(2, 53 - 32) - 1) {\n      const error = this.createError(\n        RangeError,\n        'Unsupported WebSocket frame: payload length > 2^53 - 1',\n        false,\n        1009,\n        'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH'\n      );\n\n      cb(error);\n      return;\n    }\n\n    this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n    this.haveLength(cb);\n  }\n\n  /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  haveLength(cb) {\n    if (this._payloadLength && this._opcode < 0x08) {\n      this._totalPayloadLength += this._payloadLength;\n      if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n        const error = this.createError(\n          RangeError,\n          'Max payload size exceeded',\n          false,\n          1009,\n          'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n        );\n\n        cb(error);\n        return;\n      }\n    }\n\n    if (this._masked) this._state = GET_MASK;\n    else this._state = GET_DATA;\n  }\n\n  /**\n   * Reads mask bytes.\n   *\n   * @private\n   */\n  getMask() {\n    if (this._bufferedBytes < 4) {\n      this._loop = false;\n      return;\n    }\n\n    this._mask = this.consume(4);\n    this._state = GET_DATA;\n  }\n\n  /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  getData(cb) {\n    let data = EMPTY_BUFFER;\n\n    if (this._payloadLength) {\n      if (this._bufferedBytes < this._payloadLength) {\n        this._loop = false;\n        return;\n      }\n\n      data = this.consume(this._payloadLength);\n\n      if (\n        this._masked &&\n        (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0\n      ) {\n        unmask(data, this._mask);\n      }\n    }\n\n    if (this._opcode > 0x07) {\n      this.controlMessage(data, cb);\n      return;\n    }\n\n    if (this._compressed) {\n      this._state = INFLATING;\n      this.decompress(data, cb);\n      return;\n    }\n\n    if (data.length) {\n      //\n      // This message is not compressed so its length is the sum of the payload\n      // length of all fragments.\n      //\n      this._messageLength = this._totalPayloadLength;\n      this._fragments.push(data);\n    }\n\n    this.dataMessage(cb);\n  }\n\n  /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */\n  decompress(data, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    perMessageDeflate.decompress(data, this._fin, (err, buf) => {\n      if (err) return cb(err);\n\n      if (buf.length) {\n        this._messageLength += buf.length;\n        if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n          const error = this.createError(\n            RangeError,\n            'Max payload size exceeded',\n            false,\n            1009,\n            'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._fragments.push(buf);\n      }\n\n      this.dataMessage(cb);\n      if (this._state === GET_INFO) this.startLoop(cb);\n    });\n  }\n\n  /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */\n  dataMessage(cb) {\n    if (!this._fin) {\n      this._state = GET_INFO;\n      return;\n    }\n\n    const messageLength = this._messageLength;\n    const fragments = this._fragments;\n\n    this._totalPayloadLength = 0;\n    this._messageLength = 0;\n    this._fragmented = 0;\n    this._fragments = [];\n\n    if (this._opcode === 2) {\n      let data;\n\n      if (this._binaryType === 'nodebuffer') {\n        data = concat(fragments, messageLength);\n      } else if (this._binaryType === 'arraybuffer') {\n        data = toArrayBuffer(concat(fragments, messageLength));\n      } else if (this._binaryType === 'blob') {\n        data = new Blob(fragments);\n      } else {\n        data = fragments;\n      }\n\n      if (this._allowSynchronousEvents) {\n        this.emit('message', data, true);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', data, true);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    } else {\n      const buf = concat(fragments, messageLength);\n\n      if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n        const error = this.createError(\n          Error,\n          'invalid UTF-8 sequence',\n          true,\n          1007,\n          'WS_ERR_INVALID_UTF8'\n        );\n\n        cb(error);\n        return;\n      }\n\n      if (this._state === INFLATING || this._allowSynchronousEvents) {\n        this.emit('message', buf, false);\n        this._state = GET_INFO;\n      } else {\n        this._state = DEFER_EVENT;\n        setImmediate(() => {\n          this.emit('message', buf, false);\n          this._state = GET_INFO;\n          this.startLoop(cb);\n        });\n      }\n    }\n  }\n\n  /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */\n  controlMessage(data, cb) {\n    if (this._opcode === 0x08) {\n      if (data.length === 0) {\n        this._loop = false;\n        this.emit('conclude', 1005, EMPTY_BUFFER);\n        this.end();\n      } else {\n        const code = data.readUInt16BE(0);\n\n        if (!isValidStatusCode(code)) {\n          const error = this.createError(\n            RangeError,\n            `invalid status code ${code}`,\n            true,\n            1002,\n            'WS_ERR_INVALID_CLOSE_CODE'\n          );\n\n          cb(error);\n          return;\n        }\n\n        const buf = new FastBuffer(\n          data.buffer,\n          data.byteOffset + 2,\n          data.length - 2\n        );\n\n        if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n          const error = this.createError(\n            Error,\n            'invalid UTF-8 sequence',\n            true,\n            1007,\n            'WS_ERR_INVALID_UTF8'\n          );\n\n          cb(error);\n          return;\n        }\n\n        this._loop = false;\n        this.emit('conclude', code, buf);\n        this.end();\n      }\n\n      this._state = GET_INFO;\n      return;\n    }\n\n    if (this._allowSynchronousEvents) {\n      this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n      this._state = GET_INFO;\n    } else {\n      this._state = DEFER_EVENT;\n      setImmediate(() => {\n        this.emit(this._opcode === 0x09 ? 'ping' : 'pong', data);\n        this._state = GET_INFO;\n        this.startLoop(cb);\n      });\n    }\n  }\n\n  /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */\n  createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n    this._loop = false;\n    this._errored = true;\n\n    const err = new ErrorCtor(\n      prefix ? `Invalid WebSocket frame: ${message}` : message\n    );\n\n    Error.captureStackTrace(err, this.createError);\n    err.code = errorCode;\n    err[kStatusCode] = statusCode;\n    return err;\n  }\n}\n\nmodule.exports = Receiver;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL3JlY2VpdmVyLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsV0FBVyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRXJDLDBCQUEwQixtQkFBTyxDQUFDLHlFQUFzQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxFQUFFLG1CQUFPLENBQUMsdURBQWE7QUFDekIsUUFBUSxnQ0FBZ0MsRUFBRSxtQkFBTyxDQUFDLDJEQUFlO0FBQ2pFLFFBQVEsaUNBQWlDLEVBQUUsbUJBQU8sQ0FBQyx5REFBYzs7QUFFakU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsY0FBYyxRQUFRO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsYUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLG9CQUFvQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsUUFBUTtBQUNyQixjQUFjLDhCQUE4QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxLQUFLO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsZ0NBQWdDO0FBQzdDLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxRQUFRO0FBQ3JCLGNBQWMsb0JBQW9CO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcz8xZTBkIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUsIGlzVmFsaWRVVEY4IH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5cbmNvbnN0IEdFVF9JTkZPID0gMDtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF8xNiA9IDE7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfNjQgPSAyO1xuY29uc3QgR0VUX01BU0sgPSAzO1xuY29uc3QgR0VUX0RBVEEgPSA0O1xuY29uc3QgSU5GTEFUSU5HID0gNTtcbmNvbnN0IERFRkVSX0VWRU5UID0gNjtcblxuLyoqXG4gKiBIeUJpIFJlY2VpdmVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBleHRlbmRzIFdyaXRhYmxlXG4gKi9cbmNsYXNzIFJlY2VpdmVyIGV4dGVuZHMgV3JpdGFibGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlY2VpdmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJpbmFyeVR5cGU9bm9kZWJ1ZmZlcl0gVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZFxuICAgKiAgICAgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU2VydmVyPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0byBvcGVyYXRlIGluXG4gICAqICAgICBjbGllbnQgb3Igc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cyA9XG4gICAgICBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50c1xuICAgICAgICA6IHRydWU7XG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IG9wdGlvbnMuYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IG9wdGlvbnMuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhb3B0aW9ucy5pc1NlcnZlcjtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gb3B0aW9ucy5tYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gPSAhIW9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9idWZmZXJzID0gW107XG5cbiAgICB0aGlzLl9jb21wcmVzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9tYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcbiAgICB0aGlzLl9vcGNvZGUgPSAwO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIHRoaXMuX2Vycm9yZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGBXcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgVGhlIGNodW5rIG9mIGRhdGEgdG8gd3JpdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIFRoZSBjaGFyYWN0ZXIgZW5jb2Rpbmcgb2YgYGNodW5rYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3N0YXRlID09IEdFVF9JTkZPKSByZXR1cm4gY2IoKTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGBuYCBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvbnN1bWVcbiAgICogQHJldHVybiB7QnVmZmVyfSBUaGUgY29uc3VtZWQgYnl0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN1bWUobikge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gbjtcblxuICAgIGlmIChuID09PSB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2J1ZmZlcnMuc2hpZnQoKTtcblxuICAgIGlmIChuIDwgdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICB0aGlzLl9idWZmZXJzWzBdID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgIGJ1Zi5idWZmZXIsXG4gICAgICAgIGJ1Zi5ieXRlT2Zmc2V0ICsgbixcbiAgICAgICAgYnVmLmxlbmd0aCAtIG5cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbik7XG4gICAgfVxuXG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRzdC5sZW5ndGggLSBuO1xuXG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBidWYuYnVmZmVyLFxuICAgICAgICAgIGJ1Zi5ieXRlT2Zmc2V0ICsgbixcbiAgICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBuIC09IGJ1Zi5sZW5ndGg7XG4gICAgfSB3aGlsZSAobiA+IDApO1xuXG4gICAgcmV0dXJuIGRzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHBhcnNpbmcgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0TG9vcChjYikge1xuICAgIHRoaXMuX2xvb3AgPSB0cnVlO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICBjYXNlIEdFVF9JTkZPOlxuICAgICAgICAgIHRoaXMuZ2V0SW5mbyhjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ6XG4gICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoNjQoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9NQVNLOlxuICAgICAgICAgIHRoaXMuZ2V0TWFzaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9EQVRBOlxuICAgICAgICAgIHRoaXMuZ2V0RGF0YShjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSU5GTEFUSU5HOlxuICAgICAgICBjYXNlIERFRkVSX0VWRU5UOlxuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAodGhpcy5fbG9vcCk7XG5cbiAgICBpZiAoIXRoaXMuX2Vycm9yZWQpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIGZpcnN0IHR3byBieXRlcyBvZiBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5mbyhjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSgyKTtcblxuICAgIGlmICgoYnVmWzBdICYgMHgzMCkgIT09IDB4MDApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMl8zJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAoYnVmWzBdICYgMHg0MCkgPT09IDB4NDA7XG5cbiAgICBpZiAoY29tcHJlc3NlZCAmJiAhdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpbiA9IChidWZbMF0gJiAweDgwKSA9PT0gMHg4MDtcbiAgICB0aGlzLl9vcGNvZGUgPSBidWZbMF0gJiAweDBmO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBidWZbMV0gJiAweDdmO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMCkge1xuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdpbnZhbGlkIG9wY29kZSAwJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcgJiYgdGhpcy5fb3Bjb2RlIDwgMHgwYikge1xuICAgICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ0ZJTiBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfRklOJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPiAweDdkIHx8XG4gICAgICAgICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMSlcbiAgICAgICkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9maW4gJiYgIXRoaXMuX2ZyYWdtZW50ZWQpIHRoaXMuX2ZyYWdtZW50ZWQgPSB0aGlzLl9vcGNvZGU7XG4gICAgdGhpcy5fbWFza2VkID0gKGJ1ZlsxXSAmIDB4ODApID09PSAweDgwO1xuXG4gICAgaWYgKHRoaXMuX2lzU2VydmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX21hc2tlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTUFTSyBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfTUFTSydcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnTUFTSyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX01BU0snXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNikgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY7XG4gICAgZWxzZSBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI3KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF82NDtcbiAgICBlbHNlIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoMTYoY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDY0KGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDgpO1xuICAgIGNvbnN0IG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMCk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciBpbiBKYXZhU2NyaXB0IGlzIDJeNTMgLSAxLiBBbiBlcnJvciBpcyByZXR1cm5lZFxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cbiAgICAvL1xuICAgIGlmIChudW0gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIFdlYlNvY2tldCBmcmFtZTogcGF5bG9hZCBsZW5ndGggPiAyXjUzIC0gMScsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAxMDA5LFxuICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX0RBVEFfUEFZTE9BRF9MRU5HVEgnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG4gICAgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGF2ZUxlbmd0aChjYikge1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoICYmIHRoaXMuX29wY29kZSA8IDB4MDgpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIDEwMDksXG4gICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xuICAgIGVsc2UgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBtYXNrIGJ5dGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWFzaygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXNrID0gdGhpcy5jb25zdW1lKDQpO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgZGF0YSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGEoY2IpIHtcbiAgICBsZXQgZGF0YSA9IEVNUFRZX0JVRkZFUjtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fbWFza2VkICYmXG4gICAgICAgICh0aGlzLl9tYXNrWzBdIHwgdGhpcy5fbWFza1sxXSB8IHRoaXMuX21hc2tbMl0gfCB0aGlzLl9tYXNrWzNdKSAhPT0gMFxuICAgICAgKSB7XG4gICAgICAgIHVubWFzayhkYXRhLCB0aGlzLl9tYXNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNykge1xuICAgICAgdGhpcy5jb250cm9sTWVzc2FnZShkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhTWVzc2FnZShjYik7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzc2VzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBjYikge1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmRlY29tcHJlc3MoZGF0YSwgdGhpcy5fZmluLCAoZXJyLCBidWYpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBpZiAoYnVmLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9tZXNzYWdlTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goYnVmKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhTWVzc2FnZShjYik7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEdFVF9JTkZPKSB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKGNiKSB7XG4gICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IHRoaXMuX21lc3NhZ2VMZW5ndGg7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDIpIHtcbiAgICAgIGxldCBkYXRhO1xuXG4gICAgICBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ25vZGVidWZmZXInKSB7XG4gICAgICAgIGRhdGEgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICBkYXRhID0gdG9BcnJheUJ1ZmZlcihjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgICAgICBkYXRhID0gbmV3IEJsb2IoZnJhZ21lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuXG4gICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwNyxcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBJTkZMQVRJTkcgfHwgdGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gREVGRVJfRVZFTlQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLCBmYWxzZSk7XG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb250cm9sTWVzc2FnZShkYXRhLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCBFTVBUWV9CVUZGRVIpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGRhdGEucmVhZFVJbnQxNkJFKDApO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICAgYGludmFsaWQgc3RhdHVzIGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwMixcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DTE9TRV9DT0RFJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgICAgZGF0YS5idWZmZXIsXG4gICAgICAgICAgZGF0YS5ieXRlT2Zmc2V0ICsgMixcbiAgICAgICAgICBkYXRhLmxlbmd0aCAtIDJcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIEVycm9yLFxuICAgICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDcsXG4gICAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIGNvZGUsIGJ1Zik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLl9vcGNvZGUgPT09IDB4MDkgPyAncGluZycgOiAncG9uZycsIGRhdGEpO1xuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLl9vcGNvZGUgPT09IDB4MDkgPyAncGluZycgOiAncG9uZycsIGRhdGEpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuIGVycm9yIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBwcmVmaXggU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGFkZCBhIGRlZmF1bHQgcHJlZml4IHRvXG4gICAqICAgICBgbWVzc2FnZWBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c0NvZGUgVGhlIHN0YXR1cyBjb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvckNvZGUgVGhlIGV4cG9zZWQgZXJyb3IgY29kZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlRXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9lcnJvcmVkID0gdHJ1ZTtcblxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckN0b3IoXG4gICAgICBwcmVmaXggPyBgSW52YWxpZCBXZWJTb2NrZXQgZnJhbWU6ICR7bWVzc2FnZX1gIDogbWVzc2FnZVxuICAgICk7XG5cbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHRoaXMuY3JlYXRlRXJyb3IpO1xuICAgIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICAgIGVycltrU3RhdHVzQ29kZV0gPSBzdGF0dXNDb2RlO1xuICAgIHJldHVybiBlcnI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWNlaXZlcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */\n\n\n\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst kByteLength = Symbol('kByteLength');\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\n\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n\n/**\n * HyBi Sender implementation.\n */\nclass Sender {\n  /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */\n  constructor(socket, extensions, generateMask) {\n    this._extensions = extensions || {};\n\n    if (generateMask) {\n      this._generateMask = generateMask;\n      this._maskBuffer = Buffer.alloc(4);\n    }\n\n    this._socket = socket;\n\n    this._firstFragment = true;\n    this._compress = false;\n\n    this._bufferedBytes = 0;\n    this._queue = [];\n    this._state = DEFAULT;\n    this.onerror = NOOP;\n    this[kWebSocket] = undefined;\n  }\n\n  /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */\n  static frame(data, options) {\n    let mask;\n    let merge = false;\n    let offset = 2;\n    let skipMasking = false;\n\n    if (options.mask) {\n      mask = options.maskBuffer || maskBuffer;\n\n      if (options.generateMask) {\n        options.generateMask(mask);\n      } else {\n        if (randomPoolPointer === RANDOM_POOL_SIZE) {\n          /* istanbul ignore else  */\n          if (randomPool === undefined) {\n            //\n            // This is lazily initialized because server-sent frames must not\n            // be masked so it may never be used.\n            //\n            randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n          }\n\n          randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n          randomPoolPointer = 0;\n        }\n\n        mask[0] = randomPool[randomPoolPointer++];\n        mask[1] = randomPool[randomPoolPointer++];\n        mask[2] = randomPool[randomPoolPointer++];\n        mask[3] = randomPool[randomPoolPointer++];\n      }\n\n      skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n      offset = 6;\n    }\n\n    let dataLength;\n\n    if (typeof data === 'string') {\n      if (\n        (!options.mask || skipMasking) &&\n        options[kByteLength] !== undefined\n      ) {\n        dataLength = options[kByteLength];\n      } else {\n        data = Buffer.from(data);\n        dataLength = data.length;\n      }\n    } else {\n      dataLength = data.length;\n      merge = options.mask && options.readOnly && !skipMasking;\n    }\n\n    let payloadLength = dataLength;\n\n    if (dataLength >= 65536) {\n      offset += 8;\n      payloadLength = 127;\n    } else if (dataLength > 125) {\n      offset += 2;\n      payloadLength = 126;\n    }\n\n    const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n\n    target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n    if (options.rsv1) target[0] |= 0x40;\n\n    target[1] = payloadLength;\n\n    if (payloadLength === 126) {\n      target.writeUInt16BE(dataLength, 2);\n    } else if (payloadLength === 127) {\n      target[2] = target[3] = 0;\n      target.writeUIntBE(dataLength, 4, 6);\n    }\n\n    if (!options.mask) return [target, data];\n\n    target[1] |= 0x80;\n    target[offset - 4] = mask[0];\n    target[offset - 3] = mask[1];\n    target[offset - 2] = mask[2];\n    target[offset - 1] = mask[3];\n\n    if (skipMasking) return [target, data];\n\n    if (merge) {\n      applyMask(data, mask, target, offset, dataLength);\n      return [target];\n    }\n\n    applyMask(data, mask, data, 0, dataLength);\n    return [target, data];\n  }\n\n  /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  close(code, data, mask, cb) {\n    let buf;\n\n    if (code === undefined) {\n      buf = EMPTY_BUFFER;\n    } else if (typeof code !== 'number' || !isValidStatusCode(code)) {\n      throw new TypeError('First argument must be a valid error code number');\n    } else if (data === undefined || !data.length) {\n      buf = Buffer.allocUnsafe(2);\n      buf.writeUInt16BE(code, 0);\n    } else {\n      const length = Buffer.byteLength(data);\n\n      if (length > 123) {\n        throw new RangeError('The message must not be greater than 123 bytes');\n      }\n\n      buf = Buffer.allocUnsafe(2 + length);\n      buf.writeUInt16BE(code, 0);\n\n      if (typeof data === 'string') {\n        buf.write(data, 2);\n      } else {\n        buf.set(data, 2);\n      }\n    }\n\n    const options = {\n      [kByteLength]: buf.length,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x08,\n      readOnly: false,\n      rsv1: false\n    };\n\n    if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, buf, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(buf, options), cb);\n    }\n  }\n\n  /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  ping(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x09,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  pong(data, mask, cb) {\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (byteLength > 125) {\n      throw new RangeError('The data size must not be greater than 125 bytes');\n    }\n\n    const options = {\n      [kByteLength]: byteLength,\n      fin: true,\n      generateMask: this._generateMask,\n      mask,\n      maskBuffer: this._maskBuffer,\n      opcode: 0x0a,\n      readOnly,\n      rsv1: false\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, false, options, cb]);\n      } else {\n        this.getBlobData(data, false, options, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, false, options, cb]);\n    } else {\n      this.sendFrame(Sender.frame(data, options), cb);\n    }\n  }\n\n  /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */\n  send(data, options, cb) {\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n    let opcode = options.binary ? 2 : 1;\n    let rsv1 = options.compress;\n\n    let byteLength;\n    let readOnly;\n\n    if (typeof data === 'string') {\n      byteLength = Buffer.byteLength(data);\n      readOnly = false;\n    } else if (isBlob(data)) {\n      byteLength = data.size;\n      readOnly = false;\n    } else {\n      data = toBuffer(data);\n      byteLength = data.length;\n      readOnly = toBuffer.readOnly;\n    }\n\n    if (this._firstFragment) {\n      this._firstFragment = false;\n      if (\n        rsv1 &&\n        perMessageDeflate &&\n        perMessageDeflate.params[\n          perMessageDeflate._isServer\n            ? 'server_no_context_takeover'\n            : 'client_no_context_takeover'\n        ]\n      ) {\n        rsv1 = byteLength >= perMessageDeflate._threshold;\n      }\n      this._compress = rsv1;\n    } else {\n      rsv1 = false;\n      opcode = 0;\n    }\n\n    if (options.fin) this._firstFragment = true;\n\n    const opts = {\n      [kByteLength]: byteLength,\n      fin: options.fin,\n      generateMask: this._generateMask,\n      mask: options.mask,\n      maskBuffer: this._maskBuffer,\n      opcode,\n      readOnly,\n      rsv1\n    };\n\n    if (isBlob(data)) {\n      if (this._state !== DEFAULT) {\n        this.enqueue([this.getBlobData, data, this._compress, opts, cb]);\n      } else {\n        this.getBlobData(data, this._compress, opts, cb);\n      }\n    } else if (this._state !== DEFAULT) {\n      this.enqueue([this.dispatch, data, this._compress, opts, cb]);\n    } else {\n      this.dispatch(data, this._compress, opts, cb);\n    }\n  }\n\n  /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  getBlobData(blob, compress, options, cb) {\n    this._bufferedBytes += options[kByteLength];\n    this._state = GET_BLOB_DATA;\n\n    blob\n      .arrayBuffer()\n      .then((arrayBuffer) => {\n        if (this._socket.destroyed) {\n          const err = new Error(\n            'The socket was closed while the blob was being read'\n          );\n\n          //\n          // `callCallbacks` is called in the next tick to ensure that errors\n          // that might be thrown in the callbacks behave like errors thrown\n          // outside the promise chain.\n          //\n          process.nextTick(callCallbacks, this, err, cb);\n          return;\n        }\n\n        this._bufferedBytes -= options[kByteLength];\n        const data = toBuffer(arrayBuffer);\n\n        if (!compress) {\n          this._state = DEFAULT;\n          this.sendFrame(Sender.frame(data, options), cb);\n          this.dequeue();\n        } else {\n          this.dispatch(data, compress, options, cb);\n        }\n      })\n      .catch((err) => {\n        //\n        // `onError` is called in the next tick for the same reason that\n        // `callCallbacks` above is.\n        //\n        process.nextTick(onError, this, err, cb);\n      });\n  }\n\n  /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  dispatch(data, compress, options, cb) {\n    if (!compress) {\n      this.sendFrame(Sender.frame(data, options), cb);\n      return;\n    }\n\n    const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n\n    this._bufferedBytes += options[kByteLength];\n    this._state = DEFLATING;\n    perMessageDeflate.compress(data, options.fin, (_, buf) => {\n      if (this._socket.destroyed) {\n        const err = new Error(\n          'The socket was closed while data was being compressed'\n        );\n\n        callCallbacks(this, err, cb);\n        return;\n      }\n\n      this._bufferedBytes -= options[kByteLength];\n      this._state = DEFAULT;\n      options.readOnly = false;\n      this.sendFrame(Sender.frame(buf, options), cb);\n      this.dequeue();\n    });\n  }\n\n  /**\n   * Executes queued send operations.\n   *\n   * @private\n   */\n  dequeue() {\n    while (this._state === DEFAULT && this._queue.length) {\n      const params = this._queue.shift();\n\n      this._bufferedBytes -= params[3][kByteLength];\n      Reflect.apply(params[0], this, params.slice(1));\n    }\n  }\n\n  /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */\n  enqueue(params) {\n    this._bufferedBytes += params[3][kByteLength];\n    this._queue.push(params);\n  }\n\n  /**\n   * Sends a frame.\n   *\n   * @param {(Buffer | String)[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */\n  sendFrame(list, cb) {\n    if (list.length === 2) {\n      this._socket.cork();\n      this._socket.write(list[0]);\n      this._socket.write(list[1], cb);\n      this._socket.uncork();\n    } else {\n      this._socket.write(list[0], cb);\n    }\n  }\n}\n\nmodule.exports = Sender;\n\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */\nfunction callCallbacks(sender, err, cb) {\n  if (typeof cb === 'function') cb(err);\n\n  for (let i = 0; i < sender._queue.length; i++) {\n    const params = sender._queue[i];\n    const callback = params[params.length - 1];\n\n    if (typeof callback === 'function') callback(err);\n  }\n}\n\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */\nfunction onError(sender, err, cb) {\n  callCallbacks(sender, err, cb);\n  sender.onerror(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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RUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxHQUFHO0FBQ2hCLGFBQWEsU0FBUztBQUN0QixhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE1BQU07QUFDbkIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpQkFBaUI7QUFDOUIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsVUFBVTtBQUN2QjtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsUUFBUTtBQUNyQixhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEscUJBQXFCO0FBQ2xDLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLE9BQU87QUFDbEIsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQiwwQkFBMEI7QUFDNUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsT0FBTztBQUNsQixXQUFXLFVBQVU7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzPzVjOWQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4XCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHJhbmRvbUZpbGxTeW5jIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgeyBFTVBUWV9CVUZGRVIsIGtXZWJTb2NrZXQsIE5PT1AgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGlzQmxvYiwgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IGtCeXRlTGVuZ3RoID0gU3ltYm9sKCdrQnl0ZUxlbmd0aCcpO1xuY29uc3QgbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbmNvbnN0IFJBTkRPTV9QT09MX1NJWkUgPSA4ICogMTAyNDtcbmxldCByYW5kb21Qb29sO1xubGV0IHJhbmRvbVBvb2xQb2ludGVyID0gUkFORE9NX1BPT0xfU0laRTtcblxuY29uc3QgREVGQVVMVCA9IDA7XG5jb25zdCBERUZMQVRJTkcgPSAxO1xuY29uc3QgR0VUX0JMT0JfREFUQSA9IDI7XG5cbi8qKlxuICogSHlCaSBTZW5kZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFNlbmRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBjb25uZWN0aW9uIHNvY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2dlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc29ja2V0LCBleHRlbnNpb25zLCBnZW5lcmF0ZU1hc2spIHtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcblxuICAgIGlmIChnZW5lcmF0ZU1hc2spIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlTWFzayA9IGdlbmVyYXRlTWFzaztcbiAgICAgIHRoaXMuX21hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG4gICAgdGhpcy5fY29tcHJlc3MgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgIHRoaXMub25lcnJvciA9IE5PT1A7XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcmV0dXJuIHsoQnVmZmVyfFN0cmluZylbXX0gVGhlIGZyYW1lZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hc2s7XG4gICAgbGV0IG1lcmdlID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IHNraXBNYXNraW5nID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5tYXNrKSB7XG4gICAgICBtYXNrID0gb3B0aW9ucy5tYXNrQnVmZmVyIHx8IG1hc2tCdWZmZXI7XG5cbiAgICAgIGlmIChvcHRpb25zLmdlbmVyYXRlTWFzaykge1xuICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyYW5kb21Qb29sUG9pbnRlciA9PT0gUkFORE9NX1BPT0xfU0laRSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuICAgICAgICAgIGlmIChyYW5kb21Qb29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGxhemlseSBpbml0aWFsaXplZCBiZWNhdXNlIHNlcnZlci1zZW50IGZyYW1lcyBtdXN0IG5vdFxuICAgICAgICAgICAgLy8gYmUgbWFza2VkIHNvIGl0IG1heSBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJhbmRvbVBvb2wgPSBCdWZmZXIuYWxsb2MoUkFORE9NX1BPT0xfU0laRSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmFuZG9tRmlsbFN5bmMocmFuZG9tUG9vbCwgMCwgUkFORE9NX1BPT0xfU0laRSk7XG4gICAgICAgICAgcmFuZG9tUG9vbFBvaW50ZXIgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFza1swXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbMV0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzJdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1szXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICB9XG5cbiAgICAgIHNraXBNYXNraW5nID0gKG1hc2tbMF0gfCBtYXNrWzFdIHwgbWFza1syXSB8IG1hc2tbM10pID09PSAwO1xuICAgICAgb2Zmc2V0ID0gNjtcbiAgICB9XG5cbiAgICBsZXQgZGF0YUxlbmd0aDtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKCFvcHRpb25zLm1hc2sgfHwgc2tpcE1hc2tpbmcpICYmXG4gICAgICAgIG9wdGlvbnNba0J5dGVMZW5ndGhdICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICBkYXRhTGVuZ3RoID0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbWVyZ2UgPSBvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seSAmJiAhc2tpcE1hc2tpbmc7XG4gICAgfVxuXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBkYXRhTGVuZ3RoO1xuXG4gICAgaWYgKGRhdGFMZW5ndGggPj0gNjU1MzYpIHtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNztcbiAgICB9IGVsc2UgaWYgKGRhdGFMZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhTGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0KTtcblxuICAgIHRhcmdldFswXSA9IG9wdGlvbnMuZmluID8gb3B0aW9ucy5vcGNvZGUgfCAweDgwIDogb3B0aW9ucy5vcGNvZGU7XG4gICAgaWYgKG9wdGlvbnMucnN2MSkgdGFyZ2V0WzBdIHw9IDB4NDA7XG5cbiAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDE2QkUoZGF0YUxlbmd0aCwgMik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIHRhcmdldFsyXSA9IHRhcmdldFszXSA9IDA7XG4gICAgICB0YXJnZXQud3JpdGVVSW50QkUoZGF0YUxlbmd0aCwgNCwgNik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1hc2spIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIHRhcmdldFsxXSB8PSAweDgwO1xuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XG4gICAgdGFyZ2V0W29mZnNldCAtIDNdID0gbWFza1sxXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XG5cbiAgICBpZiAoc2tpcE1hc2tpbmcpIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIGlmIChtZXJnZSkge1xuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgZGF0YSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBUaGUgc3RhdHVzIGNvZGUgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnVmO1xuXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8ICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHZhbGlkIGVycm9yIGNvZGUgbnVtYmVyJyk7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMik7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cbiAgICAgIGlmIChsZW5ndGggPiAxMjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBtZXNzYWdlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjMgYnl0ZXMnKTtcbiAgICAgIH1cblxuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBsZW5ndGgpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmLndyaXRlKGRhdGEsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmLnNldChkYXRhLCAyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnVmLmxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDgsXG4gICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnlcbiAgICogICAgIG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG4gICAgbGV0IG9wY29kZSA9IG9wdGlvbnMuYmluYXJ5ID8gMiA6IDE7XG4gICAgbGV0IHJzdjEgPSBvcHRpb25zLmNvbXByZXNzO1xuXG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSBmYWxzZTtcbiAgICAgIGlmIChcbiAgICAgICAgcnN2MSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5wYXJhbXNbXG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuX2lzU2VydmVyXG4gICAgICAgICAgICA/ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgICAgIDogJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICBdXG4gICAgICApIHtcbiAgICAgICAgcnN2MSA9IGJ5dGVMZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbXByZXNzID0gcnN2MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN2MSA9IGZhbHNlO1xuICAgICAgb3Bjb2RlID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maW4pIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29udGVudHMgb2YgYSBibG9iIGFzIGJpbmFyeSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgVGhlIGJsb2JcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgdGhlIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEJsb2JEYXRhKGJsb2IsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfQkxPQl9EQVRBO1xuXG4gICAgYmxvYlxuICAgICAgLmFycmF5QnVmZmVyKClcbiAgICAgIC50aGVuKChhcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgdGhlIGJsb2Igd2FzIGJlaW5nIHJlYWQnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gYGNhbGxDYWxsYmFja3NgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIHRvIGVuc3VyZSB0aGF0IGVycm9yc1xuICAgICAgICAgIC8vIHRoYXQgbWlnaHQgYmUgdGhyb3duIGluIHRoZSBjYWxsYmFja3MgYmVoYXZlIGxpa2UgZXJyb3JzIHRocm93blxuICAgICAgICAgIC8vIG91dHNpZGUgdGhlIHByb21pc2UgY2hhaW4uXG4gICAgICAgICAgLy9cbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxDYWxsYmFja3MsIHRoaXMsIGVyciwgY2IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0b0J1ZmZlcihhcnJheUJ1ZmZlcik7XG5cbiAgICAgICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICAgICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAvL1xuICAgICAgICAvLyBgb25FcnJvcmAgaXMgY2FsbGVkIGluIHRoZSBuZXh0IHRpY2sgZm9yIHRoZSBzYW1lIHJlYXNvbiB0aGF0XG4gICAgICAgIC8vIGBjYWxsQ2FsbGJhY2tzYCBhYm92ZSBpcy5cbiAgICAgICAgLy9cbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbkVycm9yLCB0aGlzLCBlcnIsIGNiKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9zdGF0ZSA9IERFRkxBVElORztcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5jb21wcmVzcyhkYXRhLCBvcHRpb25zLmZpbiwgKF8sIGJ1ZikgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgY29tcHJlc3NlZCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYWxsQ2FsbGJhY2tzKHRoaXMsIGVyciwgY2IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgICBvcHRpb25zLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgcXVldWVkIHNlbmQgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlcXVldWUoKSB7XG4gICAgd2hpbGUgKHRoaXMuX3N0YXRlID09PSBERUZBVUxUICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlciB8IFN0cmluZylbXX0gbGlzdCBUaGUgZnJhbWUgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kRnJhbWUobGlzdCwgY2IpIHtcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuX3NvY2tldC5jb3JrKCk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFsxXSwgY2IpO1xuICAgICAgdGhpcy5fc29ja2V0LnVuY29yaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlcjtcblxuLyoqXG4gKiBDYWxscyBxdWV1ZWQgY2FsbGJhY2tzIHdpdGggYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTZW5kZXJ9IHNlbmRlciBUaGUgYFNlbmRlcmAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3IgdG8gY2FsbCB0aGUgY2FsbGJhY2tzIHdpdGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gVGhlIGZpcnN0IGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYWxsQ2FsbGJhY2tzKHNlbmRlciwgZXJyLCBjYikge1xuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VuZGVyLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5fcXVldWVbaV07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXMgYSBgU2VuZGVyYCBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1NlbmRlcn0gc2VuZGVyIFRoZSBgU2VuZGVyYCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgcGVuZGluZyBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gb25FcnJvcihzZW5kZXIsIGVyciwgY2IpIHtcbiAgY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpO1xuICBzZW5kZXIub25lcnJvcihlcnIpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^WebSocket$\" }] */\n\n\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"./node_modules/ws/lib/websocket.js\");\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */\nfunction emitClose(stream) {\n  stream.emit('close');\n}\n\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */\nfunction duplexOnEnd() {\n  if (!this.destroyed && this._writableState.finished) {\n    this.destroy();\n  }\n}\n\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */\nfunction duplexOnError(err) {\n  this.removeListener('error', duplexOnError);\n  this.destroy();\n  if (this.listenerCount('error') === 0) {\n    // Do not suppress the throwing behavior.\n    this.emit('error', err);\n  }\n}\n\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */\nfunction createWebSocketStream(ws, options) {\n  let terminateOnDestroy = true;\n\n  const duplex = new Duplex({\n    ...options,\n    autoDestroy: false,\n    emitClose: false,\n    objectMode: false,\n    writableObjectMode: false\n  });\n\n  ws.on('message', function message(msg, isBinary) {\n    const data =\n      !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n\n    if (!duplex.push(data)) ws.pause();\n  });\n\n  ws.once('error', function error(err) {\n    if (duplex.destroyed) return;\n\n    // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n    //\n    // - If the `'error'` event is emitted before the `'open'` event, then\n    //   `ws.terminate()` is a noop as no socket is assigned.\n    // - Otherwise, the error is re-emitted by the listener of the `'error'`\n    //   event of the `Receiver` object. The listener already closes the\n    //   connection by calling `ws.close()`. This allows a close frame to be\n    //   sent to the other peer. If `ws.terminate()` is called right after this,\n    //   then the close frame might not be sent.\n    terminateOnDestroy = false;\n    duplex.destroy(err);\n  });\n\n  ws.once('close', function close() {\n    if (duplex.destroyed) return;\n\n    duplex.push(null);\n  });\n\n  duplex._destroy = function (err, callback) {\n    if (ws.readyState === ws.CLOSED) {\n      callback(err);\n      process.nextTick(emitClose, duplex);\n      return;\n    }\n\n    let called = false;\n\n    ws.once('error', function error(err) {\n      called = true;\n      callback(err);\n    });\n\n    ws.once('close', function close() {\n      if (!called) callback(err);\n      process.nextTick(emitClose, duplex);\n    });\n\n    if (terminateOnDestroy) ws.terminate();\n  };\n\n  duplex._final = function (callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._final(callback);\n      });\n      return;\n    }\n\n    // If the value of the `_socket` property is `null` it means that `ws` is a\n    // client websocket and the handshake failed. In fact, when this happens, a\n    // socket is never assigned to the websocket. Wait for the `'error'` event\n    // that will be emitted by the websocket.\n    if (ws._socket === null) return;\n\n    if (ws._socket._writableState.finished) {\n      callback();\n      if (duplex._readableState.endEmitted) duplex.destroy();\n    } else {\n      ws._socket.once('finish', function finish() {\n        // `duplex` is not destroyed here because the `'end'` event will be\n        // emitted on `duplex` after this `'finish'` event. The EOF signaling\n        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n        callback();\n      });\n      ws.close();\n    }\n  };\n\n  duplex._read = function () {\n    if (ws.isPaused) ws.resume();\n  };\n\n  duplex._write = function (chunk, encoding, callback) {\n    if (ws.readyState === ws.CONNECTING) {\n      ws.once('open', function open() {\n        duplex._write(chunk, encoding, callback);\n      });\n      return;\n    }\n\n    ws.send(chunk, callback);\n  };\n\n  duplex.on('end', duplexOnEnd);\n  duplex.on('error', duplexOnError);\n  return duplex;\n}\n\nmodule.exports = createWebSocketStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxzQ0FBc0Msb0NBQW9DO0FBQzdEOztBQUViLGtCQUFrQixtQkFBTyxDQUFDLHVEQUFhO0FBQ3ZDLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFdBQVc7QUFDdEIsV0FBVyxRQUFRO0FBQ25CLFlBQVksUUFBUTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzP2Q1YmMiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeV2ViU29ja2V0JFwiIH1dICovXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc3RyZWFtIFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7RHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHRlcm1pbmF0ZU9uRGVzdHJveSA9IHRydWU7XG5cbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcbiAgICBvYmplY3RNb2RlOiBmYWxzZSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXG4gIH0pO1xuXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9XG4gICAgICAhaXNCaW5hcnkgJiYgZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPyBtc2cudG9TdHJpbmcoKSA6IG1zZztcblxuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpIHdzLnBhdXNlKCk7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIC8vIFByZXZlbnQgYHdzLnRlcm1pbmF0ZSgpYCBmcm9tIGJlaW5nIGNhbGxlZCBieSBgZHVwbGV4Ll9kZXN0cm95KClgLlxuICAgIC8vXG4gICAgLy8gLSBJZiB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgYmVmb3JlIHRoZSBgJ29wZW4nYCBldmVudCwgdGhlblxuICAgIC8vICAgYHdzLnRlcm1pbmF0ZSgpYCBpcyBhIG5vb3AgYXMgbm8gc29ja2V0IGlzIGFzc2lnbmVkLlxuICAgIC8vIC0gT3RoZXJ3aXNlLCB0aGUgZXJyb3IgaXMgcmUtZW1pdHRlZCBieSB0aGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYFxuICAgIC8vICAgZXZlbnQgb2YgdGhlIGBSZWNlaXZlcmAgb2JqZWN0LiBUaGUgbGlzdGVuZXIgYWxyZWFkeSBjbG9zZXMgdGhlXG4gICAgLy8gICBjb25uZWN0aW9uIGJ5IGNhbGxpbmcgYHdzLmNsb3NlKClgLiBUaGlzIGFsbG93cyBhIGNsb3NlIGZyYW1lIHRvIGJlXG4gICAgLy8gICBzZW50IHRvIHRoZSBvdGhlciBwZWVyLiBJZiBgd3MudGVybWluYXRlKClgIGlzIGNhbGxlZCByaWdodCBhZnRlciB0aGlzLFxuICAgIC8vICAgdGhlbiB0aGUgY2xvc2UgZnJhbWUgbWlnaHQgbm90IGJlIHNlbnQuXG4gICAgdGVybWluYXRlT25EZXN0cm95ID0gZmFsc2U7XG4gICAgZHVwbGV4LmRlc3Ryb3koZXJyKTtcbiAgfSk7XG5cbiAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgZHVwbGV4LnB1c2gobnVsbCk7XG4gIH0pO1xuXG4gIGR1cGxleC5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNMT1NFRCkge1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBjYWxsZWQgPSBmYWxzZTtcblxuICAgIHdzLm9uY2UoJ2Vycm9yJywgZnVuY3Rpb24gZXJyb3IoZXJyKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcblxuICAgIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICBpZiAoIWNhbGxlZCkgY2FsbGJhY2soZXJyKTtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCBkdXBsZXgpO1xuICAgIH0pO1xuXG4gICAgaWYgKHRlcm1pbmF0ZU9uRGVzdHJveSkgd3MudGVybWluYXRlKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll9maW5hbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll9maW5hbChjYWxsYmFjayk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIGBfc29ja2V0YCBwcm9wZXJ0eSBpcyBgbnVsbGAgaXQgbWVhbnMgdGhhdCBgd3NgIGlzIGFcbiAgICAvLyBjbGllbnQgd2Vic29ja2V0IGFuZCB0aGUgaGFuZHNoYWtlIGZhaWxlZC4gSW4gZmFjdCwgd2hlbiB0aGlzIGhhcHBlbnMsIGFcbiAgICAvLyBzb2NrZXQgaXMgbmV2ZXIgYXNzaWduZWQgdG8gdGhlIHdlYnNvY2tldC4gV2FpdCBmb3IgdGhlIGAnZXJyb3InYCBldmVudFxuICAgIC8vIHRoYXQgd2lsbCBiZSBlbWl0dGVkIGJ5IHRoZSB3ZWJzb2NrZXQuXG4gICAgaWYgKHdzLl9zb2NrZXQgPT09IG51bGwpIHJldHVybjtcblxuICAgIGlmICh3cy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgICBjYWxsYmFjaygpO1xuICAgICAgaWYgKGR1cGxleC5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSBkdXBsZXguZGVzdHJveSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB3cy5fc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIGZ1bmN0aW9uIGZpbmlzaCgpIHtcbiAgICAgICAgLy8gYGR1cGxleGAgaXMgbm90IGRlc3Ryb3llZCBoZXJlIGJlY2F1c2UgdGhlIGAnZW5kJ2AgZXZlbnQgd2lsbCBiZVxuICAgICAgICAvLyBlbWl0dGVkIG9uIGBkdXBsZXhgIGFmdGVyIHRoaXMgYCdmaW5pc2gnYCBldmVudC4gVGhlIEVPRiBzaWduYWxpbmdcbiAgICAgICAgLy8gYG51bGxgIGNodW5rIGlzLCBpbiBmYWN0LCBwdXNoZWQgd2hlbiB0aGUgd2Vic29ja2V0IGVtaXRzIGAnY2xvc2UnYC5cbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgIH0pO1xuICAgICAgd3MuY2xvc2UoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll9yZWFkID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh3cy5pc1BhdXNlZCkgd3MucmVzdW1lKCk7XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHJldHVybiBkdXBsZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */\nfunction parse(header) {\n  const protocols = new Set();\n  let start = -1;\n  let end = -1;\n  let i = 0;\n\n  for (i; i < header.length; i++) {\n    const code = header.charCodeAt(i);\n\n    if (end === -1 && tokenChars[code] === 1) {\n      if (start === -1) start = i;\n    } else if (\n      i !== 0 &&\n      (code === 0x20 /* ' ' */ || code === 0x09) /* '\\t' */\n    ) {\n      if (end === -1 && start !== -1) end = i;\n    } else if (code === 0x2c /* ',' */) {\n      if (start === -1) {\n        throw new SyntaxError(`Unexpected character at index ${i}`);\n      }\n\n      if (end === -1) end = i;\n\n      const protocol = header.slice(start, end);\n\n      if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n      }\n\n      protocols.add(protocol);\n      start = end = -1;\n    } else {\n      throw new SyntaxError(`Unexpected character at index ${i}`);\n    }\n  }\n\n  if (start === -1 || end !== -1) {\n    throw new SyntaxError('Unexpected end of input');\n  }\n\n  const protocol = header.slice(start, i);\n\n  if (protocols.has(protocol)) {\n    throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n  }\n\n  protocols.add(protocol);\n  return protocols;\n}\n\nmodule.exports = { parse };\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLFFBQVEsYUFBYSxFQUFFLG1CQUFPLENBQUMseURBQWM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxtQkFBbUI7QUFDN0I7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLCtEQUErRCxFQUFFO0FBQ2pFOztBQUVBOztBQUVBOztBQUVBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTiw2REFBNkQsRUFBRTtBQUMvRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGtDQUFrQyxTQUFTO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zdWJwcm90b2NvbC5qcz83OTRiIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyB0b2tlbkNoYXJzIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuLyoqXG4gKiBQYXJzZXMgdGhlIGBTZWMtV2ViU29ja2V0LVByb3RvY29sYCBoZWFkZXIgaW50byBhIHNldCBvZiBzdWJwcm90b2NvbCBuYW1lcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyIFRoZSBmaWVsZCB2YWx1ZSBvZiB0aGUgaGVhZGVyXG4gKiBAcmV0dXJuIHtTZXR9IFRoZSBzdWJwcm90b2NvbCBuYW1lc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3QgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yIChpOyBpIDwgaGVhZGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgY29kZSA9IGhlYWRlci5jaGFyQ29kZUF0KGkpO1xuXG4gICAgaWYgKGVuZCA9PT0gLTEgJiYgdG9rZW5DaGFyc1tjb2RlXSA9PT0gMSkge1xuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICBpICE9PSAwICYmXG4gICAgICAoY29kZSA9PT0gMHgyMCAvKiAnICcgKi8gfHwgY29kZSA9PT0gMHgwOSkgLyogJ1xcdCcgKi9cbiAgICApIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHN0YXJ0ICE9PSAtMSkgZW5kID0gaTtcbiAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MmMgLyogJywnICovKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuXG4gICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcblxuICAgICAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG5cbiAgICAgIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICAgICAgfVxuXG4gICAgICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gLTEgfHwgZW5kICE9PSAtMSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBlbmQgb2YgaW5wdXQnKTtcbiAgfVxuXG4gIGNvbnN0IHByb3RvY29sID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBpKTtcblxuICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFRoZSBcIiR7cHJvdG9jb2x9XCIgc3VicHJvdG9jb2wgaXMgZHVwbGljYXRlZGApO1xuICB9XG5cbiAgcHJvdG9jb2xzLmFkZChwcm90b2NvbCk7XG4gIHJldHVybiBwcm90b2NvbHM7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBwYXJzZSB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\n\nconst { hasBlob } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31\n  0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63\n  0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111\n  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127\n];\n\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */\nfunction isValidStatusCode(code) {\n  return (\n    (code >= 1000 &&\n      code <= 1014 &&\n      code !== 1004 &&\n      code !== 1005 &&\n      code !== 1006) ||\n    (code >= 3000 && code <= 4999)\n  );\n}\n\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */\nfunction _isValidUTF8(buf) {\n  const len = buf.length;\n  let i = 0;\n\n  while (i < len) {\n    if ((buf[i] & 0x80) === 0) {\n      // 0xxxxxxx\n      i++;\n    } else if ((buf[i] & 0xe0) === 0xc0) {\n      // 110xxxxx 10xxxxxx\n      if (\n        i + 1 === len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i] & 0xfe) === 0xc0 // Overlong\n      ) {\n        return false;\n      }\n\n      i += 2;\n    } else if ((buf[i] & 0xf0) === 0xe0) {\n      // 1110xxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 2 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80) || // Overlong\n        (buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0) // Surrogate (U+D800 - U+DFFF)\n      ) {\n        return false;\n      }\n\n      i += 3;\n    } else if ((buf[i] & 0xf8) === 0xf0) {\n      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n      if (\n        i + 3 >= len ||\n        (buf[i + 1] & 0xc0) !== 0x80 ||\n        (buf[i + 2] & 0xc0) !== 0x80 ||\n        (buf[i + 3] & 0xc0) !== 0x80 ||\n        (buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80) || // Overlong\n        (buf[i] === 0xf4 && buf[i + 1] > 0x8f) ||\n        buf[i] > 0xf4 // > U+10FFFF\n      ) {\n        return false;\n      }\n\n      i += 4;\n    } else {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */\nfunction isBlob(value) {\n  return (\n    hasBlob &&\n    typeof value === 'object' &&\n    typeof value.arrayBuffer === 'function' &&\n    typeof value.type === 'string' &&\n    typeof value.stream === 'function' &&\n    (value[Symbol.toStringTag] === 'Blob' ||\n      value[Symbol.toStringTag] === 'File')\n  );\n}\n\nmodule.exports = {\n  isBlob,\n  isValidStatusCode,\n  isValidUTF8: _isValidUTF8,\n  tokenChars\n};\n\nif (isUtf8) {\n  module.exports.isValidUTF8 = function (buf) {\n    return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n  };\n} /* istanbul ignore else  */ else if (!{}.WS_NO_UTF_8_VALIDATE) {\n  try {\n    const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"utf-8-validate\");\n\n    module.exports.isValidUTF8 = function (buf) {\n      return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n    };\n  } catch (e) {\n    // Continue regardless of the error.\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL3ZhbGlkYXRpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsUUFBUSxTQUFTLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFbkMsUUFBUSxVQUFVLEVBQUUsbUJBQU8sQ0FBQyx1REFBYTs7QUFFekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFlBQVksU0FBUztBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLEdBQUc7QUFDZCxZQUFZLFNBQVM7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRSwwQkFBMEI7QUFDNUI7QUFDQTtBQUNBLEVBQUUsc0NBQXNDLEVBQVc7QUFDbkQ7QUFDQSx3QkFBd0IsbUJBQU8sQ0FBQyxzQ0FBZ0I7O0FBRWhELElBQUksMEJBQTBCO0FBQzlCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHJpdHVubC8uL25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcz9jNGI4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBpc1V0ZjggfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuXG5jb25zdCB7IGhhc0Jsb2IgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YXR1cyBjb2RlIGlzIGFsbG93ZWQgaW4gYSBjbG9zZSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XG4gICAgICAvLyAweHh4eHh4eFxuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSAmIDB4ZmUpID09PSAweGMwIC8vIE92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAzO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAvLyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmKSB8fFxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIGEgYEJsb2JgLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHRlc3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBgQmxvYmAsIGVsc2UgYGZhbHNlYFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaGFzQmxvYiAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXG4gICAgKHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdCbG9iJyB8fFxuICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0ZpbGUnKVxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNCbG9iLFxuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgdG9rZW5DaGFyc1xufTtcblxuaWYgKGlzVXRmOCkge1xuICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcbiAgfTtcbn0gLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovIGVsc2UgaWYgKCFwcm9jZXNzLmVudi5XU19OT19VVEZfOF9WQUxJREFURSkge1xuICB0cnkge1xuICAgIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAzMiA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\n\nconst extension = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"./node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"./node_modules/ws/lib/websocket.js\");\nconst { GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\n\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\n\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */\nclass WebSocketServer extends EventEmitter {\n  /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */\n  constructor(options, callback) {\n    super();\n\n    options = {\n      allowSynchronousEvents: true,\n      autoPong: true,\n      maxPayload: 100 * 1024 * 1024,\n      skipUTF8Validation: false,\n      perMessageDeflate: false,\n      handleProtocols: null,\n      clientTracking: true,\n      verifyClient: null,\n      noServer: false,\n      backlog: null, // use default (511 as implemented in net.js)\n      server: null,\n      host: null,\n      path: null,\n      port: null,\n      WebSocket,\n      ...options\n    };\n\n    if (\n      (options.port == null && !options.server && !options.noServer) ||\n      (options.port != null && (options.server || options.noServer)) ||\n      (options.server && options.noServer)\n    ) {\n      throw new TypeError(\n        'One and only one of the \"port\", \"server\", or \"noServer\" options ' +\n          'must be specified'\n      );\n    }\n\n    if (options.port != null) {\n      this._server = http.createServer((req, res) => {\n        const body = http.STATUS_CODES[426];\n\n        res.writeHead(426, {\n          'Content-Length': body.length,\n          'Content-Type': 'text/plain'\n        });\n        res.end(body);\n      });\n      this._server.listen(\n        options.port,\n        options.host,\n        options.backlog,\n        callback\n      );\n    } else if (options.server) {\n      this._server = options.server;\n    }\n\n    if (this._server) {\n      const emitConnection = this.emit.bind(this, 'connection');\n\n      this._removeListeners = addListeners(this._server, {\n        listening: this.emit.bind(this, 'listening'),\n        error: this.emit.bind(this, 'error'),\n        upgrade: (req, socket, head) => {\n          this.handleUpgrade(req, socket, head, emitConnection);\n        }\n      });\n    }\n\n    if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n    if (options.clientTracking) {\n      this.clients = new Set();\n      this._shouldEmitClose = false;\n    }\n\n    this.options = options;\n    this._state = RUNNING;\n  }\n\n  /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */\n  address() {\n    if (this.options.noServer) {\n      throw new Error('The server is operating in \"noServer\" mode');\n    }\n\n    if (!this._server) return null;\n    return this._server.address();\n  }\n\n  /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */\n  close(cb) {\n    if (this._state === CLOSED) {\n      if (cb) {\n        this.once('close', () => {\n          cb(new Error('The server is not running'));\n        });\n      }\n\n      process.nextTick(emitClose, this);\n      return;\n    }\n\n    if (cb) this.once('close', cb);\n\n    if (this._state === CLOSING) return;\n    this._state = CLOSING;\n\n    if (this.options.noServer || this.options.server) {\n      if (this._server) {\n        this._removeListeners();\n        this._removeListeners = this._server = null;\n      }\n\n      if (this.clients) {\n        if (!this.clients.size) {\n          process.nextTick(emitClose, this);\n        } else {\n          this._shouldEmitClose = true;\n        }\n      } else {\n        process.nextTick(emitClose, this);\n      }\n    } else {\n      const server = this._server;\n\n      this._removeListeners();\n      this._removeListeners = this._server = null;\n\n      //\n      // The HTTP/S server was created internally. Close it, and rely on its\n      // `'close'` event.\n      //\n      server.close(() => {\n        emitClose(this);\n      });\n    }\n  }\n\n  /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */\n  shouldHandle(req) {\n    if (this.options.path) {\n      const index = req.url.indexOf('?');\n      const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n\n      if (pathname !== this.options.path) return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */\n  handleUpgrade(req, socket, head, cb) {\n    socket.on('error', socketOnError);\n\n    const key = req.headers['sec-websocket-key'];\n    const upgrade = req.headers.upgrade;\n    const version = +req.headers['sec-websocket-version'];\n\n    if (req.method !== 'GET') {\n      const message = 'Invalid HTTP method';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n      return;\n    }\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      const message = 'Invalid Upgrade header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (key === undefined || !keyRegex.test(key)) {\n      const message = 'Missing or invalid Sec-WebSocket-Key header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (version !== 8 && version !== 13) {\n      const message = 'Missing or invalid Sec-WebSocket-Version header';\n      abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n      return;\n    }\n\n    if (!this.shouldHandle(req)) {\n      abortHandshake(socket, 400);\n      return;\n    }\n\n    const secWebSocketProtocol = req.headers['sec-websocket-protocol'];\n    let protocols = new Set();\n\n    if (secWebSocketProtocol !== undefined) {\n      try {\n        protocols = subprotocol.parse(secWebSocketProtocol);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Protocol header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    const secWebSocketExtensions = req.headers['sec-websocket-extensions'];\n    const extensions = {};\n\n    if (\n      this.options.perMessageDeflate &&\n      secWebSocketExtensions !== undefined\n    ) {\n      const perMessageDeflate = new PerMessageDeflate(\n        this.options.perMessageDeflate,\n        true,\n        this.options.maxPayload\n      );\n\n      try {\n        const offers = extension.parse(secWebSocketExtensions);\n\n        if (offers[PerMessageDeflate.extensionName]) {\n          perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n          extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n      } catch (err) {\n        const message =\n          'Invalid or unacceptable Sec-WebSocket-Extensions header';\n        abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n        return;\n      }\n    }\n\n    //\n    // Optionally call external client verification handler.\n    //\n    if (this.options.verifyClient) {\n      const info = {\n        origin:\n          req.headers[`${version === 8 ? 'sec-websocket-origin' : 'origin'}`],\n        secure: !!(req.socket.authorized || req.socket.encrypted),\n        req\n      };\n\n      if (this.options.verifyClient.length === 2) {\n        this.options.verifyClient(info, (verified, code, message, headers) => {\n          if (!verified) {\n            return abortHandshake(socket, code || 401, message, headers);\n          }\n\n          this.completeUpgrade(\n            extensions,\n            key,\n            protocols,\n            req,\n            socket,\n            head,\n            cb\n          );\n        });\n        return;\n      }\n\n      if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n    }\n\n    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n  }\n\n  /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */\n  completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n    //\n    // Destroy the socket if the client has already sent a FIN packet.\n    //\n    if (!socket.readable || !socket.writable) return socket.destroy();\n\n    if (socket[kWebSocket]) {\n      throw new Error(\n        'server.handleUpgrade() was called more than once with the same ' +\n          'socket, possibly due to a misconfiguration'\n      );\n    }\n\n    if (this._state > RUNNING) return abortHandshake(socket, 503);\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    const headers = [\n      'HTTP/1.1 101 Switching Protocols',\n      'Upgrade: websocket',\n      'Connection: Upgrade',\n      `Sec-WebSocket-Accept: ${digest}`\n    ];\n\n    const ws = new this.options.WebSocket(null, undefined, this.options);\n\n    if (protocols.size) {\n      //\n      // Optionally call external protocol selection handler.\n      //\n      const protocol = this.options.handleProtocols\n        ? this.options.handleProtocols(protocols, req)\n        : protocols.values().next().value;\n\n      if (protocol) {\n        headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n        ws._protocol = protocol;\n      }\n    }\n\n    if (extensions[PerMessageDeflate.extensionName]) {\n      const params = extensions[PerMessageDeflate.extensionName].params;\n      const value = extension.format({\n        [PerMessageDeflate.extensionName]: [params]\n      });\n      headers.push(`Sec-WebSocket-Extensions: ${value}`);\n      ws._extensions = extensions;\n    }\n\n    //\n    // Allow external modification/inspection of handshake headers.\n    //\n    this.emit('headers', headers, req);\n\n    socket.write(headers.concat('\\r\\n').join('\\r\\n'));\n    socket.removeListener('error', socketOnError);\n\n    ws.setSocket(socket, head, {\n      allowSynchronousEvents: this.options.allowSynchronousEvents,\n      maxPayload: this.options.maxPayload,\n      skipUTF8Validation: this.options.skipUTF8Validation\n    });\n\n    if (this.clients) {\n      this.clients.add(ws);\n      ws.on('close', () => {\n        this.clients.delete(ws);\n\n        if (this._shouldEmitClose && !this.clients.size) {\n          process.nextTick(emitClose, this);\n        }\n      });\n    }\n\n    cb(ws, req);\n  }\n}\n\nmodule.exports = WebSocketServer;\n\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */\nfunction addListeners(server, map) {\n  for (const event of Object.keys(map)) server.on(event, map[event]);\n\n  return function removeListeners() {\n    for (const event of Object.keys(map)) {\n      server.removeListener(event, map[event]);\n    }\n  };\n}\n\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */\nfunction emitClose(server) {\n  server._state = CLOSED;\n  server.emit('close');\n}\n\n/**\n * Handle socket errors.\n *\n * @private\n */\nfunction socketOnError() {\n  this.destroy();\n}\n\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */\nfunction abortHandshake(socket, code, message, headers) {\n  //\n  // The socket is writable unless the user destroyed or ended it before calling\n  // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n  // error. Handling this does not make much sense as the worst that can happen\n  // is that some of the data written by the user might be discarded due to the\n  // call to `socket.end()` below, which triggers an `'error'` event that in\n  // turn causes the socket to be destroyed.\n  //\n  message = message || http.STATUS_CODES[code];\n  headers = {\n    Connection: 'close',\n    'Content-Type': 'text/html',\n    'Content-Length': Buffer.byteLength(message),\n    ...headers\n  };\n\n  socket.once('finish', socket.destroy);\n\n  socket.end(\n    `HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` +\n      Object.keys(headers)\n        .map((h) => `${h}: ${headers[h]}`)\n        .join('\\r\\n') +\n      '\\r\\n\\r\\n' +\n      message\n  );\n}\n\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @private\n */\nfunction abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {\n  if (server.listenerCount('wsClientError')) {\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n\n    server.emit('wsClientError', err, socket, req);\n  } else {\n    abortHandshake(socket, code, message);\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC1zZXJ2ZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsc0NBQXNDLHlEQUF5RDs7QUFFbEY7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsc0JBQVE7QUFDckMsYUFBYSxtQkFBTyxDQUFDLGtCQUFNO0FBQzNCLFFBQVEsU0FBUyxFQUFFLG1CQUFPLENBQUMsc0JBQVE7QUFDbkMsUUFBUSxhQUFhLEVBQUUsbUJBQU8sQ0FBQyxzQkFBUTs7QUFFdkMsa0JBQWtCLG1CQUFPLENBQUMsdURBQWE7QUFDdkMsMEJBQTBCLG1CQUFPLENBQUMseUVBQXNCO0FBQ3hELG9CQUFvQixtQkFBTyxDQUFDLDJEQUFlO0FBQzNDLGtCQUFrQixtQkFBTyxDQUFDLHVEQUFhO0FBQ3ZDLFFBQVEsbUJBQW1CLEVBQUUsbUJBQU8sQ0FBQyx1REFBYTs7QUFFbEQsaUNBQWlDLEdBQUc7O0FBRXBDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQjtBQUNBLGFBQWEsU0FBUztBQUN0QixhQUFhLFFBQVE7QUFDckIsYUFBYSxrQkFBa0I7QUFDL0I7QUFDQSxhQUFhLFFBQVE7QUFDckIsYUFBYSw0QkFBNEI7QUFDekM7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLFVBQVU7QUFDdkIsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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QUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGNBQWM7QUFDekIsV0FBVywyQkFBMkI7QUFDdEMsWUFBWSxVQUFVO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZ0JBQWdCLE1BQU0sRUFBRSx3QkFBd0I7QUFDaEQ7QUFDQSx1QkFBdUIsRUFBRSxJQUFJLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUJBQWlCO0FBQzVCLFdBQVcsc0JBQXNCO0FBQ2pDLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wcml0dW5sLy4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzPzIxMGUiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4JFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IHsgRHVwbGV4IH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYWNrbG9nPTUxMV0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZlxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gICAqICAgICBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF0gQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvcnRdIFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLldlYlNvY2tldD1XZWJTb2NrZXRdIFNwZWNpZmllcyB0aGUgYFdlYlNvY2tldGBcbiAgICogICAgIGNsYXNzIHRvIHVzZS4gSXQgbXVzdCBiZSB0aGUgYFdlYlNvY2tldGAgY2xhc3Mgb3IgY2xhc3MgdGhhdCBleHRlbmRzIGl0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcbiAgICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIFdlYlNvY2tldCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikgfHxcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXG4gICAgICAgICAgJ211c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBub3QgcnVubmluZycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuICAgICAgLy8gYCdjbG9zZSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXTtcbiAgICBjb25zdCB1cGdyYWRlID0gcmVxLmhlYWRlcnMudXBncmFkZTtcbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcblxuICAgIGlmIChyZXEubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIEhUVFAgbWV0aG9kJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDA1LCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8ICFrZXlSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtS2V5IGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtVmVyc2lvbiBoZWFkZXInO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRIYW5kbGUocmVxKSkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldFByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBsZXQgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldFByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3RvY29scyA9IHN1YnByb3RvY29sLnBhcnNlKHNlY1dlYlNvY2tldFByb3RvY29sKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnSW52YWxpZCBvciB1bmFjY2VwdGFibGUgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUgfHwgNDAxLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXG4gICAgICAnQ29ubmVjdGlvbjogVXBncmFkZScsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuXG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsLCB1bmRlZmluZWQsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAocHJvdG9jb2xzLnNpemUpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgcHJvdG9jb2wgc2VsZWN0aW9uIGhhbmRsZXIuXG4gICAgICAvL1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scyhwcm90b2NvbHMsIHJlcSlcbiAgICAgICAgOiBwcm90b2NvbHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xuICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXG4gICAgICB9KTtcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xuICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQWxsb3cgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uL2luc3BlY3Rpb24gb2YgaGFuZHNoYWtlIGhlYWRlcnMuXG4gICAgLy9cbiAgICB0aGlzLmVtaXQoJ2hlYWRlcnMnLCBoZWFkZXJzLCByZXEpO1xuXG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgd3Muc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdGhpcy5vcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBtYXhQYXlsb2FkOiB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XG4gICAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRFbWl0Q2xvc2UgJiYgIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYih3cywgcmVxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW5cbiAqICAgICBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVtaXQgYSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYW4gYEV2ZW50RW1pdHRlcmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xuICBzZXJ2ZXIuX3N0YXRlID0gQ0xPU0VEO1xuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICAvL1xuICAvLyBUaGUgc29ja2V0IGlzIHdyaXRhYmxlIHVubGVzcyB0aGUgdXNlciBkZXN0cm95ZWQgb3IgZW5kZWQgaXQgYmVmb3JlIGNhbGxpbmdcbiAgLy8gYHNlcnZlci5oYW5kbGVVcGdyYWRlKClgIG9yIGluIHRoZSBgdmVyaWZ5Q2xpZW50YCBmdW5jdGlvbiwgd2hpY2ggaXMgYSB1c2VyXG4gIC8vIGVycm9yLiBIYW5kbGluZyB0aGlzIGRvZXMgbm90IG1ha2UgbXVjaCBzZW5zZSBhcyB0aGUgd29yc3QgdGhhdCBjYW4gaGFwcGVuXG4gIC8vIGlzIHRoYXQgc29tZSBvZiB0aGUgZGF0YSB3cml0dGVuIGJ5IHRoZSB1c2VyIG1pZ2h0IGJlIGRpc2NhcmRlZCBkdWUgdG8gdGhlXG4gIC8vIGNhbGwgdG8gYHNvY2tldC5lbmQoKWAgYmVsb3csIHdoaWNoIHRyaWdnZXJzIGFuIGAnZXJyb3InYCBldmVudCB0aGF0IGluXG4gIC8vIHR1cm4gY2F1c2VzIHRoZSBzb2NrZXQgdG8gYmUgZGVzdHJveWVkLlxuICAvL1xuICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgaGVhZGVycyA9IHtcbiAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKSxcbiAgICAuLi5oZWFkZXJzXG4gIH07XG5cbiAgc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIHNvY2tldC5kZXN0cm95KTtcblxuICBzb2NrZXQuZW5kKFxuICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7aHR0cC5TVEFUVVNfQ09ERVNbY29kZV19XFxyXFxuYCArXG4gICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgIC5qb2luKCdcXHJcXG4nKSArXG4gICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICBtZXNzYWdlXG4gICk7XG59XG5cbi8qKlxuICogRW1pdCBhIGAnd3NDbGllbnRFcnJvcidgIGV2ZW50IG9uIGEgYFdlYlNvY2tldFNlcnZlcmAgaWYgdGhlcmUgaXMgYXQgbGVhc3RcbiAqIG9uZSBsaXN0ZW5lciBmb3IgaXQsIG90aGVyd2lzZSBjYWxsIGBhYm9ydEhhbmRzaGFrZSgpYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldFNlcnZlcn0gc2VydmVyIFRoZSBXZWJTb2NrZXQgc2VydmVyXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcihzZXJ2ZXIsIHJlcSwgc29ja2V0LCBjb2RlLCBtZXNzYWdlKSB7XG4gIGlmIChzZXJ2ZXIubGlzdGVuZXJDb3VudCgnd3NDbGllbnRFcnJvcicpKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKTtcblxuICAgIHNlcnZlci5lbWl0KCd3c0NsaWVudEVycm9yJywgZXJyLCBzb2NrZXQsIHJlcSk7XG4gIH0gZWxzZSB7XG4gICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\n\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"./node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"./node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"./node_modules/ws/lib/sender.js\");\nconst { isBlob } = __webpack_require__(/*! ./validation */ \"./node_modules/ws/lib/validation.js\");\n\nconst {\n  BINARY_TYPES,\n  EMPTY_BUFFER,\n  GUID,\n  kForOnEventAttribute,\n  kListener,\n  kStatusCode,\n  kWebSocket,\n  NOOP\n} = __webpack_require__(/*! ./constants */ \"./node_modules/ws/lib/constants.js\");\nconst {\n  EventTarget: { addEventListener, removeEventListener }\n} = __webpack_require__(/*! ./event-target */ \"./node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"./node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"./node_modules/ws/lib/buffer-util.js\");\n\nconst closeTimeout = 30 * 1000;\nconst kAborted = Symbol('kAborted');\nconst protocolVersions = [8, 13];\nconst readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */\nclass WebSocket extends EventEmitter {\n  /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */\n  constructor(address, protocols, options) {\n    super();\n\n    this._binaryType = BINARY_TYPES[0];\n    this._closeCode = 1006;\n    this._closeFrameReceived = false;\n    this._closeFrameSent = false;\n    this._closeMessage = EMPTY_BUFFER;\n    this._closeTimer = null;\n    this._errorEmitted = false;\n    this._extensions = {};\n    this._paused = false;\n    this._protocol = '';\n    this._readyState = WebSocket.CONNECTING;\n    this._receiver = null;\n    this._sender = null;\n    this._socket = null;\n\n    if (address !== null) {\n      this._bufferedAmount = 0;\n      this._isServer = false;\n      this._redirects = 0;\n\n      if (protocols === undefined) {\n        protocols = [];\n      } else if (!Array.isArray(protocols)) {\n        if (typeof protocols === 'object' && protocols !== null) {\n          options = protocols;\n          protocols = [];\n        } else {\n          protocols = [protocols];\n        }\n      }\n\n      initAsClient(this, address, protocols, options);\n    } else {\n      this._autoPong = options.autoPong;\n      this._isServer = true;\n    }\n  }\n\n  /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */\n  get binaryType() {\n    return this._binaryType;\n  }\n\n  set binaryType(type) {\n    if (!BINARY_TYPES.includes(type)) return;\n\n    this._binaryType = type;\n\n    //\n    // Allow to change `binaryType` on the fly.\n    //\n    if (this._receiver) this._receiver._binaryType = type;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get bufferedAmount() {\n    if (!this._socket) return this._bufferedAmount;\n\n    return this._socket._writableState.length + this._sender._bufferedBytes;\n  }\n\n  /**\n   * @type {String}\n   */\n  get extensions() {\n    return Object.keys(this._extensions).join();\n  }\n\n  /**\n   * @type {Boolean}\n   */\n  get isPaused() {\n    return this._paused;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onclose() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onerror() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onopen() {\n    return null;\n  }\n\n  /**\n   * @type {Function}\n   */\n  /* istanbul ignore next */\n  get onmessage() {\n    return null;\n  }\n\n  /**\n   * @type {String}\n   */\n  get protocol() {\n    return this._protocol;\n  }\n\n  /**\n   * @type {Number}\n   */\n  get readyState() {\n    return this._readyState;\n  }\n\n  /**\n   * @type {String}\n   */\n  get url() {\n    return this._url;\n  }\n\n  /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */\n  setSocket(socket, head, options) {\n    const receiver = new Receiver({\n      allowSynchronousEvents: options.allowSynchronousEvents,\n      binaryType: this.binaryType,\n      extensions: this._extensions,\n      isServer: this._isServer,\n      maxPayload: options.maxPayload,\n      skipUTF8Validation: options.skipUTF8Validation\n    });\n\n    const sender = new Sender(socket, this._extensions, options.generateMask);\n\n    this._receiver = receiver;\n    this._sender = sender;\n    this._socket = socket;\n\n    receiver[kWebSocket] = this;\n    sender[kWebSocket] = this;\n    socket[kWebSocket] = this;\n\n    receiver.on('conclude', receiverOnConclude);\n    receiver.on('drain', receiverOnDrain);\n    receiver.on('error', receiverOnError);\n    receiver.on('message', receiverOnMessage);\n    receiver.on('ping', receiverOnPing);\n    receiver.on('pong', receiverOnPong);\n\n    sender.onerror = senderOnError;\n\n    //\n    // These methods may not be available if `socket` is just a `Duplex`.\n    //\n    if (socket.setTimeout) socket.setTimeout(0);\n    if (socket.setNoDelay) socket.setNoDelay();\n\n    if (head.length > 0) socket.unshift(head);\n\n    socket.on('close', socketOnClose);\n    socket.on('data', socketOnData);\n    socket.on('end', socketOnEnd);\n    socket.on('error', socketOnError);\n\n    this._readyState = WebSocket.OPEN;\n    this.emit('open');\n  }\n\n  /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */\n  emitClose() {\n    if (!this._socket) {\n      this._readyState = WebSocket.CLOSED;\n      this.emit('close', this._closeCode, this._closeMessage);\n      return;\n    }\n\n    if (this._extensions[PerMessageDeflate.extensionName]) {\n      this._extensions[PerMessageDeflate.extensionName].cleanup();\n    }\n\n    this._receiver.removeAllListeners();\n    this._readyState = WebSocket.CLOSED;\n    this.emit('close', this._closeCode, this._closeMessage);\n  }\n\n  /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */\n  close(code, data) {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this.readyState === WebSocket.CLOSING) {\n      if (\n        this._closeFrameSent &&\n        (this._closeFrameReceived || this._receiver._writableState.errorEmitted)\n      ) {\n        this._socket.end();\n      }\n\n      return;\n    }\n\n    this._readyState = WebSocket.CLOSING;\n    this._sender.close(code, data, !this._isServer, (err) => {\n      //\n      // This error is handled by the `'error'` listener on the socket. We only\n      // want to know if the close frame has been sent here.\n      //\n      if (err) return;\n\n      this._closeFrameSent = true;\n\n      if (\n        this._closeFrameReceived ||\n        this._receiver._writableState.errorEmitted\n      ) {\n        this._socket.end();\n      }\n    });\n\n    setCloseTimer(this);\n  }\n\n  /**\n   * Pause the socket.\n   *\n   * @public\n   */\n  pause() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = true;\n    this._socket.pause();\n  }\n\n  /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */\n  ping(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */\n  pong(data, mask, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof data === 'function') {\n      cb = data;\n      data = mask = undefined;\n    } else if (typeof mask === 'function') {\n      cb = mask;\n      mask = undefined;\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    if (mask === undefined) mask = !this._isServer;\n    this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n  }\n\n  /**\n   * Resume the socket.\n   *\n   * @public\n   */\n  resume() {\n    if (\n      this.readyState === WebSocket.CONNECTING ||\n      this.readyState === WebSocket.CLOSED\n    ) {\n      return;\n    }\n\n    this._paused = false;\n    if (!this._receiver._writableState.needDrain) this._socket.resume();\n  }\n\n  /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */\n  send(data, options, cb) {\n    if (this.readyState === WebSocket.CONNECTING) {\n      throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');\n    }\n\n    if (typeof options === 'function') {\n      cb = options;\n      options = {};\n    }\n\n    if (typeof data === 'number') data = data.toString();\n\n    if (this.readyState !== WebSocket.OPEN) {\n      sendAfterClose(this, data, cb);\n      return;\n    }\n\n    const opts = {\n      binary: typeof data !== 'string',\n      mask: !this._isServer,\n      compress: true,\n      fin: true,\n      ...options\n    };\n\n    if (!this._extensions[PerMessageDeflate.extensionName]) {\n      opts.compress = false;\n    }\n\n    this._sender.send(data || EMPTY_BUFFER, opts, cb);\n  }\n\n  /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */\n  terminate() {\n    if (this.readyState === WebSocket.CLOSED) return;\n    if (this.readyState === WebSocket.CONNECTING) {\n      const msg = 'WebSocket was closed before the connection was established';\n      abortHandshake(this, this._req, msg);\n      return;\n    }\n\n    if (this._socket) {\n      this._readyState = WebSocket.CLOSING;\n      this._socket.destroy();\n    }\n  }\n}\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CONNECTING', {\n  enumerable: true,\n  value: readyStates.indexOf('CONNECTING')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'OPEN', {\n  enumerable: true,\n  value: readyStates.indexOf('OPEN')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSING', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSING')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */\nObject.defineProperty(WebSocket, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */\nObject.defineProperty(WebSocket.prototype, 'CLOSED', {\n  enumerable: true,\n  value: readyStates.indexOf('CLOSED')\n});\n\n[\n  'binaryType',\n  'bufferedAmount',\n  'extensions',\n  'isPaused',\n  'protocol',\n  'readyState',\n  'url'\n].forEach((property) => {\n  Object.defineProperty(WebSocket.prototype, property, { enumerable: true });\n});\n\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n['open', 'error', 'close', 'message'].forEach((method) => {\n  Object.defineProperty(WebSocket.prototype, `on${method}`, {\n    enumerable: true,\n    get() {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) return listener[kListener];\n      }\n\n      return null;\n    },\n    set(handler) {\n      for (const listener of this.listeners(method)) {\n        if (listener[kForOnEventAttribute]) {\n          this.removeListener(method, listener);\n          break;\n        }\n      }\n\n      if (typeof handler !== 'function') return;\n\n      this.addEventListener(method, handler, {\n        [kForOnEventAttribute]: true\n      });\n    }\n  });\n});\n\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\n\nmodule.exports = WebSocket;\n\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */\nfunction initAsClient(websocket, address, protocols, options) {\n  const opts = {\n    allowSynchronousEvents: true,\n    autoPong: true,\n    protocolVersion: protocolVersions[1],\n    maxPayload: 100 * 1024 * 1024,\n    skipUTF8Validation: false,\n    perMessageDeflate: true,\n    followRedirects: false,\n    maxRedirects: 10,\n    ...options,\n    socketPath: undefined,\n    hostname: undefined,\n    protocol: undefined,\n    timeout: undefined,\n    method: 'GET',\n    host: undefined,\n    path: undefined,\n    port: undefined\n  };\n\n  websocket._autoPong = opts.autoPong;\n\n  if (!protocolVersions.includes(opts.protocolVersion)) {\n    throw new RangeError(\n      `Unsupported protocol version: ${opts.protocolVersion} ` +\n        `(supported versions: ${protocolVersions.join(', ')})`\n    );\n  }\n\n  let parsedUrl;\n\n  if (address instanceof URL) {\n    parsedUrl = address;\n  } else {\n    try {\n      parsedUrl = new URL(address);\n    } catch (e) {\n      throw new SyntaxError(`Invalid URL: ${address}`);\n    }\n  }\n\n  if (parsedUrl.protocol === 'http:') {\n    parsedUrl.protocol = 'ws:';\n  } else if (parsedUrl.protocol === 'https:') {\n    parsedUrl.protocol = 'wss:';\n  }\n\n  websocket._url = parsedUrl.href;\n\n  const isSecure = parsedUrl.protocol === 'wss:';\n  const isIpcUrl = parsedUrl.protocol === 'ws+unix:';\n  let invalidUrlMessage;\n\n  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isIpcUrl) {\n    invalidUrlMessage =\n      'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' +\n      '\"http:\", \"https\", or \"ws+unix:\"';\n  } else if (isIpcUrl && !parsedUrl.pathname) {\n    invalidUrlMessage = \"The URL's pathname is empty\";\n  } else if (parsedUrl.hash) {\n    invalidUrlMessage = 'The URL contains a fragment identifier';\n  }\n\n  if (invalidUrlMessage) {\n    const err = new SyntaxError(invalidUrlMessage);\n\n    if (websocket._redirects === 0) {\n      throw err;\n    } else {\n      emitErrorAndClose(websocket, err);\n      return;\n    }\n  }\n\n  const defaultPort = isSecure ? 443 : 80;\n  const key = randomBytes(16).toString('base64');\n  const request = isSecure ? https.request : http.request;\n  const protocolSet = new Set();\n  let perMessageDeflate;\n\n  opts.createConnection =\n    opts.createConnection || (isSecure ? tlsConnect : netConnect);\n  opts.defaultPort = opts.defaultPort || defaultPort;\n  opts.port = parsedUrl.port || defaultPort;\n  opts.host = parsedUrl.hostname.startsWith('[')\n    ? parsedUrl.hostname.slice(1, -1)\n    : parsedUrl.hostname;\n  opts.headers = {\n    ...opts.headers,\n    'Sec-WebSocket-Version': opts.protocolVersion,\n    'Sec-WebSocket-Key': key,\n    Connection: 'Upgrade',\n    Upgrade: 'websocket'\n  };\n  opts.path = parsedUrl.pathname + parsedUrl.search;\n  opts.timeout = opts.handshakeTimeout;\n\n  if (opts.perMessageDeflate) {\n    perMessageDeflate = new PerMessageDeflate(\n      opts.perMessageDeflate !== true ? opts.perMessageDeflate : {},\n      false,\n      opts.maxPayload\n    );\n    opts.headers['Sec-WebSocket-Extensions'] = format({\n      [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n    });\n  }\n  if (protocols.length) {\n    for (const protocol of protocols) {\n      if (\n        typeof protocol !== 'string' ||\n        !subprotocolRegex.test(protocol) ||\n        protocolSet.has(protocol)\n      ) {\n        throw new SyntaxError(\n          'An invalid or duplicated subprotocol was specified'\n        );\n      }\n\n      protocolSet.add(protocol);\n    }\n\n    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');\n  }\n  if (opts.origin) {\n    if (opts.protocolVersion < 13) {\n      opts.headers['Sec-WebSocket-Origin'] = opts.origin;\n    } else {\n      opts.headers.Origin = opts.origin;\n    }\n  }\n  if (parsedUrl.username || parsedUrl.password) {\n    opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n  }\n\n  if (isIpcUrl) {\n    const parts = opts.path.split(':');\n\n    opts.socketPath = parts[0];\n    opts.path = parts[1];\n  }\n\n  let req;\n\n  if (opts.followRedirects) {\n    if (websocket._redirects === 0) {\n      websocket._originalIpc = isIpcUrl;\n      websocket._originalSecure = isSecure;\n      websocket._originalHostOrSocketPath = isIpcUrl\n        ? opts.socketPath\n        : parsedUrl.host;\n\n      const headers = options && options.headers;\n\n      //\n      // Shallow copy the user provided options so that headers can be changed\n      // without mutating the original object.\n      //\n      options = { ...options, headers: {} };\n\n      if (headers) {\n        for (const [key, value] of Object.entries(headers)) {\n          options.headers[key.toLowerCase()] = value;\n        }\n      }\n    } else if (websocket.listenerCount('redirect') === 0) {\n      const isSameHost = isIpcUrl\n        ? websocket._originalIpc\n          ? opts.socketPath === websocket._originalHostOrSocketPath\n          : false\n        : websocket._originalIpc\n          ? false\n          : parsedUrl.host === websocket._originalHostOrSocketPath;\n\n      if (!isSameHost || (websocket._originalSecure && !isSecure)) {\n        //\n        // Match curl 7.77.0 behavior and drop the following headers. These\n        // headers are also dropped when following a redirect to a subdomain.\n        //\n        delete opts.headers.authorization;\n        delete opts.headers.cookie;\n\n        if (!isSameHost) delete opts.headers.host;\n\n        opts.auth = undefined;\n      }\n    }\n\n    //\n    // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n    // If the `Authorization` header is set, then there is nothing to do as it\n    // will take precedence.\n    //\n    if (opts.auth && !options.headers.authorization) {\n      options.headers.authorization =\n        'Basic ' + Buffer.from(opts.auth).toString('base64');\n    }\n\n    req = websocket._req = request(opts);\n\n    if (websocket._redirects) {\n      //\n      // Unlike what is done for the `'upgrade'` event, no early exit is\n      // triggered here if the user calls `websocket.close()` or\n      // `websocket.terminate()` from a listener of the `'redirect'` event. This\n      // is because the user can also call `request.destroy()` with an error\n      // before calling `websocket.close()` or `websocket.terminate()` and this\n      // would result in an error being emitted on the `request` object with no\n      // `'error'` event listeners attached.\n      //\n      websocket.emit('redirect', websocket.url, req);\n    }\n  } else {\n    req = websocket._req = request(opts);\n  }\n\n  if (opts.timeout) {\n    req.on('timeout', () => {\n      abortHandshake(websocket, req, 'Opening handshake has timed out');\n    });\n  }\n\n  req.on('error', (err) => {\n    if (req === null || req[kAborted]) return;\n\n    req = websocket._req = null;\n    emitErrorAndClose(websocket, err);\n  });\n\n  req.on('response', (res) => {\n    const location = res.headers.location;\n    const statusCode = res.statusCode;\n\n    if (\n      location &&\n      opts.followRedirects &&\n      statusCode >= 300 &&\n      statusCode < 400\n    ) {\n      if (++websocket._redirects > opts.maxRedirects) {\n        abortHandshake(websocket, req, 'Maximum redirects exceeded');\n        return;\n      }\n\n      req.abort();\n\n      let addr;\n\n      try {\n        addr = new URL(location, address);\n      } catch (e) {\n        const err = new SyntaxError(`Invalid URL: ${location}`);\n        emitErrorAndClose(websocket, err);\n        return;\n      }\n\n      initAsClient(websocket, addr, protocols, options);\n    } else if (!websocket.emit('unexpected-response', req, res)) {\n      abortHandshake(\n        websocket,\n        req,\n        `Unexpected server response: ${res.statusCode}`\n      );\n    }\n  });\n\n  req.on('upgrade', (res, socket, head) => {\n    websocket.emit('upgrade', res);\n\n    //\n    // The user may have closed the connection from a listener of the\n    // `'upgrade'` event.\n    //\n    if (websocket.readyState !== WebSocket.CONNECTING) return;\n\n    req = websocket._req = null;\n\n    const upgrade = res.headers.upgrade;\n\n    if (upgrade === undefined || upgrade.toLowerCase() !== 'websocket') {\n      abortHandshake(websocket, socket, 'Invalid Upgrade header');\n      return;\n    }\n\n    const digest = createHash('sha1')\n      .update(key + GUID)\n      .digest('base64');\n\n    if (res.headers['sec-websocket-accept'] !== digest) {\n      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');\n      return;\n    }\n\n    const serverProt = res.headers['sec-websocket-protocol'];\n    let protError;\n\n    if (serverProt !== undefined) {\n      if (!protocolSet.size) {\n        protError = 'Server sent a subprotocol but none was requested';\n      } else if (!protocolSet.has(serverProt)) {\n        protError = 'Server sent an invalid subprotocol';\n      }\n    } else if (protocolSet.size) {\n      protError = 'Server sent no subprotocol';\n    }\n\n    if (protError) {\n      abortHandshake(websocket, socket, protError);\n      return;\n    }\n\n    if (serverProt) websocket._protocol = serverProt;\n\n    const secWebSocketExtensions = res.headers['sec-websocket-extensions'];\n\n    if (secWebSocketExtensions !== undefined) {\n      if (!perMessageDeflate) {\n        const message =\n          'Server sent a Sec-WebSocket-Extensions header but no extension ' +\n          'was requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      let extensions;\n\n      try {\n        extensions = parse(secWebSocketExtensions);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      const extensionNames = Object.keys(extensions);\n\n      if (\n        extensionNames.length !== 1 ||\n        extensionNames[0] !== PerMessageDeflate.extensionName\n      ) {\n        const message = 'Server indicated an extension that was not requested';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      try {\n        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n      } catch (err) {\n        const message = 'Invalid Sec-WebSocket-Extensions header';\n        abortHandshake(websocket, socket, message);\n        return;\n      }\n\n      websocket._extensions[PerMessageDeflate.extensionName] =\n        perMessageDeflate;\n    }\n\n    websocket.setSocket(socket, head, {\n      allowSynchronousEvents: opts.allowSynchronousEvents,\n      generateMask: opts.generateMask,\n      maxPayload: opts.maxPayload,\n      skipUTF8Validation: opts.skipUTF8Validation\n    });\n  });\n\n  if (opts.finishRequest) {\n    opts.finishRequest(req, websocket);\n  } else {\n    req.end();\n  }\n}\n\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */\nfunction emitErrorAndClose(websocket, err) {\n  websocket._readyState = WebSocket.CLOSING;\n  //\n  // The following assignment is practically useless and is done only for\n  // consistency.\n  //\n  websocket._errorEmitted = true;\n  websocket.emit('error', err);\n  websocket.emitClose();\n}\n\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */\nfunction netConnect(options) {\n  options.path = options.socketPath;\n  return net.connect(options);\n}\n\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */\nfunction tlsConnect(options) {\n  options.path = undefined;\n\n  if (!options.servername && options.servername !== '') {\n    options.servername = net.isIP(options.host) ? '' : options.host;\n  }\n\n  return tls.connect(options);\n}\n\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */\nfunction abortHandshake(websocket, stream, message) {\n  websocket._readyState = WebSocket.CLOSING;\n\n  const err = new Error(message);\n  Error.captureStackTrace(err, abortHandshake);\n\n  if (stream.setHeader) {\n    stream[kAborted] = true;\n    stream.abort();\n\n    if (stream.socket && !stream.socket.destroyed) {\n      //\n      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n      // called after the request completed. See\n      // https://github.com/websockets/ws/issues/1869.\n      //\n      stream.socket.destroy();\n    }\n\n    process.nextTick(emitErrorAndClose, websocket, err);\n  } else {\n    stream.destroy(err);\n    stream.once('error', websocket.emit.bind(websocket, 'error'));\n    stream.once('close', websocket.emitClose.bind(websocket));\n  }\n}\n\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */\nfunction sendAfterClose(websocket, data, cb) {\n  if (data) {\n    const length = isBlob(data) ? data.size : toBuffer(data).length;\n\n    //\n    // The `_bufferedAmount` property is used only when the peer is a client and\n    // the opening handshake fails. Under these circumstances, in fact, the\n    // `setSocket()` method is not called, so the `_socket` and `_sender`\n    // properties are set to `null`.\n    //\n    if (websocket._socket) websocket._sender._bufferedBytes += length;\n    else websocket._bufferedAmount += length;\n  }\n\n  if (cb) {\n    const err = new Error(\n      `WebSocket is not open: readyState ${websocket.readyState} ` +\n        `(${readyStates[websocket.readyState]})`\n    );\n    process.nextTick(cb, err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */\nfunction receiverOnConclude(code, reason) {\n  const websocket = this[kWebSocket];\n\n  websocket._closeFrameReceived = true;\n  websocket._closeMessage = reason;\n  websocket._closeCode = code;\n\n  if (websocket._socket[kWebSocket] === undefined) return;\n\n  websocket._socket.removeListener('data', socketOnData);\n  process.nextTick(resume, websocket._socket);\n\n  if (code === 1005) websocket.close();\n  else websocket.close(code, reason);\n}\n\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */\nfunction receiverOnDrain() {\n  const websocket = this[kWebSocket];\n\n  if (!websocket.isPaused) websocket._socket.resume();\n}\n\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */\nfunction receiverOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._socket[kWebSocket] !== undefined) {\n    websocket._socket.removeListener('data', socketOnData);\n\n    //\n    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n    // https://github.com/websockets/ws/issues/1940.\n    //\n    process.nextTick(resume, websocket._socket);\n\n    websocket.close(err[kStatusCode]);\n  }\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */\nfunction receiverOnFinish() {\n  this[kWebSocket].emitClose();\n}\n\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */\nfunction receiverOnMessage(data, isBinary) {\n  this[kWebSocket].emit('message', data, isBinary);\n}\n\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */\nfunction receiverOnPing(data) {\n  const websocket = this[kWebSocket];\n\n  if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n  websocket.emit('ping', data);\n}\n\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */\nfunction receiverOnPong(data) {\n  this[kWebSocket].emit('pong', data);\n}\n\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */\nfunction resume(stream) {\n  stream.resume();\n}\n\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */\nfunction senderOnError(err) {\n  const websocket = this[kWebSocket];\n\n  if (websocket.readyState === WebSocket.CLOSED) return;\n  if (websocket.readyState === WebSocket.OPEN) {\n    websocket._readyState = WebSocket.CLOSING;\n    setCloseTimer(websocket);\n  }\n\n  //\n  // `socket.end()` is used instead of `socket.destroy()` to allow the other\n  // peer to finish sending queued data. There is no need to set a timer here\n  // because `CLOSING` means that it is already set or not needed.\n  //\n  this._socket.end();\n\n  if (!websocket._errorEmitted) {\n    websocket._errorEmitted = true;\n    websocket.emit('error', err);\n  }\n}\n\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */\nfunction setCloseTimer(websocket) {\n  websocket._closeTimer = setTimeout(\n    websocket._socket.destroy.bind(websocket._socket),\n    closeTimeout\n  );\n}\n\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */\nfunction socketOnClose() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('close', socketOnClose);\n  this.removeListener('data', socketOnData);\n  this.removeListener('end', socketOnEnd);\n\n  websocket._readyState = WebSocket.CLOSING;\n\n  let chunk;\n\n  //\n  // The close frame might not have been received or the `'end'` event emitted,\n  // for example, if the socket was destroyed due to an error. Ensure that the\n  // `receiver` stream is closed after writing any remaining buffered data to\n  // it. If the readable side of the socket is in flowing mode then there is no\n  // buffered data as everything has been already written and `readable.read()`\n  // will return `null`. If instead, the socket is paused, any possible buffered\n  // data will be read as a single chunk.\n  //\n  if (\n    !this._readableState.endEmitted &&\n    !websocket._closeFrameReceived &&\n    !websocket._receiver._writableState.errorEmitted &&\n    (chunk = websocket._socket.read()) !== null\n  ) {\n    websocket._receiver.write(chunk);\n  }\n\n  websocket._receiver.end();\n\n  this[kWebSocket] = undefined;\n\n  clearTimeout(websocket._closeTimer);\n\n  if (\n    websocket._receiver._writableState.finished ||\n    websocket._receiver._writableState.errorEmitted\n  ) {\n    websocket.emitClose();\n  } else {\n    websocket._receiver.on('error', receiverOnFinish);\n    websocket._receiver.on('finish', receiverOnFinish);\n  }\n}\n\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */\nfunction socketOnData(chunk) {\n  if (!this[kWebSocket]._receiver.write(chunk)) {\n    this.pause();\n  }\n}\n\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */\nfunction socketOnEnd() {\n  const websocket = this[kWebSocket];\n\n  websocket._readyState = WebSocket.CLOSING;\n  websocket._receiver.end();\n  this.end();\n}\n\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */\nfunction socketOnError() {\n  const websocket = this[kWebSocket];\n\n  this.removeListener('error', socketOnError);\n  this.on('error', NOOP);\n\n  if (websocket) {\n    websocket._readyState = WebSocket.CLOSING;\n    this.destroy();\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsR0FBRztBQUNoQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCLGFBQWEsVUFBVTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBLGNBQWMsUUFBUTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsa0JBQWtCO0FBQzNFLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSCxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsY0FBYztBQUN6QixXQUFXLE9BQU87QUFDbEIsV0FBVyxRQUFRO0FBQ25CLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0EsV0FBVyxrQkFBa0I7QUFDN0I7QUFDQSxXQUFXLFFBQVE7QUFDbkI7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsdUNBQXVDLHNCQUFzQjtBQUM3RCxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFtQixHQUFHLG1CQUFtQjtBQUM1RDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7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O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsV0FBVztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvd3MvbGliL3dlYnNvY2tldC5qcz9iOTUwIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleHxSZWFkYWJsZSRcIiwgXCJjYXVnaHRFcnJvcnNcIjogXCJub25lXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IER1cGxleCwgUmVhZGFibGUgfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuY29uc3QgeyBVUkwgfSA9IHJlcXVpcmUoJ3VybCcpO1xuXG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBSZWNlaXZlciA9IHJlcXVpcmUoJy4vcmVjZWl2ZXInKTtcbmNvbnN0IFNlbmRlciA9IHJlcXVpcmUoJy4vc2VuZGVyJyk7XG5jb25zdCB7IGlzQmxvYiB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIEdVSUQsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlLFxuICBrTGlzdGVuZXIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0LFxuICBOT09QXG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHtcbiAgRXZlbnRUYXJnZXQ6IHsgYWRkRXZlbnRMaXN0ZW5lciwgcmVtb3ZlRXZlbnRMaXN0ZW5lciB9XG59ID0gcmVxdWlyZSgnLi9ldmVudC10YXJnZXQnKTtcbmNvbnN0IHsgZm9ybWF0LCBwYXJzZSB9ID0gcmVxdWlyZSgnLi9leHRlbnNpb24nKTtcbmNvbnN0IHsgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuY29uc3Qga0Fib3J0ZWQgPSBTeW1ib2woJ2tBYm9ydGVkJyk7XG5jb25zdCBwcm90b2NvbFZlcnNpb25zID0gWzgsIDEzXTtcbmNvbnN0IHJlYWR5U3RhdGVzID0gWydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXTtcbmNvbnN0IHN1YnByb3RvY29sUmVnZXggPSAvXlshIyQlJicqK1xcLS4wLTlBLVpeX2B8YS16fl0rJC87XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAgICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW3Byb3RvY29sc10gVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VDb2RlID0gMTAwNjtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9IEVNUFRZX0JVRkZFUjtcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcHJvdG9jb2wgPSAnJztcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcblxuICAgICAgaWYgKHByb3RvY29scyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xuICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh0aGlzLCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9hdXRvUG9uZyA9IG9wdGlvbnMuYXV0b1Bvbmc7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvciBoaXN0b3JpY2FsIHJlYXNvbnMsIHRoZSBjdXN0b20gXCJub2RlYnVmZmVyXCIgdHlwZSBpcyB1c2VkIGJ5IHRoZSBkZWZhdWx0XG4gICAqIGluc3RlYWQgb2YgXCJibG9iXCIuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgYmluYXJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlKHR5cGUpIHtcbiAgICBpZiAoIUJJTkFSWV9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IHRvIGNoYW5nZSBgYmluYXJ5VHlwZWAgb24gdGhlIGZseS5cbiAgICAvL1xuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDtcblxuICAgIHJldHVybiB0aGlzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUubGVuZ3RoICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXh0ZW5zaW9ucykuam9pbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtCb29sZWFufVxuICAgKi9cbiAgZ2V0IGlzUGF1c2VkKCkge1xuICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uY2xvc2UoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9uZXJyb3IoKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ub3BlbigpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7RnVuY3Rpb259XG4gICAqL1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBnZXQgb25tZXNzYWdlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgcHJvdG9jb2woKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Byb3RvY29sO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZHlTdGF0ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHVybCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdXJsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB1cCB0aGUgc29ja2V0IGFuZCB0aGUgaW50ZXJuYWwgcmVzb3VyY2VzLlxuICAgKlxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcih7XG4gICAgICBhbGxvd1N5bmNocm9ub3VzRXZlbnRzOiBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBiaW5hcnlUeXBlOiB0aGlzLmJpbmFyeVR5cGUsXG4gICAgICBleHRlbnNpb25zOiB0aGlzLl9leHRlbnNpb25zLFxuICAgICAgaXNTZXJ2ZXI6IHRoaXMuX2lzU2VydmVyLFxuICAgICAgbWF4UGF5bG9hZDogb3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgY29uc3Qgc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMsIG9wdGlvbnMuZ2VuZXJhdGVNYXNrKTtcblxuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc2VuZGVyID0gc2VuZGVyO1xuICAgIHRoaXMuX3NvY2tldCA9IHNvY2tldDtcblxuICAgIHJlY2VpdmVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzZW5kZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIHNlbmRlci5vbmVycm9yID0gc2VuZGVyT25FcnJvcjtcblxuICAgIC8vXG4gICAgLy8gVGhlc2UgbWV0aG9kcyBtYXkgbm90IGJlIGF2YWlsYWJsZSBpZiBgc29ja2V0YCBpcyBqdXN0IGEgYER1cGxleGAuXG4gICAgLy9cbiAgICBpZiAoc29ja2V0LnNldFRpbWVvdXQpIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIGlmIChzb2NrZXQuc2V0Tm9EZWxheSkgc29ja2V0LnNldE5vRGVsYXkoKTtcblxuICAgIGlmIChoZWFkLmxlbmd0aCA+IDApIHNvY2tldC51bnNoaWZ0KGhlYWQpO1xuXG4gICAgc29ja2V0Lm9uKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICAgIHNvY2tldC5vbignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gICAgc29ja2V0Lm9uKCdlbmQnLCBzb2NrZXRPbkVuZCk7XG4gICAgc29ja2V0Lm9uKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5PUEVOO1xuICAgIHRoaXMuZW1pdCgnb3BlbicpO1xuICB9XG5cbiAgLyoqXG4gICAqIEVtaXQgdGhlIGAnY2xvc2UnYCBldmVudC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVtaXRDbG9zZSgpIHtcbiAgICBpZiAoIXRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdLmNsZWFudXAoKTtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NFRDtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgdGhpcy5fY2xvc2VDb2RlLCB0aGlzLl9jbG9zZU1lc3NhZ2UpO1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0IGEgY2xvc2luZyBoYW5kc2hha2UuXG4gICAqXG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLStcbiAgICogICAgIC0gLSAtfHdzLmNsb3NlKCl8LS0+fGNsb3NlIGZyYW1lfC0tPnx3cy5jbG9zZSgpfC0gLSAtXG4gICAqICAgIHwgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLSsgICAgIHxcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgICAgICAgIHxcbiAgICogQ0xPU0lORyAgfHdzLmNsb3NlKCl8PC0tfGNsb3NlIGZyYW1lfDwtLSstLS0tLSsgICAgICAgQ0xPU0lOR1xuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgfFxuICAgKiAgICB8ICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rICAgICAgICB8XG4gICAqICAgICAgICAgICAgICAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0rLS0+fGZpbnwgLSAtIC0gLVxuICAgKiAgICB8ICAgICAgICAgKy0tLSsgICAgICAgICAgICAgICAgICAgICAgfCAgICstLS0rXG4gICAqICAgICAtIC0gLSAtIC18ZmlufDwtLS0tLS0tLS0tLS0tLS0tLS0tLS0rXG4gICAqICAgICAgICAgICAgICArLS0tK1xuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZSBjb25uZWN0aW9uIGlzIGNsb3NpbmdcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgcmVhc29uIHdoeSB0aGUgY29ubmVjdGlvbiBpc1xuICAgKiAgICAgY2xvc2luZ1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NJTkcpIHtcbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgJiZcbiAgICAgICAgKHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fCB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHRoaXMuX3NlbmRlci5jbG9zZShjb2RlLCBkYXRhLCAhdGhpcy5faXNTZXJ2ZXIsIChlcnIpID0+IHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGVycm9yIGlzIGhhbmRsZWQgYnkgdGhlIGAnZXJyb3InYCBsaXN0ZW5lciBvbiB0aGUgc29ja2V0LiBXZSBvbmx5XG4gICAgICAvLyB3YW50IHRvIGtub3cgaWYgdGhlIGNsb3NlIGZyYW1lIGhhcyBiZWVuIHNlbnQgaGVyZS5cbiAgICAgIC8vXG4gICAgICBpZiAoZXJyKSByZXR1cm47XG5cbiAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gdHJ1ZTtcblxuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHxcbiAgICAgICAgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkXG4gICAgICApIHtcbiAgICAgICAgdGhpcy5fc29ja2V0LmVuZCgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgc2V0Q2xvc2VUaW1lcih0aGlzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXVzZSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICBwYXVzZSgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRURcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgIHRoaXMuX3NvY2tldC5wYXVzZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwaW5nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBpbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwaW5nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBpbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcG9uZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwb25nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcG9uZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5wb25nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogUmVzdW1lIHRoZSBzb2NrZXQuXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHJlc3VtZSgpIHtcbiAgICBpZiAoXG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HIHx8XG4gICAgICB0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRURcbiAgICApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICBpZiAoIXRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbikgdGhpcy5fc29ja2V0LnJlc3VtZSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBkYXRhIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnldIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnkgb3JcbiAgICogICAgIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzc10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgdGhlIGZyYWdtZW50IGlzIHRoZVxuICAgKiAgICAgbGFzdCBvbmVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIGRhdGEgaXMgd3JpdHRlbiBvdXRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgc2VuZChkYXRhLCBvcHRpb25zLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBvcHRpb25zO1xuICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdHMgPSB7XG4gICAgICBiaW5hcnk6IHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJyxcbiAgICAgIG1hc2s6ICF0aGlzLl9pc1NlcnZlcixcbiAgICAgIGNvbXByZXNzOiB0cnVlLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgLi4ub3B0aW9uc1xuICAgIH07XG5cbiAgICBpZiAoIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLl9zZW5kZXIuc2VuZChkYXRhIHx8IEVNUFRZX0JVRkZFUiwgb3B0cywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZvcmNpYmx5IGNsb3NlIHRoZSBjb25uZWN0aW9uLlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICB0ZXJtaW5hdGUoKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNMT1NFRCkgcmV0dXJuO1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICBjb25zdCBtc2cgPSAnV2ViU29ja2V0IHdhcyBjbG9zZWQgYmVmb3JlIHRoZSBjb25uZWN0aW9uIHdhcyBlc3RhYmxpc2hlZCc7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh0aGlzLCB0aGlzLl9yZXEsIG1zZyk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3NvY2tldCkge1xuICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgICAgdGhpcy5fc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ09OTkVDVElORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ09OTkVDVElORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NPTk5FQ1RJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ09QRU4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ09QRU4nLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdPUEVOJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0lORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDTE9TRUQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDTE9TRUQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TRUQnKVxufSk7XG5cbltcbiAgJ2JpbmFyeVR5cGUnLFxuICAnYnVmZmVyZWRBbW91bnQnLFxuICAnZXh0ZW5zaW9ucycsXG4gICdpc1BhdXNlZCcsXG4gICdwcm90b2NvbCcsXG4gICdyZWFkeVN0YXRlJyxcbiAgJ3VybCdcbl0uZm9yRWFjaCgocHJvcGVydHkpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIHByb3BlcnR5LCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG59KTtcblxuLy9cbi8vIEFkZCB0aGUgYG9ub3BlbmAsIGBvbmVycm9yYCwgYG9uY2xvc2VgLCBhbmQgYG9ubWVzc2FnZWAgYXR0cmlidXRlcy5cbi8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9jb21tcy5odG1sI3RoZS13ZWJzb2NrZXQtaW50ZXJmYWNlXG4vL1xuWydvcGVuJywgJ2Vycm9yJywgJ2Nsb3NlJywgJ21lc3NhZ2UnXS5mb3JFYWNoKChtZXRob2QpID0+IHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsIGBvbiR7bWV0aG9kfWAsIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGdldCgpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSByZXR1cm4gbGlzdGVuZXJba0xpc3RlbmVyXTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfSxcbiAgICBzZXQoaGFuZGxlcikge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKG1ldGhvZCwgbGlzdGVuZXIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0eXBlb2YgaGFuZGxlciAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuO1xuXG4gICAgICB0aGlzLmFkZEV2ZW50TGlzdGVuZXIobWV0aG9kLCBoYW5kbGVyLCB7XG4gICAgICAgIFtrRm9yT25FdmVudEF0dHJpYnV0ZV06IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59KTtcblxuV2ViU29ja2V0LnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gYWRkRXZlbnRMaXN0ZW5lcjtcbldlYlNvY2tldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IHJlbW92ZUV2ZW50TGlzdGVuZXI7XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0O1xuXG4vKipcbiAqIEluaXRpYWxpemUgYSBXZWJTb2NrZXQgY2xpZW50LlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIGNsaWVudCB0byBpbml0aWFsaXplXG4gKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAqIEBwYXJhbSB7QXJyYXl9IHByb3RvY29scyBUaGUgc3VicHJvdG9jb2xzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIGFueVxuICogICAgIG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWQgbXVsdGlwbGVcbiAqICAgICB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmF1dG9Qb25nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICogICAgIGF1dG9tYXRpY2FsbHkgc2VuZCBhIHBvbmcgaW4gcmVzcG9uc2UgdG8gYSBwaW5nXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5maW5pc2hSZXF1ZXN0XSBBIGZ1bmN0aW9uIHdoaWNoIGNhbiBiZSB1c2VkIHRvXG4gKiAgICAgY3VzdG9taXplIHRoZSBoZWFkZXJzIG9mIGVhY2ggaHR0cCByZXF1ZXN0IGJlZm9yZSBpdCBpcyBzZW50XG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvbGxvd1JlZGlyZWN0cz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gZm9sbG93XG4gKiAgICAgcmVkaXJlY3RzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICogICAgIG1hc2tpbmcga2V5XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGFuZHNoYWtlVGltZW91dF0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICogICAgIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZWRpcmVjdHM9MTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHNcbiAqICAgICBhbGxvd2VkXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JpZ2luXSBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT10cnVlXSBFbmFibGUvZGlzYWJsZVxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByb3RvY29sVmVyc2lvbj0xM10gVmFsdWUgb2YgdGhlXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmAgaGVhZGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcbiAgICBhdXRvUG9uZzogdHJ1ZSxcbiAgICBwcm90b2NvbFZlcnNpb246IHByb3RvY29sVmVyc2lvbnNbMV0sXG4gICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgc2tpcFVURjhWYWxpZGF0aW9uOiBmYWxzZSxcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdHJ1ZSxcbiAgICBmb2xsb3dSZWRpcmVjdHM6IGZhbHNlLFxuICAgIG1heFJlZGlyZWN0czogMTAsXG4gICAgLi4ub3B0aW9ucyxcbiAgICBzb2NrZXRQYXRoOiB1bmRlZmluZWQsXG4gICAgaG9zdG5hbWU6IHVuZGVmaW5lZCxcbiAgICBwcm90b2NvbDogdW5kZWZpbmVkLFxuICAgIHRpbWVvdXQ6IHVuZGVmaW5lZCxcbiAgICBtZXRob2Q6ICdHRVQnLFxuICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgcG9ydDogdW5kZWZpbmVkXG4gIH07XG5cbiAgd2Vic29ja2V0Ll9hdXRvUG9uZyA9IG9wdHMuYXV0b1Bvbmc7XG5cbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7b3B0cy5wcm90b2NvbFZlcnNpb259IGAgK1xuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcbiAgICApO1xuICB9XG5cbiAgbGV0IHBhcnNlZFVybDtcblxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVybCA9IG5ldyBVUkwoYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHthZGRyZXNzfWApO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3M6JztcbiAgfSBlbHNlIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09ICdodHRwczonKSB7XG4gICAgcGFyc2VkVXJsLnByb3RvY29sID0gJ3dzczonO1xuICB9XG5cbiAgd2Vic29ja2V0Ll91cmwgPSBwYXJzZWRVcmwuaHJlZjtcblxuICBjb25zdCBpc1NlY3VyZSA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzczonO1xuICBjb25zdCBpc0lwY1VybCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzK3VuaXg6JztcbiAgbGV0IGludmFsaWRVcmxNZXNzYWdlO1xuXG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgIT09ICd3czonICYmICFpc1NlY3VyZSAmJiAhaXNJcGNVcmwpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9XG4gICAgICAnVGhlIFVSTFxcJ3MgcHJvdG9jb2wgbXVzdCBiZSBvbmUgb2YgXCJ3czpcIiwgXCJ3c3M6XCIsICcgK1xuICAgICAgJ1wiaHR0cDpcIiwgXCJodHRwc1wiLCBvciBcIndzK3VuaXg6XCInO1xuICB9IGVsc2UgaWYgKGlzSXBjVXJsICYmICFwYXJzZWRVcmwucGF0aG5hbWUpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9IFwiVGhlIFVSTCdzIHBhdGhuYW1lIGlzIGVtcHR5XCI7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9ICdUaGUgVVJMIGNvbnRhaW5zIGEgZnJhZ21lbnQgaWRlbnRpZmllcic7XG4gIH1cblxuICBpZiAoaW52YWxpZFVybE1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoaW52YWxpZFVybE1lc3NhZ2UpO1xuXG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XG4gIGNvbnN0IGtleSA9IHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGNvbnN0IHJlcXVlc3QgPSBpc1NlY3VyZSA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XG4gIGNvbnN0IHByb3RvY29sU2V0ID0gbmV3IFNldCgpO1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID1cbiAgICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gfHwgKGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3QpO1xuICBvcHRzLmRlZmF1bHRQb3J0ID0gb3B0cy5kZWZhdWx0UG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcbiAgICA/IHBhcnNlZFVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSlcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgb3B0cy5oZWFkZXJzID0ge1xuICAgIC4uLm9wdHMuaGVhZGVycyxcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0J1xuICB9O1xuICBvcHRzLnBhdGggPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG5cbiAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxuICAgICk7XG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnXSA9IGZvcm1hdCh7XG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcm90b2NvbCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIXN1YnByb3RvY29sUmVnZXgudGVzdChwcm90b2NvbCkgfHxcbiAgICAgICAgcHJvdG9jb2xTZXQuaGFzKHByb3RvY29sKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAnQW4gaW52YWxpZCBvciBkdXBsaWNhdGVkIHN1YnByb3RvY29sIHdhcyBzcGVjaWZpZWQnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XG4gICAgfVxuXG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xuICB9XG4gIGlmIChvcHRzLm9yaWdpbikge1xuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc0lwY1VybCkge1xuICAgIGNvbnN0IHBhcnRzID0gb3B0cy5wYXRoLnNwbGl0KCc6Jyk7XG5cbiAgICBvcHRzLnNvY2tldFBhdGggPSBwYXJ0c1swXTtcbiAgICBvcHRzLnBhdGggPSBwYXJ0c1sxXTtcbiAgfVxuXG4gIGxldCByZXE7XG5cbiAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjID0gaXNJcGNVcmw7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlID0gaXNTZWN1cmU7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aCA9IGlzSXBjVXJsXG4gICAgICAgID8gb3B0cy5zb2NrZXRQYXRoXG4gICAgICAgIDogcGFyc2VkVXJsLmhvc3Q7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcblxuICAgICAgLy9cbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxuICAgICAgLy8gd2l0aG91dCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG5cbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3ZWJzb2NrZXQubGlzdGVuZXJDb3VudCgncmVkaXJlY3QnKSA9PT0gMCkge1xuICAgICAgY29uc3QgaXNTYW1lSG9zdCA9IGlzSXBjVXJsXG4gICAgICAgID8gd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xuICAgICAgICAgID8gb3B0cy5zb2NrZXRQYXRoID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aFxuICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgOiB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgIDogcGFyc2VkVXJsLmhvc3QgPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoO1xuXG4gICAgICBpZiAoIWlzU2FtZUhvc3QgfHwgKHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgJiYgIWlzU2VjdXJlKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgZHJvcCB0aGUgZm9sbG93aW5nIGhlYWRlcnMuIFRoZXNlXG4gICAgICAgIC8vIGhlYWRlcnMgYXJlIGFsc28gZHJvcHBlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgc3ViZG9tYWluLlxuICAgICAgICAvL1xuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuY29va2llO1xuXG4gICAgICAgIGlmICghaXNTYW1lSG9zdCkgZGVsZXRlIG9wdHMuaGVhZGVycy5ob3N0O1xuXG4gICAgICAgIG9wdHMuYXV0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBtYWtlIHRoZSBmaXJzdCBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIHdpbi5cbiAgICAvLyBJZiB0aGUgYEF1dGhvcml6YXRpb25gIGhlYWRlciBpcyBzZXQsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkbyBhcyBpdFxuICAgIC8vIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgIC8vXG4gICAgaWYgKG9wdHMuYXV0aCAmJiAhb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID1cbiAgICAgICAgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IHJlcXVlc3Qob3B0cyk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMpIHtcbiAgICAgIC8vXG4gICAgICAvLyBVbmxpa2Ugd2hhdCBpcyBkb25lIGZvciB0aGUgYCd1cGdyYWRlJ2AgZXZlbnQsIG5vIGVhcmx5IGV4aXQgaXNcbiAgICAgIC8vIHRyaWdnZXJlZCBoZXJlIGlmIHRoZSB1c2VyIGNhbGxzIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3JcbiAgICAgIC8vIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGZyb20gYSBsaXN0ZW5lciBvZiB0aGUgYCdyZWRpcmVjdCdgIGV2ZW50LiBUaGlzXG4gICAgICAvLyBpcyBiZWNhdXNlIHRoZSB1c2VyIGNhbiBhbHNvIGNhbGwgYHJlcXVlc3QuZGVzdHJveSgpYCB3aXRoIGFuIGVycm9yXG4gICAgICAvLyBiZWZvcmUgY2FsbGluZyBgd2Vic29ja2V0LmNsb3NlKClgIG9yIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGFuZCB0aGlzXG4gICAgICAvLyB3b3VsZCByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgZW1pdHRlZCBvbiB0aGUgYHJlcXVlc3RgIG9iamVjdCB3aXRoIG5vXG4gICAgICAvLyBgJ2Vycm9yJ2AgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkLlxuICAgICAgLy9cbiAgICAgIHdlYnNvY2tldC5lbWl0KCdyZWRpcmVjdCcsIHdlYnNvY2tldC51cmwsIHJlcSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcbiAgfVxuXG4gIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICByZXEub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ09wZW5pbmcgaGFuZHNoYWtlIGhhcyB0aW1lZCBvdXQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlcS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcSA9PT0gbnVsbCB8fCByZXFba0Fib3J0ZWRdKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICB9KTtcblxuICByZXEub24oJ3Jlc3BvbnNlJywgKHJlcykgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuXG4gICAgaWYgKFxuICAgICAgbG9jYXRpb24gJiZcbiAgICAgIG9wdHMuZm9sbG93UmVkaXJlY3RzICYmXG4gICAgICBzdGF0dXNDb2RlID49IDMwMCAmJlxuICAgICAgc3RhdHVzQ29kZSA8IDQwMFxuICAgICkge1xuICAgICAgaWYgKCsrd2Vic29ja2V0Ll9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ01heGltdW0gcmVkaXJlY3RzIGV4Y2VlZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVxLmFib3J0KCk7XG5cbiAgICAgIGxldCBhZGRyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7bG9jYXRpb259YCk7XG4gICAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgd2Vic29ja2V0LFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZVxuICAgIC8vIGAndXBncmFkZSdgIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuXG4gICAgY29uc3QgdXBncmFkZSA9IHJlcy5oZWFkZXJzLnVwZ3JhZGU7XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoc2VydmVyUHJvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgYnV0IG5vbmUgd2FzIHJlcXVlc3RlZCc7XG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gJyArXG4gICAgICAgICAgJ3dhcyByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dGVuc2lvbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGV4dGVuc2lvbk5hbWVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnU2VydmVyIGluZGljYXRlZCBhbiBleHRlbnNpb24gdGhhdCB3YXMgbm90IHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgfVxuXG4gICAgd2Vic29ja2V0LnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdHMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIGdlbmVyYXRlTWFzazogb3B0cy5nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXhQYXlsb2FkOiBvcHRzLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdHMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChvcHRzLmZpbmlzaFJlcXVlc3QpIHtcbiAgICBvcHRzLmZpbmlzaFJlcXVlc3QocmVxLCB3ZWJzb2NrZXQpO1xuICB9IGVsc2Uge1xuICAgIHJlcS5lbmQoKTtcbiAgfVxufVxuXG4vKipcbiAqIEVtaXQgdGhlIGAnZXJyb3InYCBhbmQgYCdjbG9zZSdgIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvciB0byBlbWl0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycikge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBhc3NpZ25tZW50IGlzIHByYWN0aWNhbGx5IHVzZWxlc3MgYW5kIGlzIGRvbmUgb25seSBmb3JcbiAgLy8gY29uc2lzdGVuY3kuXG4gIC8vXG4gIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBuZXQuU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7bmV0LlNvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5ldENvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG4gIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgdGxzLlRMU1NvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge3Rscy5UTFNTb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0bHNDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gdW5kZWZpbmVkO1xuXG4gIGlmICghb3B0aW9ucy5zZXJ2ZXJuYW1lICYmIG9wdGlvbnMuc2VydmVybmFtZSAhPT0gJycpIHtcbiAgICBvcHRpb25zLnNlcnZlcm5hbWUgPSBuZXQuaXNJUChvcHRpb25zLmhvc3QpID8gJycgOiBvcHRpb25zLmhvc3Q7XG4gIH1cblxuICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQWJvcnQgdGhlIGhhbmRzaGFrZSBhbmQgZW1pdCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7KGh0dHAuQ2xpZW50UmVxdWVzdHxuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzdHJlYW0gVGhlIHJlcXVlc3QgdG9cbiAqICAgICBhYm9ydCBvciB0aGUgc29ja2V0IHRvIGRlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHN0cmVhbSwgbWVzc2FnZSkge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2UpO1xuXG4gIGlmIChzdHJlYW0uc2V0SGVhZGVyKSB7XG4gICAgc3RyZWFtW2tBYm9ydGVkXSA9IHRydWU7XG4gICAgc3RyZWFtLmFib3J0KCk7XG5cbiAgICBpZiAoc3RyZWFtLnNvY2tldCAmJiAhc3RyZWFtLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPbiBOb2RlLmpzID49IDE0LjMuMCBgcmVxdWVzdC5hYm9ydCgpYCBkb2VzIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgaWZcbiAgICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgcmVxdWVzdCBjb21wbGV0ZWQuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE4NjkuXG4gICAgICAvL1xuICAgICAgc3RyZWFtLnNvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZSwgd2Vic29ja2V0LCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgcmVhZHlTdGF0ZWAgYXR0cmlidXRlIGlzIGBDTE9TSU5HYCBvciBgQ0xPU0VEYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSBpc0Jsb2IoZGF0YSkgPyBkYXRhLnNpemUgOiB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBgX2J1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eSBpcyB1c2VkIG9ubHkgd2hlbiB0aGUgcGVlciBpcyBhIGNsaWVudCBhbmRcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNldCB0byBgbnVsbGAuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcbiAgICBlbHNlIHdlYnNvY2tldC5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGNiKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuICAgICk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XG4gIHdlYnNvY2tldC5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuICB3ZWJzb2NrZXQuX2Nsb3NlQ29kZSA9IGNvZGU7XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgaWYgKGNvZGUgPT09IDEwMDUpIHdlYnNvY2tldC5jbG9zZSgpO1xuICBlbHNlIHdlYnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2RyYWluJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICghd2Vic29ja2V0LmlzUGF1c2VkKSB3ZWJzb2NrZXQuX3NvY2tldC5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gIT09IHVuZGVmaW5lZCkge1xuICAgIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcblxuICAgIC8vXG4gICAgLy8gT24gTm9kZS5qcyA8IDE0LjAuMCB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgc3luY2hyb25vdXNseS4gU2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE5NDAuXG4gICAgLy9cbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gICAgd2Vic29ja2V0LmNsb3NlKGVycltrU3RhdHVzQ29kZV0pO1xuICB9XG5cbiAgaWYgKCF3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCkge1xuICAgIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZmluaXNoJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkZpbmlzaCgpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8QnVmZmVyW10pfSBkYXRhIFRoZSBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGJpbmFyeSBvciBub3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgnbWVzc2FnZScsIGRhdGEsIGlzQmluYXJ5KTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwaW5nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBpbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25QaW5nKGRhdGEpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9hdXRvUG9uZykgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXRoaXMuX2lzU2VydmVyLCBOT09QKTtcbiAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwb25nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBvbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Qb25nKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdwb25nJywgZGF0YSk7XG59XG5cbi8qKlxuICogUmVzdW1lIGEgcmVhZGFibGUgc3RyZWFtXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZX0gc3RyZWFtIFRoZSByZWFkYWJsZSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0pIHtcbiAgc3RyZWFtLnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBgU2VuZGVyYCBlcnJvciBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZGVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHNldENsb3NlVGltZXIod2Vic29ja2V0KTtcbiAgfVxuXG4gIC8vXG4gIC8vIGBzb2NrZXQuZW5kKClgIGlzIHVzZWQgaW5zdGVhZCBvZiBgc29ja2V0LmRlc3Ryb3koKWAgdG8gYWxsb3cgdGhlIG90aGVyXG4gIC8vIHBlZXIgdG8gZmluaXNoIHNlbmRpbmcgcXVldWVkIGRhdGEuIFRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0IGEgdGltZXIgaGVyZVxuICAvLyBiZWNhdXNlIGBDTE9TSU5HYCBtZWFucyB0aGF0IGl0IGlzIGFscmVhZHkgc2V0IG9yIG5vdCBuZWVkZWQuXG4gIC8vXG4gIHRoaXMuX3NvY2tldC5lbmQoKTtcblxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSB0aW1lciB0byBkZXN0cm95IHRoZSB1bmRlcmx5aW5nIHJhdyBzb2NrZXQgb2YgYSBXZWJTb2NrZXQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCkge1xuICB3ZWJzb2NrZXQuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxuICAgIHdlYnNvY2tldC5fc29ja2V0LmRlc3Ryb3kuYmluZCh3ZWJzb2NrZXQuX3NvY2tldCksXG4gICAgY2xvc2VUaW1lb3V0XG4gICk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdjbG9zZSdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uQ2xvc2UoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBsZXQgY2h1bms7XG5cbiAgLy9cbiAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcbiAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZSBzb2NrZXQgd2FzIGRlc3Ryb3llZCBkdWUgdG8gYW4gZXJyb3IuIEVuc3VyZSB0aGF0IHRoZVxuICAvLyBgcmVjZWl2ZXJgIHN0cmVhbSBpcyBjbG9zZWQgYWZ0ZXIgd3JpdGluZyBhbnkgcmVtYWluaW5nIGJ1ZmZlcmVkIGRhdGEgdG9cbiAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cbiAgLy8gYnVmZmVyZWQgZGF0YSBhcyBldmVyeXRoaW5nIGhhcyBiZWVuIGFscmVhZHkgd3JpdHRlbiBhbmQgYHJlYWRhYmxlLnJlYWQoKWBcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgLiBJZiBpbnN0ZWFkLCB0aGUgc29ja2V0IGlzIHBhdXNlZCwgYW55IHBvc3NpYmxlIGJ1ZmZlcmVkXG4gIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxuICAvL1xuICBpZiAoXG4gICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxuICAgICF3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJlxuICAgICF3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCAmJlxuICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcbiAgKSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "./node_modules/ws/wrapper.mjs":
/*!*************************************!*\
  !*** ./node_modules/ws/wrapper.mjs ***!
  \*************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ \"./node_modules/ws/lib/stream.js\");\n/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ \"./node_modules/ws/lib/receiver.js\");\n/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ \"./node_modules/ws/lib/sender.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ \"./node_modules/ws/lib/websocket.js\");\n/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ \"./node_modules/ws/lib/websocket-server.js\");\n\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvd3Mvd3JhcHBlci5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7QUFBb0Q7QUFDWDtBQUNKO0FBQ007QUFDYTs7QUFFdUI7QUFDL0UsaUVBQWUsOENBQVMsRUFBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMvd3Mvd3JhcHBlci5tanM/MTRhYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlV2ViU29ja2V0U3RyZWFtIGZyb20gJy4vbGliL3N0cmVhbS5qcyc7XG5pbXBvcnQgUmVjZWl2ZXIgZnJvbSAnLi9saWIvcmVjZWl2ZXIuanMnO1xuaW1wb3J0IFNlbmRlciBmcm9tICcuL2xpYi9zZW5kZXIuanMnO1xuaW1wb3J0IFdlYlNvY2tldCBmcm9tICcuL2xpYi93ZWJzb2NrZXQuanMnO1xuaW1wb3J0IFdlYlNvY2tldFNlcnZlciBmcm9tICcuL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzJztcblxuZXhwb3J0IHsgY3JlYXRlV2ViU29ja2V0U3RyZWFtLCBSZWNlaXZlciwgU2VuZGVyLCBXZWJTb2NrZXQsIFdlYlNvY2tldFNlcnZlciB9O1xuZXhwb3J0IGRlZmF1bHQgV2ViU29ja2V0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/ws/wrapper.mjs\n");

/***/ }),

/***/ "./node_modules/yallist/iterator.js":
/*!******************************************!*\
  !*** ./node_modules/yallist/iterator.js ***!
  \******************************************/
/***/ ((module) => {

"use strict";
eval("\nmodule.exports = function (Yallist) {\n  Yallist.prototype[Symbol.iterator] = function* () {\n    for (let walker = this.head; walker; walker = walker.next) {\n      yield walker.value\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMveWFsbGlzdC9pdGVyYXRvci5qcyIsIm1hcHBpbmdzIjoiQUFBWTtBQUNaO0FBQ0E7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMveWFsbGlzdC9pdGVyYXRvci5qcz80YmY1Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0J1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoWWFsbGlzdCkge1xuICBZYWxsaXN0LnByb3RvdHlwZVtTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24qICgpIHtcbiAgICBmb3IgKGxldCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlcjsgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICAgIHlpZWxkIHdhbGtlci52YWx1ZVxuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/yallist/iterator.js\n");

/***/ }),

/***/ "./node_modules/yallist/yallist.js":
/*!*****************************************!*\
  !*** ./node_modules/yallist/yallist.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\nmodule.exports = Yallist\n\nYallist.Node = Node\nYallist.create = Yallist\n\nfunction Yallist (list) {\n  var self = this\n  if (!(self instanceof Yallist)) {\n    self = new Yallist()\n  }\n\n  self.tail = null\n  self.head = null\n  self.length = 0\n\n  if (list && typeof list.forEach === 'function') {\n    list.forEach(function (item) {\n      self.push(item)\n    })\n  } else if (arguments.length > 0) {\n    for (var i = 0, l = arguments.length; i < l; i++) {\n      self.push(arguments[i])\n    }\n  }\n\n  return self\n}\n\nYallist.prototype.removeNode = function (node) {\n  if (node.list !== this) {\n    throw new Error('removing node which does not belong to this list')\n  }\n\n  var next = node.next\n  var prev = node.prev\n\n  if (next) {\n    next.prev = prev\n  }\n\n  if (prev) {\n    prev.next = next\n  }\n\n  if (node === this.head) {\n    this.head = next\n  }\n  if (node === this.tail) {\n    this.tail = prev\n  }\n\n  node.list.length--\n  node.next = null\n  node.prev = null\n  node.list = null\n\n  return next\n}\n\nYallist.prototype.unshiftNode = function (node) {\n  if (node === this.head) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var head = this.head\n  node.list = this\n  node.next = head\n  if (head) {\n    head.prev = node\n  }\n\n  this.head = node\n  if (!this.tail) {\n    this.tail = node\n  }\n  this.length++\n}\n\nYallist.prototype.pushNode = function (node) {\n  if (node === this.tail) {\n    return\n  }\n\n  if (node.list) {\n    node.list.removeNode(node)\n  }\n\n  var tail = this.tail\n  node.list = this\n  node.prev = tail\n  if (tail) {\n    tail.next = node\n  }\n\n  this.tail = node\n  if (!this.head) {\n    this.head = node\n  }\n  this.length++\n}\n\nYallist.prototype.push = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    push(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.unshift = function () {\n  for (var i = 0, l = arguments.length; i < l; i++) {\n    unshift(this, arguments[i])\n  }\n  return this.length\n}\n\nYallist.prototype.pop = function () {\n  if (!this.tail) {\n    return undefined\n  }\n\n  var res = this.tail.value\n  this.tail = this.tail.prev\n  if (this.tail) {\n    this.tail.next = null\n  } else {\n    this.head = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.shift = function () {\n  if (!this.head) {\n    return undefined\n  }\n\n  var res = this.head.value\n  this.head = this.head.next\n  if (this.head) {\n    this.head.prev = null\n  } else {\n    this.tail = null\n  }\n  this.length--\n  return res\n}\n\nYallist.prototype.forEach = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.head, i = 0; walker !== null; i++) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.next\n  }\n}\n\nYallist.prototype.forEachReverse = function (fn, thisp) {\n  thisp = thisp || this\n  for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {\n    fn.call(thisp, walker.value, i, this)\n    walker = walker.prev\n  }\n}\n\nYallist.prototype.get = function (n) {\n  for (var i = 0, walker = this.head; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.next\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.getReverse = function (n) {\n  for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {\n    // abort out of the list early if we hit a cycle\n    walker = walker.prev\n  }\n  if (i === n && walker !== null) {\n    return walker.value\n  }\n}\n\nYallist.prototype.map = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.head; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.next\n  }\n  return res\n}\n\nYallist.prototype.mapReverse = function (fn, thisp) {\n  thisp = thisp || this\n  var res = new Yallist()\n  for (var walker = this.tail; walker !== null;) {\n    res.push(fn.call(thisp, walker.value, this))\n    walker = walker.prev\n  }\n  return res\n}\n\nYallist.prototype.reduce = function (fn, initial) {\n  var acc\n  var walker = this.head\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.head) {\n    walker = this.head.next\n    acc = this.head.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = 0; walker !== null; i++) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.next\n  }\n\n  return acc\n}\n\nYallist.prototype.reduceReverse = function (fn, initial) {\n  var acc\n  var walker = this.tail\n  if (arguments.length > 1) {\n    acc = initial\n  } else if (this.tail) {\n    walker = this.tail.prev\n    acc = this.tail.value\n  } else {\n    throw new TypeError('Reduce of empty list with no initial value')\n  }\n\n  for (var i = this.length - 1; walker !== null; i--) {\n    acc = fn(acc, walker.value, i)\n    walker = walker.prev\n  }\n\n  return acc\n}\n\nYallist.prototype.toArray = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.head; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.next\n  }\n  return arr\n}\n\nYallist.prototype.toArrayReverse = function () {\n  var arr = new Array(this.length)\n  for (var i = 0, walker = this.tail; walker !== null; i++) {\n    arr[i] = walker.value\n    walker = walker.prev\n  }\n  return arr\n}\n\nYallist.prototype.slice = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = 0, walker = this.head; walker !== null && i < from; i++) {\n    walker = walker.next\n  }\n  for (; walker !== null && i < to; i++, walker = walker.next) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.sliceReverse = function (from, to) {\n  to = to || this.length\n  if (to < 0) {\n    to += this.length\n  }\n  from = from || 0\n  if (from < 0) {\n    from += this.length\n  }\n  var ret = new Yallist()\n  if (to < from || to < 0) {\n    return ret\n  }\n  if (from < 0) {\n    from = 0\n  }\n  if (to > this.length) {\n    to = this.length\n  }\n  for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {\n    walker = walker.prev\n  }\n  for (; walker !== null && i > from; i--, walker = walker.prev) {\n    ret.push(walker.value)\n  }\n  return ret\n}\n\nYallist.prototype.splice = function (start, deleteCount, ...nodes) {\n  if (start > this.length) {\n    start = this.length - 1\n  }\n  if (start < 0) {\n    start = this.length + start;\n  }\n\n  for (var i = 0, walker = this.head; walker !== null && i < start; i++) {\n    walker = walker.next\n  }\n\n  var ret = []\n  for (var i = 0; walker && i < deleteCount; i++) {\n    ret.push(walker.value)\n    walker = this.removeNode(walker)\n  }\n  if (walker === null) {\n    walker = this.tail\n  }\n\n  if (walker !== this.head && walker !== this.tail) {\n    walker = walker.prev\n  }\n\n  for (var i = 0; i < nodes.length; i++) {\n    walker = insert(this, walker, nodes[i])\n  }\n  return ret;\n}\n\nYallist.prototype.reverse = function () {\n  var head = this.head\n  var tail = this.tail\n  for (var walker = head; walker !== null; walker = walker.prev) {\n    var p = walker.prev\n    walker.prev = walker.next\n    walker.next = p\n  }\n  this.head = tail\n  this.tail = head\n  return this\n}\n\nfunction insert (self, node, value) {\n  var inserted = node === self.head ?\n    new Node(value, null, node, self) :\n    new Node(value, node, node.next, self)\n\n  if (inserted.next === null) {\n    self.tail = inserted\n  }\n  if (inserted.prev === null) {\n    self.head = inserted\n  }\n\n  self.length++\n\n  return inserted\n}\n\nfunction push (self, item) {\n  self.tail = new Node(item, self.tail, null, self)\n  if (!self.head) {\n    self.head = self.tail\n  }\n  self.length++\n}\n\nfunction unshift (self, item) {\n  self.head = new Node(item, null, self.head, self)\n  if (!self.tail) {\n    self.tail = self.head\n  }\n  self.length++\n}\n\nfunction Node (value, prev, next, list) {\n  if (!(this instanceof Node)) {\n    return new Node(value, prev, next, list)\n  }\n\n  this.list = list\n  this.value = value\n\n  if (prev) {\n    prev.next = this\n    this.prev = prev\n  } else {\n    this.prev = null\n  }\n\n  if (next) {\n    next.prev = this\n    this.next = next\n  } else {\n    this.next = null\n  }\n}\n\ntry {\n  // add if support for Symbol.iterator is present\n  __webpack_require__(/*! ./iterator.js */ \"./node_modules/yallist/iterator.js\")(Yallist)\n} catch (er) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0MsOEJBQThCO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsMkJBQTJCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFLG1CQUFPLENBQUMseURBQWU7QUFDekIsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL3ByaXR1bmwvLi9ub2RlX21vZHVsZXMveWFsbGlzdC95YWxsaXN0LmpzPzM2ZDgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5tb2R1bGUuZXhwb3J0cyA9IFlhbGxpc3RcblxuWWFsbGlzdC5Ob2RlID0gTm9kZVxuWWFsbGlzdC5jcmVhdGUgPSBZYWxsaXN0XG5cbmZ1bmN0aW9uIFlhbGxpc3QgKGxpc3QpIHtcbiAgdmFyIHNlbGYgPSB0aGlzXG4gIGlmICghKHNlbGYgaW5zdGFuY2VvZiBZYWxsaXN0KSkge1xuICAgIHNlbGYgPSBuZXcgWWFsbGlzdCgpXG4gIH1cblxuICBzZWxmLnRhaWwgPSBudWxsXG4gIHNlbGYuaGVhZCA9IG51bGxcbiAgc2VsZi5sZW5ndGggPSAwXG5cbiAgaWYgKGxpc3QgJiYgdHlwZW9mIGxpc3QuZm9yRWFjaCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGxpc3QuZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgc2VsZi5wdXNoKGl0ZW0pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgc2VsZi5wdXNoKGFyZ3VtZW50c1tpXSlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZlxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5yZW1vdmVOb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUubGlzdCAhPT0gdGhpcykge1xuICAgIHRocm93IG5ldyBFcnJvcigncmVtb3Zpbmcgbm9kZSB3aGljaCBkb2VzIG5vdCBiZWxvbmcgdG8gdGhpcyBsaXN0JylcbiAgfVxuXG4gIHZhciBuZXh0ID0gbm9kZS5uZXh0XG4gIHZhciBwcmV2ID0gbm9kZS5wcmV2XG5cbiAgaWYgKG5leHQpIHtcbiAgICBuZXh0LnByZXYgPSBwcmV2XG4gIH1cblxuICBpZiAocHJldikge1xuICAgIHByZXYubmV4dCA9IG5leHRcbiAgfVxuXG4gIGlmIChub2RlID09PSB0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBuZXh0XG4gIH1cbiAgaWYgKG5vZGUgPT09IHRoaXMudGFpbCkge1xuICAgIHRoaXMudGFpbCA9IHByZXZcbiAgfVxuXG4gIG5vZGUubGlzdC5sZW5ndGgtLVxuICBub2RlLm5leHQgPSBudWxsXG4gIG5vZGUucHJldiA9IG51bGxcbiAgbm9kZS5saXN0ID0gbnVsbFxuXG4gIHJldHVybiBuZXh0XG59XG5cbllhbGxpc3QucHJvdG90eXBlLnVuc2hpZnROb2RlID0gZnVuY3Rpb24gKG5vZGUpIHtcbiAgaWYgKG5vZGUgPT09IHRoaXMuaGVhZCkge1xuICAgIHJldHVyblxuICB9XG5cbiAgaWYgKG5vZGUubGlzdCkge1xuICAgIG5vZGUubGlzdC5yZW1vdmVOb2RlKG5vZGUpXG4gIH1cblxuICB2YXIgaGVhZCA9IHRoaXMuaGVhZFxuICBub2RlLmxpc3QgPSB0aGlzXG4gIG5vZGUubmV4dCA9IGhlYWRcbiAgaWYgKGhlYWQpIHtcbiAgICBoZWFkLnByZXYgPSBub2RlXG4gIH1cblxuICB0aGlzLmhlYWQgPSBub2RlXG4gIGlmICghdGhpcy50YWlsKSB7XG4gICAgdGhpcy50YWlsID0gbm9kZVxuICB9XG4gIHRoaXMubGVuZ3RoKytcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucHVzaE5vZGUgPSBmdW5jdGlvbiAobm9kZSkge1xuICBpZiAobm9kZSA9PT0gdGhpcy50YWlsKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICBpZiAobm9kZS5saXN0KSB7XG4gICAgbm9kZS5saXN0LnJlbW92ZU5vZGUobm9kZSlcbiAgfVxuXG4gIHZhciB0YWlsID0gdGhpcy50YWlsXG4gIG5vZGUubGlzdCA9IHRoaXNcbiAgbm9kZS5wcmV2ID0gdGFpbFxuICBpZiAodGFpbCkge1xuICAgIHRhaWwubmV4dCA9IG5vZGVcbiAgfVxuXG4gIHRoaXMudGFpbCA9IG5vZGVcbiAgaWYgKCF0aGlzLmhlYWQpIHtcbiAgICB0aGlzLmhlYWQgPSBub2RlXG4gIH1cbiAgdGhpcy5sZW5ndGgrK1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBwdXNoKHRoaXMsIGFyZ3VtZW50c1tpXSlcbiAgfVxuICByZXR1cm4gdGhpcy5sZW5ndGhcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdW5zaGlmdCh0aGlzLCBhcmd1bWVudHNbaV0pXG4gIH1cbiAgcmV0dXJuIHRoaXMubGVuZ3RoXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnBvcCA9IGZ1bmN0aW9uICgpIHtcbiAgaWYgKCF0aGlzLnRhaWwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkXG4gIH1cblxuICB2YXIgcmVzID0gdGhpcy50YWlsLnZhbHVlXG4gIHRoaXMudGFpbCA9IHRoaXMudGFpbC5wcmV2XG4gIGlmICh0aGlzLnRhaWwpIHtcbiAgICB0aGlzLnRhaWwubmV4dCA9IG51bGxcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmhlYWQgPSBudWxsXG4gIH1cbiAgdGhpcy5sZW5ndGgtLVxuICByZXR1cm4gcmVzXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNoaWZ0ID0gZnVuY3Rpb24gKCkge1xuICBpZiAoIXRoaXMuaGVhZCkge1xuICAgIHJldHVybiB1bmRlZmluZWRcbiAgfVxuXG4gIHZhciByZXMgPSB0aGlzLmhlYWQudmFsdWVcbiAgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHRcbiAgaWYgKHRoaXMuaGVhZCkge1xuICAgIHRoaXMuaGVhZC5wcmV2ID0gbnVsbFxuICB9IGVsc2Uge1xuICAgIHRoaXMudGFpbCA9IG51bGxcbiAgfVxuICB0aGlzLmxlbmd0aC0tXG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIChmbiwgdGhpc3ApIHtcbiAgdGhpc3AgPSB0aGlzcCB8fCB0aGlzXG4gIGZvciAodmFyIHdhbGtlciA9IHRoaXMuaGVhZCwgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZm9yRWFjaFJldmVyc2UgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLnRhaWwsIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCBpLCB0aGlzKVxuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cbn1cblxuWWFsbGlzdC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5nZXRSZXZlcnNlID0gZnVuY3Rpb24gKG4pIHtcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMudGFpbDsgd2Fsa2VyICE9PSBudWxsICYmIGkgPCBuOyBpKyspIHtcbiAgICAvLyBhYm9ydCBvdXQgb2YgdGhlIGxpc3QgZWFybHkgaWYgd2UgaGl0IGEgY3ljbGVcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGlmIChpID09PSBuICYmIHdhbGtlciAhPT0gbnVsbCkge1xuICAgIHJldHVybiB3YWxrZXIudmFsdWVcbiAgfVxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXAgPSBmdW5jdGlvbiAoZm4sIHRoaXNwKSB7XG4gIHRoaXNwID0gdGhpc3AgfHwgdGhpc1xuICB2YXIgcmVzID0gbmV3IFlhbGxpc3QoKVxuICBmb3IgKHZhciB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbDspIHtcbiAgICByZXMucHVzaChmbi5jYWxsKHRoaXNwLCB3YWxrZXIudmFsdWUsIHRoaXMpKVxuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5tYXBSZXZlcnNlID0gZnVuY3Rpb24gKGZuLCB0aGlzcCkge1xuICB0aGlzcCA9IHRoaXNwIHx8IHRoaXNcbiAgdmFyIHJlcyA9IG5ldyBZYWxsaXN0KClcbiAgZm9yICh2YXIgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGw7KSB7XG4gICAgcmVzLnB1c2goZm4uY2FsbCh0aGlzcCwgd2Fsa2VyLnZhbHVlLCB0aGlzKSlcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIHJldHVybiByZXNcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlID0gZnVuY3Rpb24gKGZuLCBpbml0aWFsKSB7XG4gIHZhciBhY2NcbiAgdmFyIHdhbGtlciA9IHRoaXMuaGVhZFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICBhY2MgPSBpbml0aWFsXG4gIH0gZWxzZSBpZiAodGhpcy5oZWFkKSB7XG4gICAgd2Fsa2VyID0gdGhpcy5oZWFkLm5leHRcbiAgICBhY2MgPSB0aGlzLmhlYWQudmFsdWVcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdSZWR1Y2Ugb2YgZW1wdHkgbGlzdCB3aXRoIG5vIGluaXRpYWwgdmFsdWUnKVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLm5leHRcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmVkdWNlUmV2ZXJzZSA9IGZ1bmN0aW9uIChmbiwgaW5pdGlhbCkge1xuICB2YXIgYWNjXG4gIHZhciB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgYWNjID0gaW5pdGlhbFxuICB9IGVsc2UgaWYgKHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHRoaXMudGFpbC5wcmV2XG4gICAgYWNjID0gdGhpcy50YWlsLnZhbHVlXG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignUmVkdWNlIG9mIGVtcHR5IGxpc3Qgd2l0aCBubyBpbml0aWFsIHZhbHVlJylcbiAgfVxuXG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IHdhbGtlciAhPT0gbnVsbDsgaS0tKSB7XG4gICAgYWNjID0gZm4oYWNjLCB3YWxrZXIudmFsdWUsIGkpXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuXG4gIHJldHVybiBhY2Ncbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGFyciA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDAsIHdhbGtlciA9IHRoaXMuaGVhZDsgd2Fsa2VyICE9PSBudWxsOyBpKyspIHtcbiAgICBhcnJbaV0gPSB3YWxrZXIudmFsdWVcbiAgICB3YWxrZXIgPSB3YWxrZXIubmV4dFxuICB9XG4gIHJldHVybiBhcnJcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUudG9BcnJheVJldmVyc2UgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBhcnIgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLnRhaWw7IHdhbGtlciAhPT0gbnVsbDsgaSsrKSB7XG4gICAgYXJyW2ldID0gd2Fsa2VyLnZhbHVlXG4gICAgd2Fsa2VyID0gd2Fsa2VyLnByZXZcbiAgfVxuICByZXR1cm4gYXJyXG59XG5cbllhbGxpc3QucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gIHRvID0gdG8gfHwgdGhpcy5sZW5ndGhcbiAgaWYgKHRvIDwgMCkge1xuICAgIHRvICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgZnJvbSA9IGZyb20gfHwgMFxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tICs9IHRoaXMubGVuZ3RoXG4gIH1cbiAgdmFyIHJldCA9IG5ldyBZYWxsaXN0KClcbiAgaWYgKHRvIDwgZnJvbSB8fCB0byA8IDApIHtcbiAgICByZXR1cm4gcmV0XG4gIH1cbiAgaWYgKGZyb20gPCAwKSB7XG4gICAgZnJvbSA9IDBcbiAgfVxuICBpZiAodG8gPiB0aGlzLmxlbmd0aCkge1xuICAgIHRvID0gdGhpcy5sZW5ndGhcbiAgfVxuICBmb3IgKHZhciBpID0gMCwgd2Fsa2VyID0gdGhpcy5oZWFkOyB3YWxrZXIgIT09IG51bGwgJiYgaSA8IGZyb207IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cbiAgZm9yICg7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgdG87IGkrKywgd2Fsa2VyID0gd2Fsa2VyLm5leHQpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zbGljZVJldmVyc2UgPSBmdW5jdGlvbiAoZnJvbSwgdG8pIHtcbiAgdG8gPSB0byB8fCB0aGlzLmxlbmd0aFxuICBpZiAodG8gPCAwKSB7XG4gICAgdG8gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICBmcm9tID0gZnJvbSB8fCAwXG4gIGlmIChmcm9tIDwgMCkge1xuICAgIGZyb20gKz0gdGhpcy5sZW5ndGhcbiAgfVxuICB2YXIgcmV0ID0gbmV3IFlhbGxpc3QoKVxuICBpZiAodG8gPCBmcm9tIHx8IHRvIDwgMCkge1xuICAgIHJldHVybiByZXRcbiAgfVxuICBpZiAoZnJvbSA8IDApIHtcbiAgICBmcm9tID0gMFxuICB9XG4gIGlmICh0byA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdG8gPSB0aGlzLmxlbmd0aFxuICB9XG4gIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCwgd2Fsa2VyID0gdGhpcy50YWlsOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IHRvOyBpLS0pIHtcbiAgICB3YWxrZXIgPSB3YWxrZXIucHJldlxuICB9XG4gIGZvciAoOyB3YWxrZXIgIT09IG51bGwgJiYgaSA+IGZyb207IGktLSwgd2Fsa2VyID0gd2Fsa2VyLnByZXYpIHtcbiAgICByZXQucHVzaCh3YWxrZXIudmFsdWUpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5ZYWxsaXN0LnByb3RvdHlwZS5zcGxpY2UgPSBmdW5jdGlvbiAoc3RhcnQsIGRlbGV0ZUNvdW50LCAuLi5ub2Rlcykge1xuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggLSAxXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gdGhpcy5sZW5ndGggKyBzdGFydDtcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCB3YWxrZXIgPSB0aGlzLmhlYWQ7IHdhbGtlciAhPT0gbnVsbCAmJiBpIDwgc3RhcnQ7IGkrKykge1xuICAgIHdhbGtlciA9IHdhbGtlci5uZXh0XG4gIH1cblxuICB2YXIgcmV0ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IHdhbGtlciAmJiBpIDwgZGVsZXRlQ291bnQ7IGkrKykge1xuICAgIHJldC5wdXNoKHdhbGtlci52YWx1ZSlcbiAgICB3YWxrZXIgPSB0aGlzLnJlbW92ZU5vZGUod2Fsa2VyKVxuICB9XG4gIGlmICh3YWxrZXIgPT09IG51bGwpIHtcbiAgICB3YWxrZXIgPSB0aGlzLnRhaWxcbiAgfVxuXG4gIGlmICh3YWxrZXIgIT09IHRoaXMuaGVhZCAmJiB3YWxrZXIgIT09IHRoaXMudGFpbCkge1xuICAgIHdhbGtlciA9IHdhbGtlci5wcmV2XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgd2Fsa2VyID0gaW5zZXJ0KHRoaXMsIHdhbGtlciwgbm9kZXNbaV0pXG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuWWFsbGlzdC5wcm90b3R5cGUucmV2ZXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhlYWQgPSB0aGlzLmhlYWRcbiAgdmFyIHRhaWwgPSB0aGlzLnRhaWxcbiAgZm9yICh2YXIgd2Fsa2VyID0gaGVhZDsgd2Fsa2VyICE9PSBudWxsOyB3YWxrZXIgPSB3YWxrZXIucHJldikge1xuICAgIHZhciBwID0gd2Fsa2VyLnByZXZcbiAgICB3YWxrZXIucHJldiA9IHdhbGtlci5uZXh0XG4gICAgd2Fsa2VyLm5leHQgPSBwXG4gIH1cbiAgdGhpcy5oZWFkID0gdGFpbFxuICB0aGlzLnRhaWwgPSBoZWFkXG4gIHJldHVybiB0aGlzXG59XG5cbmZ1bmN0aW9uIGluc2VydCAoc2VsZiwgbm9kZSwgdmFsdWUpIHtcbiAgdmFyIGluc2VydGVkID0gbm9kZSA9PT0gc2VsZi5oZWFkID9cbiAgICBuZXcgTm9kZSh2YWx1ZSwgbnVsbCwgbm9kZSwgc2VsZikgOlxuICAgIG5ldyBOb2RlKHZhbHVlLCBub2RlLCBub2RlLm5leHQsIHNlbGYpXG5cbiAgaWYgKGluc2VydGVkLm5leHQgPT09IG51bGwpIHtcbiAgICBzZWxmLnRhaWwgPSBpbnNlcnRlZFxuICB9XG4gIGlmIChpbnNlcnRlZC5wcmV2ID09PSBudWxsKSB7XG4gICAgc2VsZi5oZWFkID0gaW5zZXJ0ZWRcbiAgfVxuXG4gIHNlbGYubGVuZ3RoKytcblxuICByZXR1cm4gaW5zZXJ0ZWRcbn1cblxuZnVuY3Rpb24gcHVzaCAoc2VsZiwgaXRlbSkge1xuICBzZWxmLnRhaWwgPSBuZXcgTm9kZShpdGVtLCBzZWxmLnRhaWwsIG51bGwsIHNlbGYpXG4gIGlmICghc2VsZi5oZWFkKSB7XG4gICAgc2VsZi5oZWFkID0gc2VsZi50YWlsXG4gIH1cbiAgc2VsZi5sZW5ndGgrK1xufVxuXG5mdW5jdGlvbiB1bnNoaWZ0IChzZWxmLCBpdGVtKSB7XG4gIHNlbGYuaGVhZCA9IG5ldyBOb2RlKGl0ZW0sIG51bGwsIHNlbGYuaGVhZCwgc2VsZilcbiAgaWYgKCFzZWxmLnRhaWwpIHtcbiAgICBzZWxmLnRhaWwgPSBzZWxmLmhlYWRcbiAgfVxuICBzZWxmLmxlbmd0aCsrXG59XG5cbmZ1bmN0aW9uIE5vZGUgKHZhbHVlLCBwcmV2LCBuZXh0LCBsaXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOb2RlKSkge1xuICAgIHJldHVybiBuZXcgTm9kZSh2YWx1ZSwgcHJldiwgbmV4dCwgbGlzdClcbiAgfVxuXG4gIHRoaXMubGlzdCA9IGxpc3RcbiAgdGhpcy52YWx1ZSA9IHZhbHVlXG5cbiAgaWYgKHByZXYpIHtcbiAgICBwcmV2Lm5leHQgPSB0aGlzXG4gICAgdGhpcy5wcmV2ID0gcHJldlxuICB9IGVsc2Uge1xuICAgIHRoaXMucHJldiA9IG51bGxcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgbmV4dC5wcmV2ID0gdGhpc1xuICAgIHRoaXMubmV4dCA9IG5leHRcbiAgfSBlbHNlIHtcbiAgICB0aGlzLm5leHQgPSBudWxsXG4gIH1cbn1cblxudHJ5IHtcbiAgLy8gYWRkIGlmIHN1cHBvcnQgZm9yIFN5bWJvbC5pdGVyYXRvciBpcyBwcmVzZW50XG4gIHJlcXVpcmUoJy4vaXRlcmF0b3IuanMnKShZYWxsaXN0KVxufSBjYXRjaCAoZXIpIHt9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/yallist/yallist.js\n");

/***/ }),

/***/ "assert":
/*!*************************!*\
  !*** external "assert" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("assert");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("buffer");

/***/ }),

/***/ "bufferutil":
/*!*****************************!*\
  !*** external "bufferutil" ***!
  \*****************************/
/***/ ((module) => {

"use strict";
if(typeof bufferutil === 'undefined') { var e = new Error("Cannot find module 'bufferutil'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = bufferutil;

/***/ }),

/***/ "child_process":
/*!********************************!*\
  !*** external "child_process" ***!
  \********************************/
/***/ ((module) => {

"use strict";
module.exports = require("child_process");

/***/ }),

/***/ "crypto":
/*!*************************!*\
  !*** external "crypto" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("crypto");

/***/ }),

/***/ "electron":
/*!***************************!*\
  !*** external "electron" ***!
  \***************************/
/***/ ((module) => {

"use strict";
module.exports = require("electron");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("events");

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("fs");

/***/ }),

/***/ "http":
/*!***********************!*\
  !*** external "http" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("http");

/***/ }),

/***/ "https":
/*!************************!*\
  !*** external "https" ***!
  \************************/
/***/ ((module) => {

"use strict";
module.exports = require("https");

/***/ }),

/***/ "net":
/*!**********************!*\
  !*** external "net" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("net");

/***/ }),

/***/ "os":
/*!*********************!*\
  !*** external "os" ***!
  \*********************/
/***/ ((module) => {

"use strict";
module.exports = require("os");

/***/ }),

/***/ "path":
/*!***********************!*\
  !*** external "path" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("path");

/***/ }),

/***/ "process":
/*!**************************!*\
  !*** external "process" ***!
  \**************************/
/***/ ((module) => {

"use strict";
module.exports = require("process");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

"use strict";
module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
module.exports = require("string_decoder");

/***/ }),

/***/ "tls":
/*!**********************!*\
  !*** external "tls" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("tls");

/***/ }),

/***/ "url":
/*!**********************!*\
  !*** external "url" ***!
  \**********************/
/***/ ((module) => {

"use strict";
module.exports = require("url");

/***/ }),

/***/ "utf-8-validate":
/*!*********************************!*\
  !*** external "utf-8-validate" ***!
  \*********************************/
/***/ ((module) => {

"use strict";
if(typeof utf-8-validate === 'undefined') { var e = new Error("Cannot find module 'utf-8-validate'"); e.code = 'MODULE_NOT_FOUND'; throw e; }

module.exports = utf-8-validate;

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("util");

/***/ }),

/***/ "zlib":
/*!***********************!*\
  !*** external "zlib" ***!
  \***********************/
/***/ ((module) => {

"use strict";
module.exports = require("zlib");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval-source-map devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./main/Main.js");
/******/ 	
/******/ })()
;